// $Id: AufEintrag_sql.pgcc,v 1.14 2002/06/20 13:27:55 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/AufEintrag.h>
#include <Auftrag/AuftragsBaum.h>
#include <stdio.h>
#include <Aux/string0.h>
#include <Aux/Transaction.h>
#include <Aux/FetchIStream.h>
#include "auftrag_status.h"
#include <Aux/Changejournal.h>
#include "selFullAufEntry.h"
#include <Auftrag/AufEintragZu.h>
#include <Lager/Lager_Vormerkungen.h>
#include <Lager/Lager.h>
#include <Lieferschein/Lieferschein.h>
#ifdef MABELLA_EXTENSIONS
#include <Lager/FertigWaren.h>
#include <Artikel/ArtikelBase.h>
#endif
#include <Artikel/ArtikelStamm.h>
#include <Auftrag/Auftrag.h>

exec sql include sqlca;

void AufEintrag::abschreiben(mengen_t menge,
    ManuProcEntity::ID lfrsid=ManuProcEntity::none_id) throw(SQLerror)
{
 exec sql begin declare section;
  int AUFID=Id();
  int AUFZNR=ZNr();
  int INSTANZ=InstanzID();
  int STATUS=getEntryStatus();
  int GELIEFERT=(int)menge+getGeliefert();
 exec sql end declare section;
//if(Id()==2) ECPGdebug(1,stdout);

// GELIEFERT=(int)menge+getGeliefert();

 if(menge>=0 && getEntryStatus()!=(AufStatVal)OPEN) 
    throw(SQLerror(__FILELINE__,-1,"Auftragszeile ist nicht offen sondern "+itos(STATUS)));
 if(menge<0 && getEntryStatus()==(AufStatVal)UNCOMMITED) 
    throw(SQLerror(__FILELINE__,-1,"Auftragszeile ist nicht bestätigt"));

 AufStatVal oldstatus=getEntryStatus();

 if(GELIEFERT>=getStueck()) STATUS=(AufStatVal)CLOSED;
 else if(menge<0 && GELIEFERT<getStueck()) STATUS=(AufStatVal)OPEN;

#ifdef PETIG_EXTENSIONS
 if(STATUS!=oldstatus && Id()!=dispo_auftrag_id)
#else
 if(STATUS!=oldstatus)
#endif
     setStatus(AufStatVal(STATUS),true);

 Transaction tr;
 exec sql lock table auftragentry in exclusive mode;
 exec sql update auftragentry set geliefert= :GELIEFERT, status= :STATUS
   where (instanz,auftragid,zeilennr) = (:INSTANZ,:AUFID,:AUFZNR);
 SQLerror::test(__FILELINE__);
 
#ifdef PETIG_EXTENSIONS
 // Um die Instanzen darunter kümmern:
// if(Id()!=dispo_auftrag_id)
//assert(!"Hier sollte 'produziert werden, oder?");
//    abschreiben_fuer_Instanzen(menge);
#endif

#ifdef MABELLA_EXTENSIONS // Lager updaten
 FertigWaren fw(Artikel(),(FertigWaren::enum_Aktion)'L',(int)menge,lfrsid);
 if(menge < 0) fw.Einlagern(1);
 else if(menge > 0) fw.Auslagern(1);
#endif

 setLetzteLieferung(Petig::Datum::today());
 tr.commit();
//if(Id()==2) exit(0);

 geliefert=GELIEFERT;
 if(geliefert>=bestellt) entrystatus=(AufStatVal)CLOSED;
}


void AufEintrag::setStatus(AufStatVal newstatus,int uid,bool force) throw(SQLerror)
{
 if(newstatus == STORNO) force=true;

 if(entrystatus == CLOSED && !force ) return; // nichts geht mehr
 if(newstatus == UNCOMMITED) return; // zurück geht nicht, nur vor
 if(entrystatus == newstatus) return;     // nichts geändert
 if(newstatus == OPEN && entrystatus != UNCOMMITED && !force) return;


 Transaction tr; 
 exec sql lock auftragentry in exclusive mode;
 SQLerror::test("setStatus: lock table auftragentry");
  
 std::string sqlcommand = "update auftragentry set status="+itos(newstatus);
 if(uid) sqlcommand+=", lasteditdate = now(), lastedit_uid="+itos(uid);
 sqlcommand +=" where (instanz,auftragid,zeilennr)=("+itos(Instanz()->Id())
              +","+itos(auftragid)+","+itos(zeilennr)+")";

 Query::Execute(sqlcommand);
 SQLerror::test("setStatus: update auftragentry");
 AufStatVal oldentrystatus=entrystatus;
 entrystatus=newstatus;

 if(newstatus==OPEN && auftragstatus==UNCOMMITED)
    setStatusAuftragBase(newstatus);

 if(newstatus == OPEN  &&  oldentrystatus==UNCOMMITED)
   {
    if(Instanz()==ppsInstanzID::Kundenauftraege)
      { cH_ppsInstanz i=ArtikelStamm(artikel).BestellenBei();
        if (i!=ppsInstanzID::None && i!=ppsInstanzID::Kundenauftraege)
         {  AuftragBase AB(ArtikelStamm(artikel).BestellenBei(),AuftragBase::ungeplante_id);
            AB.tryUpdateEntry(getStueck(),lieferdatum,Artikel(),newstatus,uid,*this);
         }
      }
    else 
      InstanzAuftraegeAnlegen(artikel,ZNr(),lieferdatum,newstatus,uid,bestellt);
   }
 else  // Status für die Instanzen setzen
    setInstanzen(newstatus,uid,getLieferdatum(),getStueck());

 if(newstatus==OPEN)
   {
    pps_ChJournalEntry::newChange(
			instanz, *this, artikel,
			(double)bestellt,
			(double)bestellt,
			pps_ChJournalEntry::CH_MENGE);
  }
 else if(newstatus==CLOSED && oldentrystatus!=UNCOMMITED) 
 // UNCOMMITED->CLOSED => kein Eintrag
   {
    pps_ChJournalEntry::newChange(
			instanz, *this, artikel,
			(double)geliefert,
			(double)geliefert-bestellt,
			pps_ChJournalEntry::CH_MENGE);
   }

 tr.commit(); 
}


void AufEintrag::setInstanzen(AufStatVal newstatus,int uid,Petig::Datum lieferdate,mengen_t Menge,int myznr,int yourznr)
{
 std::list<AufEintragZu::st_reflist> KindListe = AufEintragZu(*this).get_Referenz_list(*this,true);
 for(std::list<AufEintragZu::st_reflist>::const_iterator i=KindListe.begin();i!=KindListe.end();++i)
  {
    ArtikelBaum::menge_t f=ArtikelBaum(artikel).Faktor(i->Art);
//    mengen_t M=Menge*f;    
   mengen_t Mauftrag=AufEintrag(i->AEB).getRestStk();
   mengen_t Mzuordnung=i->Menge;
//cout << *this <<'\t'<<i->AEB<<'\t'<<Mauftrag<<' '<<i->Menge<<' '
//<<AufEintrag(i->AEB).getRestStk()<<'\n';
   AufEintrag AE(i->AEB);
   // AufEintrag splitten und Anlegen in der Zuordnungsliste
   int znr=0,newznr=0; mengen_t menge=0;
   if(!i->AEB.existEntry(i->Art,lieferdate,znr,newznr,menge,newstatus))
     {
      znr=AE.insertNewEntry(Mauftrag,lieferdate,i->Art,newstatus,uid,false); //false=KEINE Instanzen
      AufEintragBase neuAEB(AE,znr);
      if(Instanz()==ppsInstanzID::Kundenauftraege) 
            AufEintragZu(*this).setKindZnr(neuAEB);
      else 
         {
//cout << Instanz()->Id()<<' '<<Id()<<' '<<ZNr()<<'\t'<<-M<<'\n';
            AufEintragZu(*this).Neu(neuAEB,Mzuordnung,myznr);
            mengen_t mtt=AufEintragZu(*this).setMengeDiff__(AE,-Mzuordnung);
//cout << *this<<'\t'<<AE<<'\t'<<-M<<'\t'<<mtt<<'\n';
//            assert(mtt==-M);
         }
     }
   else
     {
//std::cout << "existEntry :"<<Instanz()<<' '<<Id()<<' '<<AE.Instanz()<<' '
//      <<AE.Id()<<" Myznr:"<<myznr<<" Yourznr: "<<yourznr<<" Znr: "<<znr
//<<" NEWZnr: "<<newznr<<'\t';
//std::cout << menge<<'+'<<M<<'='<<menge+M<<'\n';
      AufEintragBase AEBZ(AE,znr); 
      mengen_t mt=AEBZ.updateStkDiffBase__(uid,Mauftrag);
//cout <<*this<<'\t'<< AEBZ<<'\t'<<mt<<' '<<M<<'\n';
      assert(mt==Mauftrag);
      if(Instanz()==ppsInstanzID::Kundenauftraege) 
            AufEintragZu(*this).setKindZnr(AEBZ);
      else 
         {
//std::cout<<"Reduce:   "<<Id()<<' '<<ZNr()<<'\t'<<AE.Id()<<' '<<AE.ZNr()<<'\t'<<i->Menge<<'\n';
            mengen_t mts=AufEintragZu(*this).setMengeDiff__(AE,-Mzuordnung);
//cout <<*this<<'\t'<< AE<<'\t'<<mts<<' '<<-M<<'\n';
            assert(mts==-Mzuordnung);
//std::cout<<"Increase: "<<Id()<<' '<<myznr<<'\t'<<AE.Id()<<' '<<znr<<'\n';
            try{ mengen_t mt=AufEintragZu(class AufEintragBase(*this,myznr)).setMengeDiff__(AEBZ,Mzuordnung);
                 assert(mt>=0); } catch(SQLerror &e)
               {AufEintragZu(class AufEintragBase(*this,myznr)).Neu(AEBZ,Mzuordnung); }
         }
     }
//cout << AE.Instanz()->Id()<<' '<<AE.Id()<<' '<<AE.ZNr()<<'\t';
   mengen_t mt=AE.updateStkDiff__(uid,-Mauftrag,false); // macht auch das Lager
//cout <<*this<<'\t'<< AE<<'\t'<<mt<<' '<<-M<<'\n';
//   assert(mt==-M);
   if(auftragstatus==UNCOMMITED && newstatus==OPEN ) 
      AE.setStatusAuftragBase(newstatus);

   if(instanz->LagerInstanz() && Id()==plan_auftrag_id && 
       (newstatus==STORNO || Mauftrag < 0 ))
    {
      H_Lager L(instanz);
      L->rein_ins_lager(ArtId(),Mauftrag,uid);
//      Lager_Vormerkungen::freigegeben_menge_neu_verplanen(instanz,ArtId(),Mauftrag,uid);
    }
   AE.setInstanzen(newstatus,uid,lieferdate,Mauftrag,znr,newznr);
  }
}




AuftragBase::mengen_t AufEintrag::updateStkDiff__(int uid,mengen_t menge,bool instanzen,
   void (*callback)(void *,st_problems),void* argument) throw(SQLerror)
{
 if(auftragstatus==OPEN || auftragstatus==UNCOMMITED)
  {
   Transaction tr;
   exec sql lock auftragentry in exclusive mode;
   SQLerror::test("updateStkDiff: lock table auftragentry");
//cout << "Try Menge= "<<menge<<'\t'<<getStueck()<<'\t';
//ECPGdebug(true,stdout);
   mengen_t mt=updateStkDiffBase__(uid,menge);
//ECPGdebug(false,0);
//cout << "get menge: "<<mt<<'\n';
     if(mt!=mengen_t(menge)) // es konnte nicht alles bei ungeplanten reduziert werden
      {
        if(Instanz()->LagerInstanz() && mt>menge)
         {
           H_Lager L(Instanz());
           L->dispo_auftrag_aendern(Artikel(),mt-menge);
           Lager_Vormerkungen::freigegeben_menge_neu_verplanen(instanz,artikel,mt-menge,uid);
         }
        else if(callback)
          (*callback)(argument,st_problems(Geplant,*this,menge,mt));
        else 
          cerr<< "WARNUNG: kein Lager und KEINE callback Funktion definiert\n\n";
      }
   if(instanzen)
      updateStkDiffInstanz__(uid,mt,callback,argument);
   bestellt+=menge;
   tr.commit();
   return mt;
  }
 return menge;
}


void AufEintrag::updateStkDiffInstanz__(int uid,mengen_t oldmenge,void (*callback)(void *,st_problems),void* argument) throw(SQLerror)
{
  std::list<AufEintragZu::st_reflist> KindListeU = AufEintragZu(*this).get_Referenz_list_ungeplant();
 try{
  for(std::list<AufEintragZu::st_reflist>::const_iterator i=KindListeU.begin();i!=KindListeU.end();++i)
   {
     ArtikelBaum::faktor_t faktor = ArtikelBaum(ArtId()).Faktor(i->Art);
     AuftragBase::mengen_t menge=faktor*oldmenge;
     mengen_t mt=AufEintrag(i->AEB).updateStkDiff__(uid,menge,true,callback,argument);
     AufEintragZu(*this).setMengeDiff__(i->AEB,menge);

     if(mt!=mengen_t(menge)) // es konnte nicht alles bei ungeplanten reduziert werden
      {
       mengen_t verplante_menge=menge-mt;        
       std::list<AufEintragZu::st_reflist> KindListeG = AufEintragZu(i->AEB).get_Referenz_list_geplant();
       for(std::list<AufEintragZu::st_reflist>::const_iterator j=KindListeG.begin();j!=KindListeG.end();++j)
        {
          AufEintrag AE(j->AEB);
          if(AE.getRestStk()==mengen_t(0)) 
           { 
             if(callback) (*callback)(argument,st_problems(Geliefert,i->AEB,0,0));
             continue;
           }
          else
           {
             mengen_t abmenge;
             if(verplante_menge<=AE.getRestStk())
                  abmenge=verplante_menge;
             else abmenge=AE.getRestStk();
             
             if(j->AEB.Instanz()->LagerInstanz())
              {
                 mengen_t mt=j->AEB.updateStkDiffBase__(uid,abmenge);
                 assert(mt==mengen_t(abmenge));
              }
             else
              {
                if(callback) (*callback)(argument,st_problems(Geplant_nolager,j->AEB,0,0));
              }
             mengen_t mt2=AufEintragZu(i->AEB).setMengeDiff__(j->AEB,abmenge);
             assert(mt2==mengen_t(abmenge));

             if(verplante_menge<=AE.getRestStk())
               {
                 verplante_menge=0;
                 break;
               }
             else 
               { 
                 verplante_menge-=abmenge;
               }
           }
        }
       if(verplante_menge!=mengen_t(0)) 
          if(callback) (*callback)(argument,st_problems(GeliefertFatal,*this,menge,mt));
      }
    }
  }catch(NoAEB_Error &e) 
  {cerr <<"Falsche Anzahl von AufEinträgen: "<<e.what()<<'\n'; 
   exit(1);}
}




void AufEintrag::updatePreis(const Preis &pr) throw(SQLerror)
{exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int ZEILENNR = zeilennr;
 int INSTANZ=instanz->Id();
 float PREIS=pr.Wert();
 float PREISMENGE=pr.PreisMenge();
 exec sql end declare section;
 
 exec sql update auftragentry 
 	set preis= :PREIS, preismenge= :PREISMENGE
 	where (instanz,auftragid,zeilennr)=(:INSTANZ,:AUFTRAGID,:ZEILENNR);
 SQLerror::test("updatePreis: update preis in auftragentry");
 preis=pr;
}



void AufEintrag::updateRabatt(rabatt_t rb) throw(SQLerror)
{exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int INSTANZ=instanz->Id();
 int ZEILENNR = zeilennr;
 float RABATT = rb;
 exec sql end declare section;

 exec sql update auftragentry set rabatt= :RABATT
 	where (instanz,auftragid,zeilennr)=(:INSTANZ,:AUFTRAGID,:ZEILENNR);
 SQLerror::test("updateRabatt: update rabatt in auftragentry");
 
 rabatt=RABATT;
}


void AufEintrag::updateLieferdatum(const Petig::Datum &ld,int uid) throw(SQLerror)
{exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int INSTANZ=instanz->Id();
 int ZEILENNR = zeilennr;
 char LIEFERDATUM[21];
 exec sql end declare section;

 Transaction tr;
 exec sql lock auftragentry in exclusive mode;
 SQLerror::test("updateLieferdatum: lock table auftragentry");
  
 ld.write_postgres(LIEFERDATUM,sizeof LIEFERDATUM);
 
 exec sql update auftragentry set lieferdate= :LIEFERDATUM
 	where (instanz,auftragid,zeilennr)=(:INSTANZ,:AUFTRAGID,:ZEILENNR);
 SQLerror::test("updateLiefDatum: update lieferdate in auftragentry");

 //update Lieferdatum für Instanzen
 setInstanzen(entrystatus,uid,ld,getStueck()); 

 if(entrystatus==OPEN)// status->entrystatus
  {
   try 
    {
     pps_ChJournalEntry::newChange(
  			instanz, *this,
  			artikel, ld,
  			(double)(ld-getLieferdatum()),
  			pps_ChJournalEntry::CH_LIEFDAT);
    }
   catch(SQLerror &e)
     {tr.rollback(); throw; }
  }
 
 lieferdatum=ld;
 tr.commit(); 
}

int AufEintrag::split(int uid,mengen_t newmenge, const Petig::Datum &newld,void (*callback)(void *,st_problems)=0,void* argument=0) throw(SQLerror)
{
 if(entrystatus==CLOSED) return none_znr;

 mengen_t BESTELLT_OLD=bestellt-newmenge;
 int STATUS=entrystatus;

 double GELIEFERT;
 double GELIEFERT_OLD;

 if(lieferdatum>newld)
   {GELIEFERT=geliefert>newmenge ? mengen_t(newmenge) : geliefert;
    GELIEFERT_OLD=geliefert>newmenge ? geliefert-mengen_t(newmenge) : mengen_t(0);}
 else
   {GELIEFERT_OLD=geliefert>BESTELLT_OLD ? mengen_t(BESTELLT_OLD) : geliefert;
    GELIEFERT=geliefert>BESTELLT_OLD ? geliefert-mengen_t(BESTELLT_OLD) : mengen_t(0);}
    
 Transaction tr;
 exec sql lock auftragentry in exclusive mode;
 SQLerror::test("split: lock table auftragentry");

 int ZEILENNR;
 if(Instanz()==ppsInstanzID::Kundenauftraege)
   ZEILENNR=insertNewEntry(newmenge,newld,artikel,entrystatus,uid,true,preis,rabatt);
 else
   ZEILENNR=split_zuordnungen_to(newmenge,newld,artikel,entrystatus,uid);
 mengen_t mt=updateStkDiff__(uid,-newmenge,true,callback,argument);
 assert(mt==-newmenge);

 if(STATUS==OPEN)
   {   pps_ChJournalEntry::newChange(
    			instanz, *this,
    			artikel, BESTELLT_OLD, +(BESTELLT_OLD-bestellt),
    			pps_ChJournalEntry::CH_MENGE);
       pps_ChJournalEntry::newChange(
    			instanz, *this,
    			artikel, newmenge, +newmenge,
    			pps_ChJournalEntry::CH_MENGE);
   }

 tr.commit();
 return ZEILENNR;
}

AufEintrag::AufEintrag(const AufEintragBase &aebb) throw (SQLerror,NoAEB_Error)
  : AufEintragBase(aebb), 
    artikel(0),
    prozess(Prozess::default_id)
{
 try{
  SelectedFullAufList aufids((SQLFullAuftragSelector)
    (SQLFullAuftragSelector::sel_AufidZnr(aebb)));

  if ( aufids.aufidliste.size()!=1 ) throw NoAEB_Error(aufids.aufidliste.size());
//  assert(aufids.aufidliste.size()==1);

//  (*this)=aufids.aufidliste[0];
  *this=*(aufids.aufidliste.begin());
 } catch (SQLerror &e) {std::cerr << e <<'\n';}
}


int AufEintrag::Planen(int uid,mengen_t menge, const AuftragBase &zielauftrag,
   const Petig::Datum &datum,bool rekursiv) throw(std::exception)
{
   assert(!Id());
   assert(Instanz()->LagerInstanz() || entrystatus==OPEN);
   assert(Instanz()->LagerInstanz() || auftragstatus==OPEN);
   if(entrystatus==UNCOMMITED) entrystatus=OPEN; // Kein Datenbankzugriff nötig, 
                                                // das macht insertNewEntry
   Auftrag(zielauftrag).setStatusAuftrag_(OPEN);

   // wenn Lieferdatum rekursiv korrigieren (VOR dem Planen)
   if(datum!=getLieferdatum())
    {
      AuftragBase::mengen_t M;
      if(menge>=getStueck()) M=getStueck();
      else M=menge; 
      int znr=split(uid,M,datum);
      AufEintrag ae=AufEintrag(AufEintragBase(*this,znr));
      return ae.Planen(uid,menge,zielauftrag,datum,rekursiv);
    }

   int znr=-1,dummy;
   mengen_t mdummy;
   if (!zielauftrag.existEntry(Artikel(),datum,znr,dummy,mdummy,entrystatus))
      znr = zielauftrag.insertNewEntry(0,datum,Artikel(),entrystatus,uid,false);

   if(menge==AuftragBase::mengen_t(0)) return znr;
   assert(menge>0);
   if(menge-getRestStk() > 0 )
    {
      assert(!Instanz()->LagerInstanz()); // Lager werden nicht überplant
      mengen_t dispomenge = menge-getRestStk();
      menge=getRestStk();      
      AufEintragBase(zielauftrag,znr).PlanenDispo(uid,Artikel(),dispomenge,datum);
    }
   move_to(uid,AufEintragBase(zielauftrag,znr),menge);

   std::list<AufEintragZu::st_reflist> ReferenzAufEintrag =
			         AufEintragZu(*this).get_Referenz_listFull(false);

   for (std::list<AufEintragZu::st_reflist>::iterator i=ReferenzAufEintrag.begin();i!=ReferenzAufEintrag.end();++i)
    {
     if(i->AEB.Instanz()->Id()!=ppsInstanzID::Kundenauftraege) continue;
     i->AEB.setLetztePlanungFuer(instanz);
     i->AEB.calculateProzessInstanz();
    }

   



   if(rekursiv) // Braucht nur das Erfassungs/Reperaturprogramm
    {
     // bei dem gerade geplaneten Auftrag abschreiben:
     AufEintrag(class AufEintragBase(zielauftrag,znr)).abschreiben(menge);
     std::list<AufEintragZu::st_reflist> L=AufEintragZu(*this).get_Referenz_list_ungeplant();
     for(std::list<AufEintragZu::st_reflist>::const_iterator i=L.begin();i!=L.end();++i)
      {
        // Lager nicht rekursiv Planen
        if(i->AEB.Instanz()->LagerInstanz()) continue;
        AuftragBase ab(i->AEB.Instanz(),plan_auftrag_id);
        AuftragBase::mengen_t M=menge*ArtikelBaum(ArtId()).Faktor(i->Art);
//cout << "Planen: "<<i->AEB.Instanz()->Id()<<' '<<i->AEB.Id()<<' '<<i->AEB.ZNr()
//<<AufEintrag(i->AEB).getAufStatus()<<' '
//<<AufEintrag(i->AEB).getEntryStatus()<<' '<<'\n';
        AufEintrag(i->AEB).Planen(uid,M,ab,datum,rekursiv);
      }
    }
 return znr;
}

void AufEintrag::moveInstanz(int uid,const AuftragBase &newAuftrag) throw(SQLerror)
{
 AufEintragBase oldAEB = *this;
 auftragid=newAuftrag.Id(); 
 instanz=newAuftrag.Instanz();

 exec sql begin declare section;
  int OLDAUFTRAGID = oldAEB.Id();
  int OLDINSTANZ   = oldAEB.Instanz()->Id();
  int OLDZEILENNR  = oldAEB.ZNr();  
 exec sql end declare section;

 AuftragBase::mengen_t menge=getRestStk();
 mengen_t mt=oldAEB.updateStkDiffBase__(uid,-menge);
 assert(mt==-menge);
 zeilennr = newAuftrag.insertNewEntry(menge,getLieferdatum(),Artikel(),
                            getEntryStatus(),uid,false,EPreis(),Rabatt());
 Lager_Vormerkungen(class AufEintrag(newAuftrag.Instanz()->Id(),newAuftrag.Id()
         ,zeilennr,menge,Artikel(),getLieferdatum(),getEntryStatus())).vormerken_oder_bestellen(uid);

// exec sql delete from prod_changejournal where 
//      (insid,auftragid,auftragzeile)=(:OLDINSTANZ,:OLDAUFTRAGID,:OLDZEILENNR);
 exec sql delete from auftragentry where 
   (instanz,auftragid,zeilennr) = (:OLDINSTANZ,:OLDAUFTRAGID,:OLDZEILENNR);
 SQLerror::test("moveInstanz: delete from auftragentry");

 if(oldAEB.Instanz()->LagerInstanz())
   {
     SQLFullAuftragSelector psel= SQLFullAuftragSelector::sel_Artikel(
                                  oldAEB.Instanz()->LagerFuer(),Artikel());
     SelectedFullAufList allaufids=SelectedFullAufList(psel);
     for(SelectedFullAufList::iterator i=allaufids.begin();i!=allaufids.end();++i)
      {
        OLDINSTANZ=i->Instanz()->Id();
        OLDAUFTRAGID=i->Id();
        OLDZEILENNR=i->ZNr();
        exec sql delete from auftragentry where 
            (instanz,auftragid,zeilennr) = (:OLDINSTANZ,:OLDAUFTRAGID,:OLDZEILENNR);
        SQLerror::test("moveInstanz: delete from auftragentry");
        AufEintragZu::moveInstanz(AufEintragZu::Delete,oldAEB,*i);
        AufEintragZu::moveInstanz(AufEintragZu::Von,*i,*this);
      }
   }
 else AufEintragZu::moveInstanz(AufEintragZu::Von,oldAEB,*this);
 AufEintragZu::moveInstanz(AufEintragZu::Nach,oldAEB,*this);
}


cH_Lieferschein AufEintrag::getLieferschein() const
{
  exec sql begin declare section;
   int LFRSID=0,LFRZNR=0;
   int AUFID=Id();
   int AUFZNR=ZNr();
   int INSTANZ=Instanz()->Id();
  exec sql end declare section;
  exec sql select lfrsid,zeile into :LFRSID,:LFRZNR
      from lieferscheinentry where 
      (instanz,refauftragid,refzeilennr)=(:INSTANZ,:AUFID,:AUFZNR) limit 1;
#warning kann es mehr als eine Zeile geben? 
 SQLerror::test(__FILELINE__,100);
 if(sqlca.sqlcode) // keine Zeile gefunden ... warum nicht throw?
   return cH_Lieferschein(ppsInstanzID::None,0);
 else 
   return cH_Lieferschein(Instanz(),LFRSID);
}
