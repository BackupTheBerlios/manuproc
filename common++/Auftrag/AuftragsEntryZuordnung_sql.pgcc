// $Id: AuftragsEntryZuordnung_sql.pgcc,v 1.10 2002/04/03 06:38:09 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/AuftragsEntryZuordnung.h>
//#include "AufEintrag.h"
#include <Aux/Transaction.h>
#include <Auftrag/auftrag_status.h>
#include <Auftrag/AuftragsBaum.h> 
#include <Aux/Changejournal.h>
#include <Artikel/ArtikelStamm.h>

exec sql include sqlca;


std::list<AufEintragZu::st_reflist> AufEintragZu::get_Referenz_list(const AufEintragBase& aeb,bool kinder) const throw(SQLerror) 
{
 exec sql begin declare section;
  int INSTANZ[30],AUFTRAGID[30],ZEILENNR[30];
  double MENGE[30];
  int ARTIKEL[30];
  char query[1024];
 exec sql end declare section;
 Transaction tr;
 std::string squery;
 if(kinder)
    squery = "select neuauftragid,neuinstanz,neuzeilennr,menge,artikelid
      from auftragsentryzuordnung 
      join auftragentry on (neuinstanz,neuauftragid,neuzeilennr)
         = (instanz,auftragid,zeilennr)
      where (altinstanz,altauftragid,altzeilennr) = 
       ("+itos(aeb.InstanzID())+","+itos(aeb.Id())+","+itos(aeb.ZNr())+")";
 else
    squery = "select altauftragid,altinstanz,altzeilennr,menge,artikelid
      from auftragsentryzuordnung 
      join auftragentry on (altinstanz,altauftragid,altzeilennr)
         = (instanz,auftragid,zeilennr)
      where (neuinstanz,neuauftragid,neuzeilennr) = 
       ("+itos(aeb.InstanzID())+","+itos(aeb.Id())+","+itos(aeb.ZNr())+")";
 strncpy(query,squery.c_str(),sizeof(query));
 exec sql prepare ONAUF_ from :query;
//std::cout << query<<"\n\n\n";
 exec sql declare ONAUF cursor for ONAUF_;
 exec sql open ONAUF;
 std::list<st_reflist> vaeb;
 while(true)
  {
    exec sql fetch 30 in ONAUF into :AUFTRAGID,:INSTANZ,:ZEILENNR,:MENGE,:ARTIKEL;
    SQLerror::test(__FILELINE__,100);
    if (sqlca.sqlcode) break;
    int j=sqlca.sqlerrd[2];
    for (int i=0;i<j;++i)
     {
      vaeb.push_back(st_reflist(
         AufEintragBase(cH_ppsInstanz((ppsInstanz::ppsInstId)INSTANZ[i]),
             AUFTRAGID[i],ZEILENNR[i]),ARTIKEL[i],MENGE[i]));
     }
    if(j<30) break;
  }
 exec sql close ONAUF;
 tr.close();
 return vaeb;
}


std::list<AufEintragZu::st_reflist> AufEintragZu::get_Referenz_list_ungeplant(const AufEintragBase& aeb,bool kinder) const throw(SQLerror)
{
   std::list<st_reflist> L=get_Referenz_list(aeb,kinder);
   std::list<st_reflist> N;
   for(std::list<AufEintragZu::st_reflist>::const_iterator i=L.begin();i!=L.end();++i)
     {
       if(i->AEB2.Id()==0)
         N.push_back(*i);
     }
   return N;
}

list<AufEintragZu::st_reflist> AufEintragZu::get_Referenz_listFull(bool kinder,bool nur_ende) const throw(SQLerror)
{
 std::list<st_reflist> tv=get_Referenz_list(AEB,kinder);
 std::list<st_reflist> vaeb;
 std::list<st_reflist> tvxx;
// ++tiefe;
reloop:
 tv.splice(tv.end(),tvxx);
 for (std::list<st_reflist>::iterator i=tv.begin();i!=tv.end();++i)
   {
     tvxx=get_Referenz_list(i->AEB2,kinder);
     if(nur_ende)
      {
        if (tvxx.empty()) vaeb.splice(vaeb.end(),tv,i) ;
        else tv.erase(i) ; 
      }
     else vaeb.splice(vaeb.end(),tv,i) ;
     goto reloop;
   }
 return vaeb;
}


std::list<AufEintragZu::st_reflist> AufEintragZu::get_Referenz_list_for_geplant(bool kinder=false) const throw(SQLerror)
{
//cout << AEB.Instanz()->Name()<<' '<<AEB.Id()<<' '<<AEB.ZNr()<<'\n';
  // Ungeplante Referenz Aufträge
  std::list<st_reflist> URA=get_Referenz_list(AEB,false);
  // ich gehe davon aus, daß zu jedem geplanten Auftrag GENAU 
  // ein Elternauftrag gehört
  assert(URA.size()==1);
  std::list<st_reflist> L=AufEintragZu(URA.begin()->AEB2).get_Referenz_list(URA.begin()->AEB2,kinder);
  // Aus dieser Liste muß eventuell noch der geplante Auftrag entfernt werden:
  if(kinder)
     for (std::list<st_reflist>::iterator i=L.begin();i!=L.end();++i)
        if(i->AEB2==AEB) {L.erase(i); break;}
  return L; 
}


list<cH_Kunde> AufEintragZu::get_Referenz_Kunden_long() const throw(SQLerror)
{
 std::list<cH_Kunde> LK;
// std::list<st_reflist> vaeb = get_Referenz_AufEintragBase();
 std::list<st_reflist> vaeb = get_Referenz_listFull(false);
 exec sql begin declare section;
  int KUNDE;
  int INSTANZ;
  int AUFTRAGID;
 exec sql end declare section;
 for (std::list<st_reflist>::const_iterator i=vaeb.begin();i!=vaeb.end();++i)
  {
    INSTANZ=i->AEB2.InstanzID();
    AUFTRAGID=i->AEB2.Id();
    exec sql select kundennr into :KUNDE from auftrag where
      (instanz,auftragid)=(:INSTANZ,:AUFTRAGID); 
    SQLerror::test(__FILELINE__);
    LK.push_back(cH_Kunde(KUNDE));
  }
 return LK;
}

list<cH_Kunde> AufEintragZu::get_Referenz_Kunden() const throw(SQLerror)
{
 std::list<cH_Kunde> LK = get_Referenz_Kunden_long();
 LK.sort();
 LK.unique();
 return LK;
}

std::list<AufEintragBase> AufEintragZu::get_AufEintragList_from_Artikel
               (const ArtikelBase& artikel,ppsInstanz::ppsInstId instanz,AufStatVal status)
{
  std::list<AufEintragBase> L;
  exec sql begin declare section;
   char query[1024];
   int db_auftragid,db_zeilennr;
  exec sql end declare section;
  std::string squery = "select auftragid,zeilennr from auftragentry
      where artikelid="+itos(artikel.Id()) +
      " and instanz!="+itos(ppsInstanz::INST_KNDAUF) //Nur interne Aufträge sind interessant
      +" and auftragid=0"; // Nur die UNGEPLANTEN Aufträge bekommen neue Kinder
  if(status!=NOSTAT) squery += " and status="+itos(status);
  strncpy(query,squery.c_str(),sizeof(query));
  Transaction tr;
  exec sql prepare AELfAein_ from :query ;
  exec sql declare AELfAein cursor for AELfAein_ ;

  exec sql open AELfAein;
  SQLerror::test(__FILELINE__);
  while(true)
   {
     exec sql fetch AELfAein into :db_auftragid,:db_zeilennr;
     SQLerror::test(__FILELINE__,100);
     if (sqlca.sqlcode) break;
     L.push_back(AufEintragBase(instanz,db_auftragid,db_zeilennr));
//std::cout << "Liste: "<<I->Name()<<' '<<db_auftragid<<' '<<db_zeilennr<<'\n';
   }  
  return L;
}

void AufEintragZu::AuftragsEntryZuordnung(const mengen_t menge,
                              const AuftragBase& neuAuftrag,const int neuZnr,
                              const int oldZnr=0)
{
 exec sql begin declare section;
  int db_aaid=AEB.Id();
  int db_ains=AEB.InstanzID();
  int db_aznr=AEB.ZNr();
  double db_menge=menge;
  int db_naid=neuAuftrag.Id();
  int db_nins=neuAuftrag.InstanzID();
  int db_nznr=neuZnr;
 exec sql end declare section;
 if(oldZnr!=0) db_aznr=oldZnr;
 exec sql insert into auftragsentryzuordnung
   (altinstanz,altauftragid,altzeilennr, menge, neuinstanz,neuauftragid,neuzeilennr) values
   (:db_ains,:db_aaid,:db_aznr, :db_menge, :db_nins,:db_naid,:db_nznr);
 SQLerror::test(__FILELINE__);
}

#include <Aux/itos.h>

void AufEintragZu::setMenge(const mengen_t menge,const AuftragBase& neuAuftrag,const int neuZnr)
{
 exec sql begin declare section;
  int db_aaid=AEB.Id();
  int db_ains=AEB.InstanzID();
  int db_aznr=AEB.ZNr();
  double db_menge=menge;
  int db_naid=neuAuftrag.Id();
  int db_nins=neuAuftrag.InstanzID();
  int db_nznr=neuZnr;
 exec sql end declare section;
 exec sql update auftragsentryzuordnung
   set menge=:db_menge where
   (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid,neuzeilennr)
    = (:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid,:db_nznr);
 SQLerror::test(__FILELINE__);
}

bool AufEintragZu::setMengeDiff(const mengen_t menge,const AuftragBase& neuAuftrag,const int neuZnr)
{
 exec sql begin declare section;
  int db_aaid=AEB.Id();
  int db_ains=AEB.InstanzID();
  int db_aznr=AEB.ZNr();
  double db_menge=menge;
  int db_naid=neuAuftrag.Id();
  int db_nins=neuAuftrag.InstanzID();
  int db_nznr=neuZnr;
 exec sql end declare section;
 exec sql update auftragsentryzuordnung
   set menge=menge+:db_menge where
   (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid,neuzeilennr)
    = (:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid,:db_nznr);
 SQLerror::test(__FILELINE__,100);
 if (sqlca.sqlcode) return false;
 else return true;
}


bool AufEintragZu::setKindZnr(const AuftragBase& neuAuftrag,const int neuZnr)
{
 exec sql begin declare section;
  int db_aaid=AEB.Id();
  int db_ains=AEB.InstanzID();
  int db_aznr=AEB.ZNr();
  int db_naid=neuAuftrag.Id();
  int db_nins=neuAuftrag.InstanzID();
  int db_nznr=neuZnr;
 exec sql end declare section;
 exec sql update auftragsentryzuordnung
   set neuzeilennr=:db_nznr where
   (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid)
    = (:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid);
 SQLerror::test(__FILELINE__);
 if (sqlca.sqlcode) return false;
 else return true;
}

void AufEintragZu::moveInstanz(const VonNachDel vdl,const AufEintragBase &oldAEB, const AufEintragBase &newAEB) throw(SQLerror)
{
 exec sql begin declare section;
  int db_aaid=oldAEB.Id();
  int db_ains=oldAEB.Instanz()->Id();
  int db_aznr=oldAEB.ZNr();
  int db_naid=newAEB.Id();
  int db_nins=newAEB.Instanz()->Id();
  int db_nznr=newAEB.ZNr();
 exec sql end declare section;

 switch(vdl)
  {
   case Von:
    exec sql update auftragsentryzuordnung set 
      altauftragid=:db_naid, altinstanz=:db_nins, altzeilennr=:db_nznr where
      (altinstanz,altauftragid,altzeilennr)=(:db_ains,:db_aaid,:db_aznr);
    break;
   case Nach:
    exec sql update auftragsentryzuordnung set 
      neuauftragid=:db_naid, neuinstanz=:db_nins, neuzeilennr=:db_nznr where
      (neuinstanz,neuauftragid,neuzeilennr)=(:db_ains,:db_aaid,:db_aznr);
    break;
   case Delete:
    exec sql delete from auftragsentryzuordnung where
      (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid,neuzeilennr)
     =(:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid,:db_nznr);
    break;
  }
 SQLerror::test(__FILELINE__,100);
}

