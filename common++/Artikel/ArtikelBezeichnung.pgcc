// $Id: ArtikelBezeichnung.pgcc,v 1.7 2001/10/02 15:26:22 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Artikel/ArtikelBezeichnung.h>
#include <Artikel/ArtikelStamm.h>
#include "Aux/string0.h"
#include <Aux/Transaction.h>
#include <Aux/mystream.h>
exec sql include sqlca;
#include <Aux/FetchIStream.h>
//#include <Aux/dbconnect.h>

ArtikelBezeichnung::ArtikelBezeichnung(const ArtikelBase &artikel, const cH_ExtBezSchema &_schema) throw()
 : ArtikelBase(artikel), schema(_schema)
{  *this=ArtikelBezeichnung(artikel,_schema->Id());
}

ArtikelBezeichnung::ArtikelBezeichnung(const ArtikelBase &artikel, ExtBezSchema::ID _schema) throw()
 : ArtikelBase(artikel), schema(ExtBezSchema::default_ID)
{  try
   {  ArtikelStamm AS( artikel );
      try 
      { setzeExtBezSchema(cH_ExtBezSchema(_schema,AS.Warengruppe(_schema)));
      } catch (SQLerror &e)
      { try 
        {  // requested schema, default type
          setzeExtBezSchema(cH_ExtBezSchema(_schema,
		   			AS.Warengruppe(AS.defaultSchema())));
        } catch (SQLerror &e) 
        {try // last resort: default
         {  setzeExtBezSchema(cH_ExtBezSchema(AS.defaultSchema(),
		   			AS.Warengruppe(AS.defaultSchema())));
         } catch (SQLerror &e) { } 
        }
      }
   }
  catch (SQLerror &e) { }
}

void ArtikelBezeichnung::setzeExtBezSchema(const cH_ExtBezSchema &_schema) throw(SQLerror)
{   
 schema = _schema;
 exec sql begin declare section;
 char *QUERY;
 exec sql end declare section;

 Transaction tr;
 
    value.clear();
    if (Id())
    {mystream sq; 
     std::vector<int> gewaehlte_indizes;
     sq << "SELECT ";
     for (ExtBezSchema::const_iterator i=schema->begin();i!=schema->end();)
      {
         sq << i->spaltenname;
         gewaehlte_indizes.push_back(i->bezkomptype);
         ++i;
         if (i!=schema->end()) sq <<", " ;
      }
     sq << " FROM artbez_" << schema->Typ()<<"_"<<schema->Id()<<" WHERE id = "
         << Id();
     std::string this_string_holds_my_query=sq.str();
     (const char*)QUERY=this_string_holds_my_query.c_str();
     Transaction tr;
     exec sql allocate descriptor mydesc;
     exec sql prepare ein_ from :QUERY;
     exec sql declare ein cursor for ein_;
     exec sql open ein;
     SQLerror::test(__FILELINE__);
     exec sql fetch from ein into sql descriptor mydesc; 
     SQLerror::test(__FILELINE__);
     
     value.resize(gewaehlte_indizes[gewaehlte_indizes.size()-1]+1);
     FetchIStream is("mydesc");
     for (std::vector<int>::const_iterator i=gewaehlte_indizes.begin();i!=gewaehlte_indizes.end();++i)
      {  std::string s;
         is >> FetchIStream::MapNull<std::string>(s,"");
         value[*i]=cH_EntryValueIntString(s);  
      }
     exec sql close ein;
     SQLerror::test(__FILELINE__);
     exec sql deallocate descriptor mydesc;
    }
} 

std::string ArtikelBezeichnung::Bezeichnung(int signifikanz, char separator,int felder) const throw()
{   std::string ret;
    int f=0;
    const_sigiterator end=sigend(signifikanz);
    for (const_sigiterator i=sigbegin(signifikanz);i!=end;++i)
    {  if (i.BezKomp().bezkomptype<0 
    		|| (unsigned int)i.BezKomp().bezkomptype>value.size()) 
    	  continue;
       ret+=value[i.BezKomp().bezkomptype]->getStrVal();
       if (separator)
       {  const_sigiterator h=i;
          ++h;
          if (h!=end) ret+=char(separator); 
       }
       else ret+=i.BezKomp().separator;
       ++f;
    }
    if (separator)
    {  for (;f<felder;++f) ret+=char(separator);
    } 
    return ret;
}

std::string ArtikelBezeichnung::Komponente(int feldnr,int signifikanz) const throw()
{
    const_sigiterator end=sigend(signifikanz);
    int f=0;
    for (const_sigiterator i=sigbegin(signifikanz);i!=end;++i,++f)
    { if (i.BezKomp().bezkomptype<0 
    		|| (unsigned int)i.BezKomp().bezkomptype>value.size()) 
    	  continue;
      if (f==feldnr) return value[i.BezKomp().bezkomptype]->getStrVal();
    }
 return "";
}

ArtikelBezeichnung::ArtikelBezeichnung(int signifikanz, const std::vector<cH_EntryValue> &_val, const cH_ExtBezSchema &_schema) throw(SQLerror)
: schema(_schema)
{
 exec sql begin declare section;
 long ARTIKELID;
 char *QUERY;
 exec sql end declare section;
 mystream squery;
 squery << "SELECT id FROM artbez_"<<schema->Typ()<<"_"<<schema->Id()
      << " WHERE ";
 int f=0;
 for (ExtBezSchema::const_iterator i=schema->begin();i!=schema->end();)
   {
     if (i->signifikanz != signifikanz) {++i; continue;}
     squery << i->spaltenname << " = '" << _val[f]->getStrVal() <<"'";
     ++f;
     do 
     ++i;
     while (i!=schema->end() && i->signifikanz != signifikanz ) ;
     if (i!=schema->end()) squery <<" AND " ;
   }

 std::string query = squery.str(); 
   
 try
 {  (const char*)QUERY=query.c_str();
    Transaction tr;
    exec sql prepare QUERY2 from :QUERY;
    exec sql declare loadart cursor for QUERY2;
    exec sql open loadart;
    SQLerror::test("ArtikelBox::loadArtikel: select artikelid");
    exec sql fetch in loadart into :ARTIKELID;
    SQLerror::test("ArtikelBox::loadArtikel: fetch artikelid");
    exec sql close loadart;
    tr.commit();
 }
 catch (SQLerror &e) { throw; }
 
 *(ArtikelBase*)this=ARTIKELID;
 setzeExtBezSchema(schema);
}

cH_ArtikelBezeichnung::cache_t cH_ArtikelBezeichnung::cache;

cH_ArtikelBezeichnung::cH_ArtikelBezeichnung(const ArtikelBase &artikel,const cH_ExtBezSchema &schema) throw(SQLerror)
{  *this=cH_ArtikelBezeichnung(artikel,schema->Id());
}

cH_ArtikelBezeichnung::cH_ArtikelBezeichnung(const ArtikelBase &artikel,const ExtBezSchema::ID id) throw(SQLerror)
{  cH_ArtikelBezeichnung *cached(cache.lookup(cache_key(artikel.Id(),id)));
   if (cached) *this=*cached;
   else
   {  *this=cH_ArtikelBezeichnung(new ArtikelBezeichnung(artikel,id));
      cache.Register(cache_key(artikel.Id(),id),*this);
   }
}

const cH_EntryValue ArtikelBezeichnung::const_sigiterator::operator*() const
{  return container[BezKomp().bezkomptype];
}

#if 0
const cH_EntryValue *ArtikelBezeichnung::const_sigiterator::operator->() const
{  return &container[BezKomp().bezkomptype];
}
#endif

