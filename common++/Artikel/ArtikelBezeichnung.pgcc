// $Id: ArtikelBezeichnung.pgcc,v 1.3 2001/07/05 12:41:42 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Artikel/ArtikelBezeichnung.h>
#include <Artikel/ArtikelStamm.h>
#include "Aux/string0.h"
#include <Aux/Transaction.h>
#include <Aux/mystream.h>
exec sql include sqlca;
#include <Aux/FetchIStream.h>
//#include <Aux/dbconnect.h>

ArtikelBezeichnung::ArtikelBezeichnung(const ArtikelBase &artikel, const cH_ExtBezSchema &_schema) throw(SQLerror)
 : ArtikelBase(artikel), schema(_schema)
{  *this=ArtikelBezeichnung(artikel,_schema->Id());
}

ArtikelBezeichnung::ArtikelBezeichnung(const ArtikelBase &artikel, ExtBezSchema::ID _schema) throw()
 : ArtikelBase(artikel), schema(1)
{  try
   {  ArtikelStamm AS( artikel );
      try { setzeExtBezSchema(cH_ExtBezSchema(_schema,AS.Warengruppe()));
          }
      catch (SQLerror &e)
         {  if (e.Code()!=100) throw; // die
            try {
                  setzeExtBezSchema(cH_ExtBezSchema(AS.defaultSchema(),AS.Warengruppe())); 
                }
            catch (SQLerror &e) 
               { if (e.Code()!=100) throw; // die
               }
         }
   }
  catch (SQLerror &e)
   {if (e.Code()!=100) throw; // die
   }
}

ArtikelBezeichnung::ArtikelBezeichnung(const ArtikelBase &artikel, ExtBezSchema::ID _schema, dont_throw dummy) throw()
 : ArtikelBase(artikel), schema(1)
{  *this=ArtikelBezeichnung(artikel,_schema);
}

void ArtikelBezeichnung::setzeExtBezSchema(const cH_ExtBezSchema &_schema) throw(SQLerror)
{   
 schema = _schema;
 exec sql begin declare section;
 char *QUERY;
 exec sql end declare section;

 Transaction tr;
 
    value.clear();
    if (Id())
    {mystream sq; 
     std::vector<int> gewaehlte_indizes;
     sq << "SELECT ";
     for (ExtBezSchema::const_iterator i=schema->begin();i!=schema->end();)
      {
         sq << i->spaltenname;
         gewaehlte_indizes.push_back(i->bezkomptype);
         ++i;
         if (i!=schema->end()) sq <<", " ;
      }
     sq << " FROM artbez_" << schema->Typ()<<"_"<<schema->Id()<<" WHERE id = "
         << Id();
     std::string this_string_holds_my_query=sq.str();
     (const char*)QUERY=this_string_holds_my_query.c_str();
     Transaction tr;
     exec sql allocate descriptor mydesc;
     exec sql prepare ein_ from :QUERY;
     exec sql declare ein cursor for ein_;
     exec sql open ein;
     SQLerror::test(__FILELINE__);
     exec sql fetch from ein into sql descriptor mydesc; 
     SQLerror::test(__FILELINE__);
     value.resize(gewaehlte_indizes[gewaehlte_indizes.size()-1]+1);
     FetchIStream is("mydesc");
//     for (size_t i=0;i<gewaehlte_indizes.size();++i)
     for (std::vector<int>::const_iterator i=gewaehlte_indizes.begin();i!=gewaehlte_indizes.end();++i)
      {
           std::string s;
         is >> FetchIStream::MapNull<std::string>(s,"");
         value[*i]=EntryValue(s);  
//std::cout << *i <<"\t"<<s<<"  <--\n";
      }
     exec sql close ein;
     SQLerror::test(__FILELINE__);
     exec sql deallocate descriptor mydesc;
//     tr.close(); // passiert automatisch
    }
} 


const EntryValue ArtikelBezeichnung::getExtBezFeld(int feld) const throw(SQLerror)
{  return feld<(int)value.size()?value[feld]:EntryValue();
}

std::string ArtikelBezeichnung::Bezeichnung(int signifikanz, char separator,int felder) const throw()
{   std::string ret;
    int f=0;
    if (begin()!=end()) 
    for (ExtBezSchema::const_iterator i=schema->begin();i!=schema->end();++i)
    {  
       if (signifikanz == i->signifikanz)
        {
          ret+=(const std::string)(value[i->bezkomptype]);
          if (separator) // aber nur wenns nicht das letzte ist
          {  if (i+1!=schema->end()) ret+=separator;
          }
          else ret+=i->separator;
          f++;
        }
    }
    if (separator)
    {  for (;f<felder;++f) ret+=separator;
    } 
    return ret;
}

ArtikelBezeichnung::ArtikelBezeichnung(int signifikanz, const std::vector<EntryValue> &_val, const cH_ExtBezSchema &_schema) throw(SQLerror)
: schema(_schema)
{
 exec sql begin declare section;
 long ARTIKELID;
 char *QUERY;
 exec sql end declare section;
 mystream squery;
 squery << "SELECT id FROM artbez_"<<schema->Typ()<<"_"<<schema->Id()
      << " WHERE ";
 int f=0;
 for (ExtBezSchema::const_iterator i=schema->begin();i!=schema->end();)
   {
     if (i->signifikanz != signifikanz) {++i; continue;}
     squery << i->spaltenname << " = '" << (std::string)_val[f] <<"'";
     ++f;
     do 
     ++i;
     while (i!=schema->end() && i->signifikanz != signifikanz ) ;
     if (i!=schema->end()) squery <<" AND " ;
   }

 std::string query = squery.str(); 
   
 try
 {  (const char*)QUERY=query.c_str();
    Transaction tr;
    exec sql prepare QUERY2 from :QUERY;
    exec sql declare loadart cursor for QUERY2;
    exec sql open loadart;
    SQLerror::test("ArtikelBox::loadArtikel: select artikelid");
    exec sql fetch in loadart into :ARTIKELID;
    SQLerror::test("ArtikelBox::loadArtikel: fetch artikelid");
    exec sql close loadart;
    tr.commit();
 }
 catch (SQLerror &e) { throw; }
//std::cout << ARTIKELID<<"\n";
 
 *(ArtikelBase*)this=ARTIKELID;
 setzeExtBezSchema(schema);
}

cH_ArtikelBezeichnung::cache_t cH_ArtikelBezeichnung::cache;

cH_ArtikelBezeichnung::cH_ArtikelBezeichnung(const ArtikelBase &artikel,const cH_ExtBezSchema &schema) throw(SQLerror)
{  *this=cH_ArtikelBezeichnung(artikel,schema->Id());
}

cH_ArtikelBezeichnung::cH_ArtikelBezeichnung(const ArtikelBase &artikel,const ExtBezSchema::ID &id) throw(SQLerror)
{  cH_ArtikelBezeichnung *cached(cache.lookup(cache_key(artikel.Id(),id)));
   if (cached) *this=*cached;
   else
   {  *this=cH_ArtikelBezeichnung(new ArtikelBezeichnung(artikel,id));
      cache.Register(cache_key(artikel.Id(),id),*this);
   }
}

cH_ArtikelBezeichnung::cH_ArtikelBezeichnung(const ArtikelBase &artikel,
		const ExtBezSchema::ID &id,dont_throw dummy) throw()
{  cH_ArtikelBezeichnung *cached(cache.lookup(cache_key(artikel.Id(),id)));
   if (cached) *this=*cached;
   else
   {  *this=cH_ArtikelBezeichnung(new ArtikelBezeichnung(artikel,id,dummy));
      cache.Register(cache_key(artikel.Id(),id),*this);
   }
}
