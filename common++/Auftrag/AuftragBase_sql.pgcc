/*  pps: ManuProC's production planning system
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/Auftrag.h>
#include<stdio.h>
#include <Aux/Transaction.h>
#include<Aux/Changejournal.h>
#include <Auftrag/auftrag_status.h>
#include "AufEintrag.h"
#include <Artikel/ArtikelStamm.h>
#include <Auftrag/AufEintragZu.h>
#include <Lager/Lager_Vormerkungen.h>
#include <Aux/Trace.h>

exec sql include sqlca;


AuftragBase::AuftragBase(cH_ppsInstanz _instanz, int aufid,int kid) throw(SQLerror)
: instanz(_instanz),auftragid(aufid)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,str());
 exec sql begin declare section;
   int KID=kid;
   int AID=auftragid;
   int INST=instanz->Id();
   int ID;
 exec sql end declare section;
 exec sql select auftragid into :ID from auftrag where instanz=:INST and
      kundennr=:KID and youraufnr=:AID;
 SQLerror::test(__FILELINE__);	
 *this=AuftragBase(instanz,ID);
}

bool AuftragBase::Exists() const throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,str());
 exec sql begin declare section;
  int AUFTRAGID=Id();
  int INSTANZ=InstanzID();
  bool DUMMY;
 exec sql end declare section;
 exec sql select true into :DUMMY from auftrag where 
	(instanz,auftragid)= (:INSTANZ,:AUFTRAGID);
 SQLerror::test(__FILELINE__,100);
 if(sqlca.sqlcode) return false;
 return true;
}

void AuftragBase::create_if_not_exists(AufStatVal status,Kunde::ID kunde) const
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,str(),"Status="+itos(status),"Kunde="+itos(kunde));
  if(Exists()) return;
  exec sql begin declare section;
   int AUFTRAGID=Id();
   int INSTANZ=InstanzID();
   int KUNDE=kunde;
   int STATUS=status;
  exec sql end declare section;
  exec sql insert into auftrag (instanz,auftragid,kundennr,stat) 
      values (:INSTANZ,:AUFTRAGID,:KUNDE,:STATUS);
 SQLerror::test(__FILELINE__);
}


void AuftragBase::setStatusAuftragBase(AufStatVal st) const throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,str(),"Status="+itos(st));
 exec sql begin declare section;
  int AUFTRAGID=Id();
  int INSTANZ=InstanzID();
  int STATUS=st;
 exec sql end declare section;

 exec sql update auftrag set stat= :STATUS
       where (instanz,auftragid)= (:INSTANZ,:AUFTRAGID);
 SQLerror::test(__FILELINE__"Status setzen");
}


void AuftragBase::setRabatt(const rabatt_t auftragsrabatt) const throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,str());
 exec sql begin declare section;
  int AUFTRAGID=Id();
  int INSTANZ=InstanzID();
  double RABATT=auftragsrabatt;
 exec sql end declare section;

 exec sql update auftrag set rabatt= :RABATT
       where (instanz,auftragid)= (:INSTANZ,:AUFTRAGID);
 SQLerror::test(__FILELINE__"Rabatt setzen");
}




bool AuftragBase::existEntry(const ArtikelBase& artikel,
                             const ManuProC::Datum& lieferdatum,
                             int& znr,int &newznr,mengen_t& menge,
                             AufStatVal status) const throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,str(),
         "Artikel="+cH_ArtikelBezeichnung(artikel)->Bezeichnung(),
         "LieferDatum="+lieferdatum.to_iso(),"ZNr="+itos(znr),"Status="+itos(status));
 exec sql begin declare section;
   int AUFTRAGID =Id();
   long ARTIKELID=artikel.Id();
   int INSTANZ =InstanzID();
   int ZEILENNR,NEUZNR=-99;
   double MENGE;
   char LIEFERDATUM[21];
   int STATUS=status;
 exec sql end declare section;
 lieferdatum.write_postgres(LIEFERDATUM,sizeof LIEFERDATUM);
//ECPGdebug(true,stdout);

 exec sql select zeilennr,neuzeilennr,bestellt into :ZEILENNR, :NEUZNR,:MENGE
   from auftragentry join auftragsentryzuordnung on
   (altauftragid,altinstanz,altzeilennr)=(auftragid,instanz,zeilennr)
	where (instanz,auftragid)= (:INSTANZ,:AUFTRAGID) and
      lieferdate=:LIEFERDATUM and artikelid=:ARTIKELID 
      and status=:STATUS limit 1;
 SQLerror::test(__FILELINE__,100);
 //2.Versuch ohne 'join'
 if (sqlca.sqlcode==100) ;
  { 
    exec sql select zeilennr,bestellt into :ZEILENNR, :MENGE
      from auftragentry 
   	where (instanz,auftragid)= (:INSTANZ,:AUFTRAGID) and 
      lieferdate=:LIEFERDATUM and artikelid=:ARTIKELID 
      and status=:STATUS limit 1;
    SQLerror::test(__FILELINE__,100);
   }
//ECPGdebug(false,0);

 if (sqlca.sqlcode==100) return false;
 else  {
    znr=ZEILENNR;
    newznr=NEUZNR;
    menge=MENGE;
    return true;  }
}

#include <Artikel/ArtikelBezeichnung.h> //debug
int AuftragBase::tryUpdateEntry(mengen_t bestellt, 
  const ManuProC::Datum lieferdatum,const ArtikelBase& artikel,
  AufStatVal status,int uid,const AufEintragBase& altAEB,
  st_tryUpdateEntry st_bool) const throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,str(),"Artikel="+cH_ArtikelBezeichnung(artikel)->Bezeichnung(),
         "Menge="+dtos(bestellt),"AltAEB="+altAEB.str(),
         "LieferDatum="+lieferdatum.to_iso(),
         "Status="+itos(status),"ForceNew="+itos(st_bool.force_new),
         "DispoPlanung="+itos(st_bool.dispoplanung));

 create_if_not_exists(status);
 int znr=-99,neuznr=-99;
 mengen_t altemenge=0;
 Transaction tr;
 exec sql lock table auftragentry in exclusive mode;
 SQLerror::test(__FILELINE__);  
 AuftragBase::mengen_t lagermenge=Lager_Vormerkungen::artikel_auf_lager(artikel,instanz,lieferdatum,AuftragBase::dispo_auftrag_id);
// AuftragBase::mengen_t lagermenge2=Lager_Vormerkungen::artikel_auf_lager(artikel,instanz,lieferdatum,AuftragBase::PlanId_for(instanz),false);
//cout << Instanz()->Name()<<"   Lagermenge = "<<lagermenge<<' '<<lagermenge2<<'\n';
 mengen_t auftragbestellmenge;
 if(lagermenge>=bestellt) {auftragbestellmenge = 0; lagermenge=bestellt;}
 else                      auftragbestellmenge = bestellt-lagermenge;

 if(st_bool.force_new || !existEntry(artikel,lieferdatum,znr,neuznr,altemenge,status))
  {
    Auftrag A(*this);
    AufEintragBase newaeb=A.push_back(auftragbestellmenge,lieferdatum,artikel,status,uid,false)  ;
    znr=newaeb.ZNr();
   }
 else
   {
     if(auftragbestellmenge)
      {
       mengen_t mt=AufEintragBase(instanz,auftragid,znr).updateStkDiffBase__(uid,auftragbestellmenge);
       assert(mt==auftragbestellmenge);
      }
   }

//cout << "\nTryUpdate: "<<AufEintragBase(instanz,auftragid,znr)<<'\t'
//<<"Betsellte="<<bestellt<<" Lagermenge="<<lagermenge<<" auftragbestellmenge="
//<<auftragbestellmenge<<'\t'<<st_bool.dispoplanung<<'\n';

  if(!st_bool.dispoplanung)
   {    
     if(altAEB.valid())
        AufEintragZu(altAEB).Neu(AufEintragBase(*this,znr),bestellt);
//cout << AufEintragBase(*this,znr)<<'\t'<<altemenge<<'+'<<auftragbestellmenge<<'\t'
//<<bestellt<<' '<<lagermenge<<'\n';
     Lager_Vormerkungen(class AufEintrag(Instanz()->Id(),Id(),znr,
            altemenge+auftragbestellmenge,artikel,lieferdatum,status)).
            vormerken_oder_bestellen(uid,lagermenge,bestellt,st_bool);
   }
  else 
   {
     if(altAEB.valid())
        AufEintragZu(class AufEintragBase(*this,znr)).Neu(altAEB,bestellt);
   }

  tr.commit();
  return znr;
}


