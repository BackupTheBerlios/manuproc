// $Id: ArtikelBezeichnung.pgcc,v 1.29 2005/06/17 15:17:06 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Artikel/ArtikelBezeichnung.h>
#include <Artikel/ArtikelStamm.h>
#include <Misc/string0.h>
#include <Misc/Transaction.h>
#include <Misc/mystream.h>
exec sql include sqlca;
#include <Misc/FetchIStream.h>
//#include <Misc/dbconnect.h>
#include <unistd.h>
#include <sys/types.h>


#ifdef MABELLA_EXTENSIONS
#include <Aux/EAN.h>
#endif

ArtikelBezeichnung::ArtikelBezeichnung(const ArtikelBase &artikel, const cH_ExtBezSchema &_schema) throw()
 : ArtikelBase(artikel), schema(_schema)
{  *this=ArtikelBezeichnung(artikel,_schema->Id());
}

ArtikelBezeichnung::ArtikelBezeichnung(const ArtikelBase &artikel, ExtBezSchema::ID _schema) throw()
 : ArtikelBase(artikel), schema(ExtBezSchema::default_ID)
{  try
   {  ArtikelStamm AS( artikel );
      try 
      { setzeExtBezSchema(cH_ExtBezSchema(_schema,AS.Warengruppe(_schema)));
        return;
      } catch (SQLerror &e) {}

      try  // für interne Artikel zuerst internwarengruppe beim Kunden suchen
      { if (_schema==ExtBezSchema::default_ID)
        {   setzeExtBezSchema(cH_ExtBezSchema(AS.defaultSchema(),
                     AS.Warengruppe(_schema)));
              return;
        }
      } catch (SQLerror &e) {} 

      try // last resort: default
      {  setzeExtBezSchema(cH_ExtBezSchema(AS.defaultSchema(),
		   			AS.Warengruppe(AS.defaultSchema())));
         return;
      } catch (SQLerror &e) { } 
   }
  catch (SQLerror &e) { }
}

void ArtikelBezeichnung::setzeExtBezSchema(const cH_ExtBezSchema &_schema) throw(SQLerror)
{   
 schema = _schema;

    value.clear();
    
    unsigned neededsize=0;
    if (Id())
    {mystream sq; 
     std::vector<int> gewaehlte_indizes;
     sq << "SELECT ";
     for (ExtBezSchema::const_iterator i=schema->begin();i!=schema->end();)
      {
         sq << i->spaltenname;
         gewaehlte_indizes.push_back(i->bezkomptype);
         if (unsigned(i->bezkomptype+1)>neededsize) neededsize=i->bezkomptype+1;
         ++i;
         if (i!=schema->end()) sq <<", " ;
      }
     sq << " FROM artbez_" << int(schema->Typ()) <<"_"<<schema->Id()<<" WHERE id = "
         << Id();
     Query q(sq.str());
     SQLerror::test(__FILELINE__);
     
     value.resize(neededsize);
     FetchIStream is=q.Fetch();
     for (std::vector<int>::const_iterator i=gewaehlte_indizes.begin();i!=gewaehlte_indizes.end();++i)
      {  std::string s;
         is >> FetchIStream::MapNull(s,std::string());
         value[*i]=cH_EntryValueIntString(s);
      }
    }
} 


void ArtikelBezeichnung::setzeExtBezSchema(
		const std::vector<cH_EntryValueIntString> &_val,
		const cH_ExtBezSchema &_schema)
{   
 schema = _schema;

 value.clear();
    
 if (Id())
    {
     value.resize(_val.size()+1);
     int cnt=1;
     for (std::vector<cH_EntryValueIntString>::const_iterator i=_val.begin();
			i!=_val.end();++i)
         value[cnt++]=(*i);
    }
} 

std::string ArtikelBezeichnung::Bezeichnung(int signifikanz, char separator,int felder) const throw()
{   std::string ret;
    int f=0;
    const_sigiterator end=sigend(signifikanz);
    for (const_sigiterator i=sigbegin(signifikanz);i!=end;++i)
    {  if (i.BezKomp().bezkomptype<0 
    		|| (unsigned int)i.BezKomp().bezkomptype>value.size()) 
    	  continue;
       ret+=value[i.BezKomp().bezkomptype]->getStrVal();
       if (separator)
       {  const_sigiterator h=i;
          ++h;
          if (h!=end) ret+=char(separator); 
       }
       else ret+=i.BezKomp().separator;
       ++f;
    }
    if (separator)
    {  for (;f<felder;++f) ret+=char(separator);
    } 
    return ret;
}

cH_EntryValue ArtikelBezeichnung::Komponente_als_EntryValue
	(int feldnr,int signifikanz) const throw()
{
    const_sigiterator end=sigend(signifikanz);
    for (const_sigiterator i=sigbegin(signifikanz);i!=end;++i)
    {
       if (i.BezKomp().bezkomptype<0 
    		|| (unsigned int)i.BezKomp().bezkomptype>value.size()) 
    	  continue;
      if (feldnr==i.BezKomp().folgenr_in_sig) 
	 return value[i.BezKomp().bezkomptype];
    }
 return cH_EntryValue();
}




ArtikelBezeichnung::ArtikelBezeichnung(int signifikanz, const std::vector<cH_EntryValue> &_val, const cH_ExtBezSchema &_schema) throw(SQLerror)
: schema(_schema)
{
 exec sql begin declare section;
 long ARTIKELID;
 char *QUERY;
 exec sql end declare section;
 mystream squery;
 squery << "SELECT id FROM artbez_"<<int(schema->Typ())<<"_"<<schema->Id()
      << " WHERE ";
 int f=0;
 for (ExtBezSchema::const_iterator i=schema->begin();i!=schema->end();)
   {
     if (i->signifikanz != signifikanz) {++i; continue;}
     squery << i->spaltenname << " = '" << _val[f]->getStrVal() <<"'";
     ++f;
     do 
     ++i;
     while (i!=schema->end() && i->signifikanz != signifikanz ) ;
     if (i!=schema->end()) squery <<" AND " ;
   }

 std::string query = squery.str(); 
   
 try
 {  QUERY=const_cast<char*>(query.c_str());
    Transaction tr;
    exec sql prepare QUERY2 from :QUERY;
    exec sql declare loadart cursor for QUERY2;
    exec sql open loadart;
    SQLerror::test("ArtikelBox::loadArtikel: select artikelid");
    exec sql fetch in loadart into :ARTIKELID;
    SQLerror::test("ArtikelBox::loadArtikel: fetch artikelid");
    exec sql close loadart;
    tr.commit();
 }
 catch (SQLerror &e) { throw; }
 
 *(ArtikelBase*)this=ArtikelBase(ARTIKELID);
 setzeExtBezSchema(schema);
}


ArtikelBezeichnung::ArtikelBezeichnung(const ArtikelBase &artikel, 
const std::vector<cH_EntryValueIntString> &_val, const cH_ExtBezSchema &_schema) throw()
: schema(_schema)
{
 *(ArtikelBase*)this=artikel;
// setzeExtBezSchema(_val,schema);
 setzeExtBezSchema(schema);
}

cH_ArtikelBezeichnung::cache_t cH_ArtikelBezeichnung::cache;

cH_ArtikelBezeichnung::cH_ArtikelBezeichnung(const ArtikelBase &artikel,const cH_ExtBezSchema &schema) throw(SQLerror)
{  *this=cH_ArtikelBezeichnung(artikel,schema->Id());
}

cH_ArtikelBezeichnung::cH_ArtikelBezeichnung(const ArtikelBase &artikel,const ExtBezSchema::ID id) throw(SQLerror)
{  cH_ArtikelBezeichnung *cached(cache.lookup(cache_key(id,artikel.Id())));
   if (cached) *this=*cached;
   else
   {  *this=cH_ArtikelBezeichnung(new ArtikelBezeichnung(artikel,id));
      cache.Register(cache_key(id,artikel.Id()),*this);
   }
}

const cH_EntryValue ArtikelBezeichnung::const_sigiterator::operator*() const
{  return container[BezKomp().bezkomptype];
}

#if 0
const cH_EntryValue *ArtikelBezeichnung::const_sigiterator::operator->() const
{  return &container[BezKomp().bezkomptype];
}
#endif

std::string ArtikelBezeichnung::Tabellenname(const cH_ExtBezSchema &s)
{  return "artbez_"+itos(s->Typ().Id())+"_"+itos(s->Id());
}

void ArtikelBezeichnung::Anlegen(const cH_ExtBezSchema &schema,const ArtikelBase &art,
  	const std::string &columns, const std::string &values)
{  std::string col="(id,"+columns+",";
   std::string val="("+itos(art.Id())+","+values+",";
#if defined(MABELLA_EXTENSIONS)  && defined(MANUPROC_DYNAMICENUMS_CREATED)
  if(schema->Id()==ExtBezSchema::default_id && 
	ArtikelTyp::hasAttribute(schema->Typ(),
	  ManuProC::DynamicEnums::ArtikelTyp_Attributes::mit_ean))
     {
     col +="ean,";
     val += EAN::next_value(schema->Typ())+",";
     }  
#endif

#if defined MABELLA_EXTENSIONS && defined(MANUPROC_DYNAMICENUMS_CREATED)
   int prozess=40; // Rollen allgemein   
   if(ArtikelTyp::hasAttribute(schema->Typ(),
	  ManuProC::DynamicEnums::ArtikelTyp_Attributes::bez_as_view))
     {col+="prozess,uid,";
      val+=itos(prozess)+","+itos(getuid())+","; 
     }
#endif

   assert(col[col.size()-1]==',' && val[val.size()-1]==',');
   col[col.size()-1]=')';
   val[val.size()-1]=')';

   Query("insert into "+Tabellenname(schema) +" "+ col+" values "+val);
   SQLerror::test(__FILELINE__,100);
}

const ArtikelBezeichnung &ArtikelBezeichnung::operator=(const ArtikelBezeichnung &b)
 {  *(ArtikelBase*)this=(const ArtikelBase&)b;
    schema=b.schema;
    value=b.value;
    return *this;
 }

void ArtikelBezeichnung::setID(const ArtikelBase &id) throw(SQLerror)
#if 0
 {  *(ArtikelBase*)this=id;
    schema=b.schema;
    value=b.value;
    return *this;
 }
#endif
// this->operator=(ArtikelBezeichnung(id,schema->Id())); }
{ *this=ArtikelBezeichnung(id,schema->Id()); }
