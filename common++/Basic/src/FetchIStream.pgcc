// $Id: FetchIStream.pgcc,v 1.53 2004/09/02 07:45:54 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 2001 Adolf Petig GmbH & Co. KG, written by Christof Petig
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

// NOTE that this code might be duplicated for SQLite

#include <ManuProCConfig.h>
#ifndef MPC_SQLITE
#include <Misc/FetchIStream.h>
#include <Misc/SQLerror.h>
#include <Misc/itos.h>

exec sql include sqlca;

#ifdef OLD_ECPG
#define ECPGdo300
#else
#define ECPGdo300 0,1,
#endif

#define DEBUG_FIS(x) std::cerr << x << '\n'
// ,y...) x,##y

extern "C" {
extern PGresult **ECPGdescriptor_lvalue(int line, const char *descriptor);
}

// ecpg incoming descriptor has to be FetchIStream

FetchIStream::FetchIStream(const std::string &descr, int line)
	: naechstesFeld(0), zeile(line), result(0)
{  PGresult **r=ECPGdescriptor_lvalue(__LINE__,descr.c_str());
   if (r) result=*r;
}

FetchIStream &FetchIStream::operator>>(std::string &str)
{  if (!result)
	mythrow(SQLerror(__FUNCTION__,ECPG_UNKNOWN_DESCRIPTOR,"no result to fetch from (left?)"));
   if (naechstesFeld>=PQnfields(result)) 
	mythrow(SQLerror(__FUNCTION__,ECPG_INVALID_DESCRIPTOR_INDEX,"reading beyond line end"));
   if (PQgetisnull(result, zeile, naechstesFeld))
	mythrow(SQLerror(__FUNCTION__,ECPG_MISSING_INDICATOR,"missing indicator"));
   const char *pval = PQgetvalue(result, zeile, naechstesFeld);
   if (pval) str=pval;
   else str="";
   if (Query::debugging.on) 
      std::cerr << "FIS result["<<zeile<<','<<naechstesFeld<<"]="<<str << '\n';
   naechstesFeld++;
   return *this;
}

void FetchIStream::ThrowIfNotEmpty(const char *where)
{  if (!result)
	mythrow(SQLerror(where,ECPG_UNKNOWN_DESCRIPTOR,"no result to fetch from"));
   if (naechstesFeld<PQnfields(result))
	mythrow(SQLerror(where,ECPG_TOO_FEW_ARGUMENTS,"too few arguments"));
}

int FetchIStream::getIndicator() const
{  if (naechstesFeld>=PQnfields(result)) 
	mythrow(SQLerror("FetchIStream::getIndicator",ECPG_INVALID_DESCRIPTOR_INDEX,"reading beyond line end"));
   return -PQgetisnull(result, zeile, naechstesFeld);
}


/// QUERY

// note cursor is the name for both the cursor and the descriptor
void Query::Execute() throw(SQLerror)
{  exec sql begin declare section;
   char *COMMAND=const_cast<char*>(query.c_str());
   exec sql end declare section;

   eof=false;
//   exec sql allocate descriptor X;
sqlca.sqlcode=0;
   ECPGallocate_desc(__LINE__, descriptor.c_str());
   if (sqlca.sqlcode) { DEBUG_FIS(SQLerror("allocate descriptor")); eof=true; }
//   exec sql prepare com from :COMMAND;
//   exec sql execute com into descriptor X;
   ECPGdo(__LINE__, ECPGdo300 NULL, COMMAND, 
   	ECPGt_EOIT,
   	ECPGt_descriptor, descriptor.c_str(), 0L, 0L, 0L,
   	ECPGt_NO_INDICATOR, NULL , 0L, 0L, 0L, ECPGt_EORT);
   error=sqlca.sqlcode;
   lines=sqlca.sqlerrd[2];
   if (sqlca.sqlcode && sqlca.sqlcode!=100)
   {  eof=true;
      FetchIStream::mythrow(SQLerror(query)); 
   }
   else if (sqlca.sqlcode==100 && Query::debugging.on)
   {  DEBUG_FIS("no lines returned/changed");
   }
   result=*(ECPGdescriptor_lvalue(__LINE__,descriptor.c_str()));
}

// note cursor is the name for both the cursor and the descriptor
Query::Query(const std::string &command)
: descriptor(std::string("Query")+ulltos(reinterpret_cast<unsigned long long>(this))), 
	eof(true), line(), result(), query(command), num_params(), 
	error(ECPG_TOO_FEW_ARGUMENTS), lines()
{  const char *p=query.c_str();
   while ((p=ArgumentList::next_insert(p))) { ++num_params; ++p; }
   params.setNeededParams(num_params);
   Execute_if_complete();
}

Query::~Query()
{  if (!params.complete())
   {  std::cerr << "The query " << query << " still needed " 
   	<< params.HowManyNeededParams() 
   	<< " parameters on destruction and got never executed!\n";
      if (Query::debugging.on)
      {  std::cerr << "existing parameters: ";
         for (ArgumentList::const_iterator i=params.begin();i!=params.end();
			++i)
            std::cerr << *i << ',';
         std::cerr << '\n';
      }
      sqlca.sqlcode=ECPG_TOO_FEW_ARGUMENTS;
   }
   else
   {  
#ifdef OLD_ECPG
      struct sqlca copy=sqlca;
#else
      struct sqlca_t copy=sqlca;
#endif      
      //   exec sql deallocate descriptor X;
      ECPGdeallocate_desc(__LINE__, descriptor.c_str());
      // do not change sqlca ... believe me, you don't want to
      sqlca=copy;
   }
}

void Query::Fetch(FetchIStream &is)
{  if (!params.complete())
      FetchIStream::mythrow(SQLerror(query,ECPG_TOO_FEW_ARGUMENTS,"to few input parameter"));
   if (!eof)
   {  if (line<PQntuples(result)) 
      {  is=FetchIStream(result,line++);
         return;
      }
      eof=true;
   }
 is=FetchIStream();
}

void Query::Execute(const std::string &command) throw(SQLerror)
{  exec sql begin declare section;
   char *COMMAND=const_cast<char*>(command.c_str());
   exec sql end declare section;

   exec sql execute immediate :COMMAND;
}

int Query::Code() {  
	return sqlca.sqlcode; 
}

unsigned Query::Lines() { 
	return sqlca.sqlerrd[2]; 
}
#endif
