/*  pps: ManuProC's production planning system
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/Auftrag.h>
#include<stdio.h>
#include <Misc/Transaction.h>
#include<Misc/Changejournal.h>
#include <Auftrag/auftrag_status.h>
#include "AufEintrag.h"
#include <Artikel/ArtikelStamm.h>
#include <Auftrag/AufEintragZu.h>
#include <Misc/TraceNV.h>
#include <Auftrag/VerfuegbareMenge.h>
#include <Misc/FetchIStream_fixedpoint.h>

exec sql include sqlca;

// aufid sollte string sein (es ist immerhin youraufnr gemeint)
AuftragBase::AuftragBase(cH_ppsInstanz _instanz, ID aufid,Kunde::ID kid) throw(SQLerror)
: instanz(_instanz),auftragid(none_id)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 Query("select auftragid from auftrag "
 	"where instanz=? and kundennr=? and youraufnr=?")
 	<< instanz->Id() << kid << aufid
 	>> auftragid;
}

Query &operator<<(Query &q, const AuftragBase &ab)
{  return q << ab.InstanzID() << ab.Id();
}

bool AuftragBase::Exists() const throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 return (Query("select exists(select true from auftrag "
 		"where (instanz,auftragid)=(?,?))").lvalue()
 	<< *this)
 	.FetchOne<bool>();
}

void AuftragBase::create_if_not_exists(AufStatVal status,Kunde::ID kunde) const
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,NV("Status",status),NV("Kunde",kunde));
  if(Exists()) return;
  Query("insert into auftrag (instanz,auftragid,kundennr,stat) "
  	"values (?,?,?,?)").lvalue()
  	<< *this << kunde << status;
 SQLerror::test(__FILELINE__);
}


void AuftragBase::setStatusAuftragBase(AufStatVal st) const throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,NV("Status",st));
 Query("update auftrag set stat=? where (instanz,auftragid)=(?,?)").lvalue()
 	<< st << *this;
 SQLerror::test(__FILELINE__"Status setzen");
}


void AuftragBase::setRabatt(const rabatt_t auftragsrabatt) const throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 Query("update auftrag set rabatt=? where (instanz,auftragid)=(?,?)").lvalue()
 	<< auftragsrabatt << *this;
 SQLerror::test(__FILELINE__"Rabatt setzen");
}

// braucht irgendjemand newznr?, sonst könnte ein join wegfallen!!!

bool AuftragBase::existEntry(const ArtikelBase& artikel,
                             const ManuProC::Datum& lieferdatum,
                             int& znr,int &newznr,mengen_t& menge,
                             AufStatVal status) const throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,
         NV("Artikel",artikel),
         NV("LieferDatum",lieferdatum),NV("ZNr",znr),NV("Status",status));
 exec sql begin declare section;
   int AUFTRAGID =Id();
   long ARTIKELID=artikel.Id();
   int INSTANZ =InstanzID();
   int ZEILENNR,NEUZNR=-99;
   double MENGE;
   char LIEFERDATUM[21];
   int STATUS=status;
 exec sql end declare section;
 lieferdatum.write_postgres(LIEFERDATUM,sizeof LIEFERDATUM);
//ECPGdebug(true,stdout);

 exec sql select zeilennr,neuzeilennr,bestellt into :ZEILENNR, :NEUZNR,:MENGE
   from auftragentry join auftragsentryzuordnung on
   (altauftragid,altinstanz,altzeilennr)=(auftragid,instanz,zeilennr)
	where (instanz,auftragid)= (:INSTANZ,:AUFTRAGID) and
      lieferdate=:LIEFERDATUM and artikelid=:ARTIKELID 
      and status=:STATUS limit 1;
 SQLerror::test(__FILELINE__,100);
 //2.Versuch ohne 'join'
 if (sqlca.sqlcode==100) ;
  { 
    exec sql select zeilennr,bestellt into :ZEILENNR, :MENGE
      from auftragentry 
   	where (instanz,auftragid)= (:INSTANZ,:AUFTRAGID) and 
      lieferdate=:LIEFERDATUM and artikelid=:ARTIKELID 
      and status=:STATUS limit 1;
    SQLerror::test(__FILELINE__,100);
   }
//ECPGdebug(false,0);

 if (sqlca.sqlcode==100) return false;
 else  {
    znr=ZEILENNR;
    newznr=NEUZNR;
    menge=MENGE;
    return true;  }
}



