// $Id: Kunde_sql.pgcc,v 1.18 2002/05/06 13:41:23 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Christof Petig
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */


#include "Kunde/Kunde.h"
#include <Kunde/Person.h>
#include <Aux/Transaction.h>
#include <Kunde/Telefon.h>
#include <Aux/FetchIStream.h>


Kunde::Kunde(ID _id) throw(SQLerror) 
: ManuProcEntity(_id), KundenGruppennr(0),schema(ExtBezSchema::default_id),rngan(0),
  rng_an_postfach(false),lieferadresse(false),rechnungsadresse(false),
  entsorg(false),
  waehrung(WaehrungID::EUR)
{ 
   // return ersetzen
   if(_id == Kunde::none_id) return;
   exec sql begin declare section;
   int ID=_id,GRUPPENID,BEZSCHEMA,BANKINDEX,RNG_AN,PREISLISTE;
   char SORTNAME[31], IDNR[21];
   char NAME[61], STRASSE[36], HSNR[8], POSTFACH[21],ORT[31],BANKNAME[51],
         PLZ[11],POSTFACHPLZ[11],KTONR[11],BLZ[11],POSTANWVOR[41],POSTANWNACH[41];
   int LANDESID;
   int ILLEGALLANDID;
   int FLAECHE,MITARBEITER;
   double KUNDENUMSATZ,PLANUMSATZ,UMSATZ, RABATT,EINZUGRABATT,SKONTOSATZ;
   bool ZEILENRABATT;
   int SKONTOFRIST;
   char VEREIN[31];
   bool BANKEINZUG,LIEFERADRESSE,RECHUNGSADRESSE,ENTSORGUNG,RNGANLFRA;
   char NOTIZ[2048];
   char STAND[50];
   int WAEHRUNGID;
   int VERKNR;
   int BETREUER;
   int LIEFERANTENKONTO,GEGENKONTO;
   char UNSERE_KUNDENNR[128];
   exec sql end declare section;
   ILLEGALLANDID=LandesListe::none_id;
//Sonderpreislisten werden getrennt geholt
  
   Transaction tr;
 
   WAEHRUNGID = WaehrungID::EUR;

///XXX STAND 'now' stimmt noch nicht MAT
   exec sql select coalesce(gruppennr,0), firma,coalesce(sortname,''),
    coalesce(extartbezid,1),
	 coalesce(strasse,''),
    coalesce(postanwvor,''),coalesce(postanwnach,''),
         coalesce(hsnr,''),coalesce(plz,''),coalesce(postfach,''),
         coalesce(postfplz,''),coalesce(ort,''),coalesce(text(ktonr),''),
         coalesce(text(b.blz),''), coalesce(b.name,''), coalesce(b.bankindex,0),
         coalesce(rechnung_an,kundennr), coalesce(preisliste,kundennr), 
         coalesce(idnr,''),
         coalesce(lieferadresse,false), coalesce(rechnungsadresse,false), 
         coalesce(rng_an_postfach,false),
         coalesce(flaeche,0),coalesce(mitarbeiter,0),
   /* the 0.0s are to make typing more strict, which gives an error
      once it is read into the wrong variable */
         coalesce(kundenumsatz,0.0),
         coalesce(planumsatz,0.0),coalesce(umsatz,0.0),
         coalesce(rabatt,0.0),coalesce(zeilenrabatt,false),coalesce(einzugrabatt,0.0),coalesce(skontofrist,0),
         coalesce(verein,''),coalesce(bankeinzug,false), coalesce(notiz,''), 
         coalesce(stand,now()),	coalesce(landid,:ILLEGALLANDID),
	 coalesce(waehrungid,:WAEHRUNGID),
	 coalesce(entsorgung,false), coalesce(skontosatz,0),
    coalesce(verknr,0),coalesce(lieferantenkonto,0),
    coalesce(gegenkonto,0),coalesce(unsere_kundennr,''),
	coalesce(betreuer,0)
   	into :GRUPPENID ,:NAME, :SORTNAME, :BEZSCHEMA, :STRASSE, :POSTANWVOR, :POSTANWNACH,
           :HSNR, :PLZ, :POSTFACH,
           :POSTFACHPLZ, :ORT, :KTONR, :BLZ, :BANKNAME, :BANKINDEX, :RNG_AN,
           :PREISLISTE, :IDNR,
            :LIEFERADRESSE,:RECHUNGSADRESSE,:RNGANLFRA,
           :FLAECHE,:MITARBEITER,:KUNDENUMSATZ,:PLANUMSATZ,:UMSATZ,
	   :RABATT,:ZEILENRABATT,:EINZUGRABATT,:SKONTOFRIST, :VEREIN, :BANKEINZUG,
	   :NOTIZ,:STAND, :LANDESID, :WAEHRUNGID, :ENTSORGUNG, :SKONTOSATZ,:VERKNR,
      :LIEFERANTENKONTO,:GEGENKONTO,:UNSERE_KUNDENNR,:BETREUER
   	from kunden k left join banken b using(bankindex)
   	where kundennr= :ID;

   SQLerror::test(__FILELINE__);


   schema=BEZSCHEMA;
   adresse.firma=NAME;
   adresse.sortname=SORTNAME;
   adresse.strasse=STRASSE;
   adresse.postanwvor=POSTANWVOR;
   adresse.postanwnach=POSTANWNACH;
   adresse.hsnr=HSNR;
   adresse.plz=PLZ;
   adresse.postfach=POSTFACH;
   adresse.postfachplz=POSTFACHPLZ;
   adresse.ort=ORT;
   adresse.land = cH_LandesListe(LANDESID);
   adresse.unsere_kundennr = UNSERE_KUNDENNR;
   IDnr=IDNR;
   lieferadresse=LIEFERADRESSE;
   rechnungsadresse=RECHUNGSADRESSE;
   rng_an_postfach=RNGANLFRA;
   bankverb.konto=strtoll(KTONR,NULL,10);
   bankverb.blz=strtoul(BLZ,NULL,10);
   bankverb.bank=BANKNAME;
   bankverb.bankindex=BANKINDEX;
   bankverb.lieferantenkonto=LIEFERANTENKONTO;
   bankverb.gegenkonto=GEGENKONTO;
   rngan=RNG_AN;
   kundendaten.preisliste=PREISLISTE;
   entsorg = ENTSORGUNG;

   kundendaten.flaeche = FLAECHE;
   kundendaten.mitarbeiter=MITARBEITER;
   kundendaten.kundenumsatz=KUNDENUMSATZ;
   kundendaten.planumsatz=PLANUMSATZ;
   kundendaten.umsatz=UMSATZ;
   kundendaten.rabatt=RABATT;
   kundendaten.zeilenrabatt=ZEILENRABATT;
   kundendaten.einzugrabatt=EINZUGRABATT;
   kundendaten.skontosatz=SKONTOSATZ;
   kundendaten.skontofrist=SKONTOFRIST;
   kundendaten.verein=VEREIN;
   kundendaten.bankeinzug=BANKEINZUG;
   kundendaten.stand=STAND;
   kundendaten.notiz=NOTIZ;
   waehrung = cP_Waehrung(Waehrung::ID(WAEHRUNGID));

   verkaeufer.verknr=VERKNR;
   betreuer=BETREUER==0 ? Person::none_id : BETREUER;
}

const cH_Kunde Kunde::newKunde(const Kunde::ID kid, const std::string &firma) throw(SQLerror)
{
 exec sql begin declare section;
 int KID=kid;
 char *FIRMA;
 exec sql end declare section;

 Transaction tr;

 FIRMA=(char*)firma.c_str();
 
 exec sql insert into kunden (kundennr, firma) values (:KID, :FIRMA);
 SQLerror::test(__FILELINE__);
 
 tr.commit();

 return cH_Kunde(KID);
 
}

void Kunde::delete_Kunde(const Kunde::ID kid) throw(SQLerror)
{
 exec sql begin declare section;
    int KID=kid;
 exec sql end declare section;

 exec sql delete from kunden where kundennr = :KID;
 SQLerror::test(__FILELINE__);
}

unsigned int Kunde::nextval()
{
 exec sql begin declare section;
   unsigned int KUNDENNR;
 exec sql end declare section;
 exec sql select nextval('kunden_seq') into :KUNDENNR;
 SQLerror::test(__FILELINE__);
 return KUNDENNR;
}

void Kunde::get_blz_from_bankindex(unsigned int bankindex)
{
 exec sql begin declare section;
   unsigned int BANKINDEX=bankindex;
   unsigned long int BLZ;   
 exec sql end declare section;
 exec sql select blz into :BLZ from banken where bankindex=:BANKINDEX;
 SQLerror::test(__FILELINE__);
 bankverb.blz=BLZ;
}


unsigned long int Kunde::neue_bank_anlegen(const std::string& name, unsigned long int blz)
{
 exec sql begin declare section;
   unsigned int BANKINDEX;
   char NAME[50];
   unsigned long int BLZ=blz;   
 exec sql end declare section;
 exec sql select nextval('banken_bankindex_seq') into :BANKINDEX;
 SQLerror::test(__FILELINE__);
 strncpy(NAME,name.c_str(),sizeof(NAME));
 exec sql insert into banken (bankindex,name,blz)
   values (:BANKINDEX,:NAME,:BLZ);
 SQLerror::test(__FILELINE__);
 return BANKINDEX;
}


void Kunde::reread_Stand() throw(SQLerror)
{
 exec sql begin declare section;
 unsigned int KUNDENNR = entityid;
 char STAND[20];
 exec sql end declare section;

 exec sql select stand into :STAND from kunden where kundennr = :KUNDENNR;
 SQLerror::test(__FILELINE__);
 
 kundendaten.stand = STAND; 

}

vector<Kunde::st_ansprech> Kunde::getPersonen() const
{
  exec sql begin declare section;
      char *QUERY;
      int PERSNR;
      char NOTIZ[1024];
      char POSITION[100];
  exec sql end declare section;

  std::string QU=" SELECT a.persnr,coalesce(a._position,''),coalesce(a.notiz,'') FROM "
         "ku_person p, ku_ansprech a"
         " WHERE p.persnr=a.persnr and a.kundennr ="+
         itos(Id())+" ORDER BY name";

  QUERY=(char*)QU.c_str();

  Transaction tr;

  exec sql prepare ein_ from :QUERY;
  exec sql declare ein cursor for ein_ ;
  exec sql open ein;
  SQLerror::test(__FILELINE__);
  vector<st_ansprech> VP;
  while (true)
   {
     exec sql fetch ein into :PERSNR,:POSITION,:NOTIZ;
     SQLerror::test(__FILELINE__,"ein",100);
     if (sqlca.sqlcode) break;
     VP.push_back(st_ansprech(cH_Person(PERSNR),POSITION,NOTIZ));
   }
  exec sql close ein;

  tr.close();
  return VP;  
}

std::list<cH_Telefon> Kunde::getTelefon() const
{
 exec sql begin declare section;
   int TELID;   
   int KUNDENNR=Id();
 exec sql end declare section;

 Transaction tr;
 
 exec sql declare telein cursor for
   SELECT telid FROM ku_telefon WHERE kundennr= :KUNDENNR and persnr is null;
 exec sql open telein;
 SQLerror::test(__FILELINE__);
 std::list<cH_Telefon> T;
 while(true)
   {
      exec sql fetch telein into :TELID;
      SQLerror::test(__FILELINE__,"teleein",100);
      if (sqlca.sqlcode) break;
      T.push_back(cH_Telefon(TELID));
   }
 exec sql close telein;
 tr.close(); 
 return T;
}

const Kunde::Verkaeufer Kunde::getVerkaeufer()
{
  exec sql begin declare section;
   int VERKNR=verkaeufer.verknr;
   char NAME[31],KURZ[6];
  exec sql end declare section;
  exec sql select name,kurz into :NAME,:KURZ
      from ku_verkaeufer where verknr=:VERKNR;
  SQLerror::test(__FILELINE__);
  verkaeufer.name=NAME;
  verkaeufer.kurz=KURZ;
  return verkaeufer;
}

enum Kunde::B_UPDATE_BITS_ADRESSE &operator++(enum Kunde::B_UPDATE_BITS_ADRESSE &s)
{  return (enum Kunde::B_UPDATE_BITS_ADRESSE)(++(int&)s);
}
enum Kunde::B_UPDATE_BITS_FIRMA &operator++(enum Kunde::B_UPDATE_BITS_FIRMA &s)
{  return (enum Kunde::B_UPDATE_BITS_FIRMA)(++(int&)s);
}
enum Kunde::B_UPDATE_BITS_BANK &operator++(enum Kunde::B_UPDATE_BITS_BANK &s)
{  return (enum Kunde::B_UPDATE_BITS_BANK)(++(int&)s);
}
enum Kunde::B_UPDATE_BITS_SONST &operator++(enum Kunde::B_UPDATE_BITS_SONST &s)
{  return (enum Kunde::B_UPDATE_BITS_SONST)(++(int&)s);
}

void Kunde::update_e(UpdateBitsAdresse e)
{
  std::string query ="update kunden set ";
  for(B_UPDATE_BITS_ADRESSE i=B_UPDATE_BITS_ADRESSE(0);i<B_MaxAnzA;++i)
   {
     if(!(e&(1<<i))) continue;
     if      (i==B_Gruppennr  ) query += "gruppennr = '"+itos(GruppenId())+"',";
     else if (i==B_Sortname   ) query += "sortname = nullif('"+sortname()+"',''),";
     else if (i==B_Idnr       ) query += "idnr = '"+idnr()+"',";
     else if (i==B_Firma      ) query += "firma  = '"+firma()+"',";
     else if (i==B_Postanwvor ) query += "postanwvor  = '"+postanwvor()+"',";
     else if (i==B_Strasse    ) query += "strasse  = '"+strasse()+"',";
     else if (i==B_Postanwnach) query += "postanwnach  = '"+postanwnach()+"',";
     else if (i==B_Hsnr       ) query += "hsnr  = '"+hausnr()+"',";
     else if (i==B_Plz        ) query += "plz  = '"+plz()+"',";
     else if (i==B_Postfach   ) query += "postfach  = '"+postfach()+"',";
     else if (i==B_Postfachplz) query += "postfplz  = '"+postfachplz()+"',";
     else if (i==B_Ort        ) query += "ort  = '"+ort()+"',";
     else if (i==B_Lkz           ) query += "landid  = '"+itos(land()->Id())+"',";
     else if (i==B_Lieferadresse  ) query += "lieferadresse  = "+btos(isLieferadresse())+",";
     else if (i==B_Rechnungadresse) query += "rechnungsadresse  = "+btos(isRechnungsadresse())+",";
     else if (i==B_Rng_an_postfach) query += "rng_an_postfach  = "+btos(Rng_an_postfach())+",";
   }
 query += "stand  = now() where kundennr = "+itos(Id());
 Query::Execute(query);
 SQLerror::test(__FILELINE__);
} 

void Kunde::update_e(UpdateBitsFirma e)
{
  std::string query ="update kunden set ";
  for(B_UPDATE_BITS_FIRMA i=B_UPDATE_BITS_FIRMA(0);i<B_MaxAnzF;++i)
   {
     if(!(e&(1<<i))) continue;
     if      (i==B_Planumsatz    ) query += "planumsatz  = "+dtos(planumsatz())+",";
     else if (i==B_Umsatz        ) query += "umsatz  = "+dtos(umsatz())+",";
     else if (i==B_Mitarbeiter   ) query += "mitarbeiter  = "+itos(mitarbeiter())+",";
     else if (i==B_Kundenumsatz  ) query += "kundenumsatz  = "+dtos(kundenumsatz())+",";
     else if (i==B_Flaeche       ) query += "flaeche  = "+itos(flaeche())+",";
     else if (i==B_UnsereKundenNr) query += "unsere_kundennr  = '"+UnsereKundenNr()+"',";
     else if (i==B_Verein     ) query += "verein = '"+verein()+"',";
   }
 query += "stand  = now() where kundennr = "+itos(Id());
 Query::Execute(query);
 SQLerror::test(__FILELINE__);
} 

void Kunde::update_e(UpdateBitsBank e)
{
  std::string query ="update kunden set ";
  for(B_UPDATE_BITS_BANK i=B_UPDATE_BITS_BANK(0);i<B_MaxAnzB;++i)
   {
     if(!(e&(1<<i))) continue;
     if      (i==B_Ktonr       ) query += "ktonr  = '"+ulltos(getKtnr())+"',";
//     else if (i==B_Blz         ) query += "bankindex  = "+itos(getindex())+",";
     else if (i==B_Bankindex   ) query += "bankindex  = "+itos(getindex())+",";
     else if (i==B_Bankeinzug  ) query += "bankeinzug  = "+btos(bankeinzug())+",";
     else if (i==B_Rabatt      ) query += "rabatt      = "+dtos(rabatt())+",";
     else if (i==B_Zeilenrabatt) query += "zeilenrabatt= "+btos(zeilenrabatt())+",";
     else if (i==B_Waehrungid  ) query += "waehrungid  = "+itos(getWaehrung()->Id())+",";
     else if (i==B_Einzugrabatt) query += "einzugrabatt= "+dtos(einzugrabatt())+",";
     else if (i==B_Skontosatz  ) query += "skontosatz  = "+dtos(skontosatz())+",";
     else if (i==B_Skontofrist ) query += "skontofrist = "+itos(skontofrist())+",";
     else if (i==B_Lieferantenkonto ) query += "lieferantenkonto = "+itos(getLieferantenkonto())+",";
     else if (i==B_Gegenkonto  ) query += "gegenkonto = "+itos(getGegenkonto())+",";
   }
 query += "stand  = now() where kundennr = "+itos(Id());
 Query::Execute(query);
 SQLerror::test(__FILELINE__);
} 

void Kunde::update_e(UpdateBitsSonst e)
{
  std::string query ="update kunden set ";
  for(B_UPDATE_BITS_SONST i=B_UPDATE_BITS_SONST(0);i<B_MaxAnzS;++i)
   {
     if(!(e&(1<<i))) continue;
     if      (i==B_Rechnungan ) query += "rechnung_an  = "+itos(Rngan())+",";
     else if (i==B_Extartbezid) query += "extartbezid = "+itos(getSchemaId())+",";
     else if (i==B_Preisliste ) query += "preisliste  = "+itos(preisliste())+","; 
     else if (i==B_Notiz      ) query += "notiz  = '"+notiz()+"',";
     else if (i==B_Entsorgung ) query += "entsorgung  = "+btos(entsorgung())+",";
     else if (i==B_Verknr     ) query += "verknr  = "+itos(verkaeufer.verknr)+",";
//     else if (i==B_Kalkulation) query += "kalkulation  = "+itos(kalkulation())+",";
   }
 query += "stand  = now() where kundennr = "+itos(Id());
 Query::Execute(query);
 SQLerror::test(__FILELINE__);
} 

const list<PreisListe::ID> Kunde::Sonderpreislisten() const
{
  exec sql begin declare section;
   int P;
   char query[1024];
  exec sql end declare section;
  Transaction tr;
  list<PreisListe::ID> V;
  int i=1;
  while (true)
   {
     std::string squery="select sonder_pliste["+itos(i)+"] from kunden"
         " where kundennr="+itos(Id());        
     strncpy(query,squery.c_str(),sizeof(query));
     exec sql prepare preiscursor_ from :query;
     exec sql declare preiscursor cursor for preiscursor_;
     exec sql open preiscursor;
     SQLerror::test(__FILELINE__);
     exec sql fetch preiscursor into :P;
     SQLerror::test(__FILELINE__,-209);
     if(sqlca.sqlcode) break;
     V.push_back(P);
     ++i;
   }
 return V;
}

void Kunde::setSonderpreisliste(const std::list<PreisListe::ID>& VP) const
{
  std::string query="update kunden set sonder_pliste='{";
  for(std::list<PreisListe::ID>::const_iterator i=VP.begin();i!=VP.end();)
   {
     query +=itos(*i);
     ++i;
     if(i!=VP.end()) query += ",";
   }
  query +="}' where kundennr="+itos(Id());
  Query::Execute(query);  
  SQLerror::test(__FILELINE__);
}

void Kunde::newKontaktperson(const cH_Person &Person) const
{
  std::string query="insert into ku_ansprech (kundennr,persnr) "
      "values ("+itos(Id())+","+itos(Person->Id())+")";
  Query::Execute(query);  
  SQLerror::test(__FILELINE__);
}

void Kunde::updateKontaktperson(const st_ansprech &A) const
{
  std::string query="update ku_ansprech set _position='"+A.position
      +"', notiz='"+A.notiz+"' "
      " where (kundennr,persnr) = ("+itos(Id())+","+itos(A.Person->Id())+")";
  Query::Execute(query);  
  SQLerror::test(__FILELINE__);
}

void Kunde::deleteKontaktperson(const H_Kunde&K,const cH_Person &P)
{
  std::string query="delete from ku_ansprech  "
      " where (kundennr,persnr) = ("+itos(K->Id())+","+itos(P->Id())+")";
  Query::Execute(query);  
  SQLerror::test(__FILELINE__);
}




