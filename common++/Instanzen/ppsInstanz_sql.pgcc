/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 2002 Adolf Petig GmbH & Co. KG
 *  written by Jacek Jakubowski, Christof Petig, Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "ppsInstanz.h"
#include <Aux/SQLerror.h>
#include <Aux/Transaction.h>
exec sql include sqlca;


void ppsInstanz::get_name()
{
 if(instid == ppsInstanzID::None) return;
 try{

 exec sql begin declare section;
   char db_name[50];
   int db_nr=instid,db_lager_fuer,db_sortierung,db_produktionsdauer_tage;
   int IN;
   int db_einlagern_in;
   bool db_liefer,db_produziert_selbst,db_automatisch_einlagern;
   char db_lagername[50];
   char db_typ;
 exec sql end declare section;
 IN=ppsInstanzID::None;
 exec sql select name,coalesce(lager_fuer,:IN),sortierung ,
      coalesce(lieferschein,'f'),coalesce(produziert_selbst,'f'),
      coalesce(lagername,''),coalesce(prod_dauer_tage,0),
      coalesce(einlagern_in,:IN),coalesce(automatisch_einlagern,'f'),
      typ
      into :db_name,:db_lager_fuer,:db_sortierung ,:db_liefer,
      :db_produziert_selbst,:db_lagername,:db_produktionsdauer_tage,
      :db_einlagern_in,:db_automatisch_einlagern,:db_typ
      from prod_instanz where insid= :db_nr;
 SQLerror::test(__FILELINE__);
// if(sqlca.sqlcode) *db_name=0;

//cout << instid<< ' ' <<db_name<<' '<<db_lager_fuer<<' '
//<<db_sortierung<<' '<<db_liefer<<' '<<db_lagername<<'\n';
 name=db_name;
 lager_fuer=ID(db_lager_fuer);
 sortierung=db_sortierung;
 lieferschein=db_liefer;
 produziert_selbst=db_produziert_selbst;
 lagername=db_lagername;
 produktionsdauer_tage=db_produktionsdauer_tage;
 einlagern_in=ID(db_einlagern_in);
 automatisch_einlagern=db_automatisch_einlagern;
 typ=db_typ;

 assert(typ=='L' || typ=='P' || typ=='E');
/*  
  exec sql select insid into :db_best_fuer from prod_instanz 
         where lager_fuer=:db_nr;
  SQLerror::test(__FILELINE__,100);
  if(sqlca.sqlcode) bestellung_fuer=ppsInstanzID::None;
  else              bestellung_fuer=ID(db_best_fuer);
*/
 }catch(SQLerror &e) {std::cerr<<e<<'\n'; exit(1);}
}


std::vector<cH_ppsInstanz> cH_ppsInstanz::get_all_instanz()
{
 std::vector<cH_ppsInstanz> v;
 try{
  exec sql begin declare section;
    int db_i;
  exec sql end declare section;
  exec sql declare ins_ein cursor for select insid from 
      prod_instanz order by sortierung;
  Transaction tr;
  exec sql open ins_ein;
  SQLerror::test(__FILELINE__);
  while (true)
   {
     exec sql fetch ins_ein into :db_i;
     SQLerror::test(__FILELINE__,100);
     if (sqlca.sqlcode) break;
     v.push_back(cH_ppsInstanz(ppsInstanz::ID(db_i)));
   }
 }catch(SQLerror &e){std::cerr << e<<'\n';}
 return v;
}

