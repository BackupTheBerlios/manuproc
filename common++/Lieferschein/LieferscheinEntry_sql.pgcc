/* $Id: LieferscheinEntry_sql.pgcc,v 1.23 2002/10/24 14:08:59 thoma Exp $ */
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include"LieferscheinEntry.h"
#include"Lieferschein.h"
#include<Aux/Transaction.h>
#include <Auftrag/AufEintragBase.h>
#include<Auftrag/auftrag_status.h>
#include <unistd.h>
//#include <Instanzen/Produziert.h>
#include <Instanzen/ppsInstanzProduziert.h>
#include<Aux/FetchIStream.h>
#include <Aux/FetchIStream_fixedpoint.h>
exec sql include sqlca;


FetchIStream& operator>>(FetchIStream& is,LieferscheinEntry& z)
{
 is >> z.artikel >> z.zeilennr >> z.stueck>> z.menge >> z.palette >> z.yourauftrag 
     >> z.zusatzinfo >> z.refauftrag ;

 if(!z.zusatzinfo) return is;
 std::string zquery="select instanz,coalesce(auftragid,"+itos(AuftragBase::none_id)+")"
   ",coalesce(auftragznr,"+itos(AufEintragBase::none_znr)+"),menge "
   " from lieferscheinentryzusatz where (instanz,lfrsid,lfsznr) = ("
   +itos(z.Instanz()->Id())+","+itos(z.Id())+","+itos(z.Zeile())+")";
 Query(zquery).FetchArray(z.VZusatz);
 return is;  
}

FetchIStream& operator>>(FetchIStream& is,LieferscheinEntry::st_zusatz& z)
{
  return is >> z.aeb >> z.menge;
}



LieferscheinEntry::LieferscheinEntry(const LieferscheinEntryBase &lsbase)
 throw(SQLerror) : LieferscheinEntryBase(lsbase) 
{
 std::string qstr =
  "select ly.artikelid, ly.zeile, coalesce(ly.stueck,0), "
  " coalesce(ly.menge,0), coalesce(ly.palette,0), coalesce(youraufnr,''),"
  " coalesce(ly.zusatzinfo,'f'), ly.instanz, "
  " coalesce(ly.refauftragid,"+itos(ManuProcEntity<>::none_id)+"),"
  " coalesce(ly.refzeilennr,"+itos(ManuProcEintrag::none_znr)+")"
  " from lieferscheinentry ly "
  " left join auftrag a on (ly.refauftragid,ly.instanz) = (a.auftragid,a.instanz)"
  " where (ly.instanz,ly.lfrsid,ly.zeile) = ("
   +itos(Instanz()->Id())+","+itos(Id())+","+itos(Zeile())+")"; 

 Query(qstr).FetchOne(*this);

}

LieferscheinEntry::LieferscheinEntry(const LieferscheinBase &lsb,
	const AufEintragBase &auf, const ArtikelBase &art, int anzahl,
	mengen_t _menge,int _palette, bool _zusatzinfo)
throw(SQLerror) : LieferscheinEntryBase(lsb),artikel(art),
			refauftrag(auf),stueck(anzahl),menge(_menge),
			palette(_palette), zusatzinfo(_zusatzinfo)
{
 exec sql begin declare section;
 int INSTANZ=Instanz()->Id();
 int LFRSID=Id();
 int ARTIKELID=artikel.Id();
 int REFAUFID=refauftrag.Id();
 int REFZEILENNR=refauftrag.ZNr();
 int STK=stueck;
 int ZEILE;
 float MENGE=menge;
 int PALETTE=palette;
 bool ZUSATZINFO=zusatzinfo;
 exec sql end declare section;

 Transaction tr;
 
 exec sql lock table lieferscheinentry in exclusive mode;
 SQLerror::test(__FILELINE__":LieferscheinEntry: lock table");
 
 exec sql select coalesce(max(zeile)+1,1) into :ZEILE from lieferscheinentry
	where (instanz,lfrsid)=(:INSTANZ,:LFRSID) ;
 SQLerror::test(__FILELINE__":LieferscheinEntry: select max(zeilennr)");

 exec sql insert into lieferscheinentry 
 		(instanz,lfrsid,zeile,artikelid, refauftragid, refzeilennr, stueck,
		menge,palette,zusatzinfo)
 	values
 		(:INSTANZ,:LFRSID,:ZEILE,:ARTIKELID,nullif(:REFAUFID,0),
 		 nullif(:REFZEILENNR,0),:STK,nullif(:MENGE,0),:PALETTE,:ZUSATZINFO);
 SQLerror::test(__FILELINE__":LieferscheinEntry: insert into lieferscheinentry");

 zeilennr=ZEILE;
 
 tr.commit();
}


LieferscheinEntry::LieferscheinEntry(const LieferscheinBase &lsb,
			const ArtikelBase &art, int anzahl,
			mengen_t _menge,int _palette, bool zusatz)
							throw(SQLerror) 
{  *this=LieferscheinEntry(lsb,AufEintragBase(Instanz(),0,0),art,anzahl,_menge,_palette,zusatz);
}

void LieferscheinEntry::deleteEntry(const LieferscheinEntry &lse) throw(SQLerror)
{
 exec sql begin declare section;
  int INSTANZ=lse.Instanz()->Id();
  int LFRSID=lse.Id();
  int ZEILE=lse.Zeile();
 exec sql end declare section;

 Transaction tr;

 exec sql lock table lieferscheinentry in exclusive mode;
 
 exec sql delete from lieferscheinentry where
		(instanz,lfrsid,zeile) = (:INSTANZ,:LFRSID,:ZEILE);
 SQLerror::test(__FILELINE__":deleteEntry: delete from lieferscheinentry");
 
 if (lse.RefAuftrag().Id()!=AuftragBase::none_id 
 	|| lse.AufZeile()!=AufEintragBase::none_znr)
 {  AuftragBase::mengen_t geliefert=lse.Anzahl();
    if (lse.Menge()) geliefert *= lse.Menge();
    AufEintrag AE(lse.getAufEintragBase());

    AE.Produziert(-geliefert,LFRSID);
 }

 tr.commit();
}
