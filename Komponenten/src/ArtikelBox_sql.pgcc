/*  libKomponenten: GUI components for ManuProC's libcommon++
 *  Copyright (C) 1998-2001 Adolf Petig GmbH & Co. KG
 *			 written by Christof Petig and Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <ManuProCConfig.h>
#include "ArtikelBox.hh"
#include <Aux/itos.h>
#include <algorithm>
#include <unistd.h>
#include <Aux/FetchIStream.h>
#if (defined PETIG_EXTENSIONS) || (defined MABELLA_EXTENSIONS) 
#include <Instanzen/ppsInstanz.h>
#include <Artikel/Prozess.h>
#endif
#ifdef MABELLA_EXTENSIONS
#include <Aux/EAN.h>
#endif
#include <Aux/Global_Settings.h>

exec sql include sqlca;

void ArtikelBox::searchFunc(int *cont, GtkSCContext newsearch, unsigned int sp,unsigned int l) throw(SQLerror)
{std::vector<cH_EntryValue> v=get_content(l,sp);
 active_sc=combos[l][sp];

 try
 {switch(newsearch)
  { case GTK_SEARCH_OPEN: 
    { pixmap_setzen(false);
      artikel=ArtikelBase();
 exec sql begin declare section;
   char *QUERY;
 exec sql end declare section;
 std::string table=Tabellenname(schema) + " as artboxtable";
 std::string what;
// std::string combocontent=combos[l][sp]->get_text();
 std::string constraint;
 std::string squery; 

 {vector<cH_EntryValue>::const_iterator vi=v.begin();
  for (ExtBezSchema::const_sigiterator i=schema->sigbegin(signifikanz[l]);
 		i!=schema->sigend(signifikanz[l]);++i,++vi)
  { if (vi+1==v.end())
    {  if (!kombiniertbool) what = i->spaltenname;
       constraint += "text("+i->spaltenname +") like '"+(*vi)->getStrVal()+"\%'";
       break;
    }
    else 
       constraint += "text("+i->spaltenname +")='"+(*vi)->getStrVal()+"' AND ";
  }
 }
  if (kombiniertbool)
  {  ExtBezSchema::const_sigiterator i=schema->sigbegin(signifikanz[l]);
     assert(i!=schema->sigend(signifikanz[l]));
     what=i->spaltenname;
     for (++i;i!=schema->sigend(signifikanz[l]);++i)
     {  what+=","+i->spaltenname;
     }
  }

 squery = "SELECT DISTINCT "+what+" FROM "+table ;
 if (eingeschraenkt && !joinstring.empty()) squery += joinstring;
 if (!constraint.empty()) squery += " WHERE "+constraint;
 if (eingeschraenkt && !einschraenkung.empty())
 	squery += (!constraint.empty()?" AND ":" WHERE ") + einschraenkung;
 
    (const char*)QUERY=squery.c_str();
    tr.open();
    exec sql prepare QUERY from :QUERY;
    exec sql declare extbezfeld cursor for QUERY;
    exec sql open extbezfeld;
    SQLerror::test("ArtikelBox::searchFunc: select text",100);
    if(sqlca.sqlcode==100) return;
    }
    // fall through
    
case GTK_SEARCH_FETCH:   
 {if (BreitenSuche(GTK_SEARCH_FETCH,sp,l,cont)) return;
 
   exec sql allocate descriptor spalten;
   exec sql fetch extbezfeld into sql descriptor spalten;
   SQLerror::test(__FILELINE__,100);
   if (sqlca.sqlcode==100)
   {  if (newsearch==GTK_SEARCH_OPEN && artikel_automatisch_finden 
   		&& !automatisch_anlegen_bool 
   		&& (l || !combos[l][sp]->get_text().empty()))
      {  if (BreitenSuche(GTK_SEARCH_OPEN,sp,l,cont)) return;
      }
   }
   else
  {FetchIStream is("spalten");
   if (!kombiniertbool)
   {  std::string t;
      is >> FetchIStream::MapNull<string>(t,"");
      combos[l][sp]->add_item(t);
   }
   else
   {  std::vector<std::string> sv;
      try
      {  std::string t;
         for (;;)
         {  is >> FetchIStream::MapNull<string>(t,"");
            sv.push_back(t);
         }
      } catch (SQLerror &e) {} // Endemarkierung
      combos[l][sp]->add_item(Kombinieren(schema,signifikanz[l],sv));
   }
   exec sql deallocate descriptor spalten;
   SQLerror::test("ArtikelBox::searchFunc: fetch resulttable");
   *cont=true;
  }
 }
 break;
 
case GTK_SEARCH_CLOSE:
 exec sql close extbezfeld;
 tr.commit();
 BreitenSuche(GTK_SEARCH_CLOSE);
 break;
  }
 } catch (SQLerror &e)
  {  //std::cerr << e << '\n';
  }
}

void ArtikelBox::fuelleMenu()
{  
   exec sql begin declare section;
     int eab_id,db_artikeltyp;
   unsigned int id[20];
   char bez[20][41];
   exec sql end declare section;
   eab_id=schema->Id();
   bool typ_ok=false;
   int neuerTyp=0;
   
   // Hauptmenü
   if (menu)
   {  menu->destroy();
      menu=0;
   }
   menu=new Gtk::Menu();

   Gtk::Menu *typ_menu = manage(new class Gtk::Menu());
   Gtk::MenuItem *typ = manage(new class Gtk::MenuItem("Typ (Warengruppe)"));
   typ->set_submenu(*typ_menu);
   Gtk::Menu *schema_menu = manage(new class Gtk::Menu());
   Gtk::MenuItem *schema_mi = manage(new class Gtk::MenuItem("Schema (Kundengruppe)"));
   schema_mi->set_submenu(*schema_menu);
   Gtk::Menu *anzeige_menu = manage(new class Gtk::Menu());
   Gtk::MenuItem *anzeige = manage(new class Gtk::MenuItem("Anzeige"));
   anzeige->set_submenu(*anzeige_menu);
   Gtk::Menu *optionen_menu = manage(new class Gtk::Menu());
   Gtk::MenuItem *optionen = manage(new class Gtk::MenuItem("Optionen"));
   optionen->set_submenu(*optionen_menu);
   Gtk::MenuItem *neu = manage(new class Gtk::MenuItem("Neuen Eintrag anlegen"));
   neu->activate.connect(SigC::slot(this,&ArtikelBox::Neuer_Eintrag));
   Gtk::CheckMenuItem *autoneu = manage(new class Gtk::CheckMenuItem("Neue Einträge automatisch anlegen"));
   autoneu->set_active(automatisch_anlegen_bool);
   autoneu->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::Neuer_Eintrag_automatisch),autoneu));

   Gtk::CheckMenuItem *allesanzeigen=manage(new class Gtk::CheckMenuItem("Alle Artikel anzeigen"));
   allesanzeigen->set_active(alle_artikel_anzeigen_bool);
   allesanzeigen->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::AlleArtikelAnzeigen),allesanzeigen));
   Gtk::CheckMenuItem *allesanzeigenid=manage(new class Gtk::CheckMenuItem("ID anzeigen"));
   allesanzeigenid->set_active(alle_artikel_anzeigen_mit_id_bool);
   allesanzeigenid->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::AlleArtikelAnzeigenId),allesanzeigenid));

   menu->append(*typ);   
   menu->append(*schema_mi);   
   menu->append(*anzeige);   
   menu->append(*optionen);   
   menu->append(*neu);
   menu->append(*autoneu);
   menu->append(*allesanzeigen);
   menu->append(*allesanzeigenid);

   // Einträge für den Menüeintrag 'Typ'
   exec sql select DISTINCT e.artikeltyp, w.text into :id, :bez
        from extbezschema e, artbez_warengruppe w where w.id 
         = e.artikeltyp AND extartbezid= :eab_id limit 20;
   if (!sqlca.sqlcode)
   {  for (int i=0;i<sqlca.sqlerrd[2];++i)
      {  std::string entr;
         if (id[i]==schema->Typ()) entr += "*";
         else entr += " ";
         entr += bez[i];
         Gtk::MenuItem *mi=manage(new Gtk::MenuItem(entr)); 
         typ_menu->append(*mi);
//         mi->show();
         mi->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::setzeSchemaId),id[i]));

   	 if (!typ_ok)
	     { if (schema->Typ()==ArtikelTyp::ID(id[i])) typ_ok=true;
	       else if (!i) neuerTyp=id[i];
     	  }
       }
   }
   // Auch die Warengruppen anzeigen, die für diesen Typ eigentlich 
   // nicht vorgesehen sind sondern nur intern vorhanden sind (eingeklammert)
   exec sql select DISTINCT e.artikeltyp, w.text into :id, :bez
        from extbezschema e, artbez_warengruppe w where w.id 
         = e.artikeltyp AND extartbezid=1 and e.artikeltyp not in
         (select DISTINCT ee.artikeltyp from extbezschema ee where
            extartbezid=:eab_id ) limit 20;
   if (!sqlca.sqlcode)
   {  for (int i=0;i<sqlca.sqlerrd[2];++i)
      {  std::string entr;
         if (id[i]==schema->Typ()) entr += "*(";
         else entr += " (";
         entr += bez[i] ;
         entr += ")";
         Gtk::MenuItem *mi=manage(new Gtk::MenuItem(entr)); 
         typ_menu->append(*mi);
//         mi->show();
         mi->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::setzeSchemaId),id[i]));
       }
   }
   if (!typ_ok)
   // Dieser Typ ist für diesen Kunden nicht vorhanden,
   // nehmen wir den ersten anderen.
   {  static bool block=false;
      if (block) return;
      block=true; // never recurse here
      setExtBezSchema(cH_ExtBezSchema(schema->Id(),neuerTyp));
      block=false;
      return;
   }

   // Einträge für den Menüeintrag 'Typ (Kundengruppe)'
   db_artikeltyp=schema->Typ();
   exec sql select DISTINCT e.extartbezid, k.firma into :id, :bez
        from extbezschema e join kunden k on (e.extartbezid=k.kundennr) 
        where e.artikeltyp = :db_artikeltyp
         limit 20;
   if (!sqlca.sqlcode)
   {  for (int i=0;i<sqlca.sqlerrd[2];++i)
      {  std::string entr;
         if (id[i]==schema->Id()) entr += "*";
         else entr += " ";
         entr += bez[i];
         Gtk::MenuItem *mi=manage(new Gtk::MenuItem(entr)); 
         schema_menu->append(*mi);
//         mi->show();
         mi->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::setzeSchemaTyp),id[i]));
       }
   }
   // Für neue Kundengruppe immer erste Warengruppe setzen:
//   setExtBezSchema(cH_ExtBezSchema(schema->Id(),neuerTyp));

   // Einträge für den Menüeintrag 'Anzeige'
   exec sql begin declare section;
      int db_atyp, db_sigV[20];
   exec sql end declare section;
   db_atyp=schema->Typ();
   exec sql select distinct signifikanz into :db_sigV 
      from extbezschema where artikeltyp = :db_atyp 
      and extartbezid = :eab_id limit 20;
   SQLerror::test(__FILELINE__);
   if (!sqlca.sqlcode)
   {  
     int sanz = sqlca.sqlerrd[2];
     for (int i=0;i<sanz;++i)
      {
       std::string text = kombinierterName(schema,db_sigV[i]);
       Gtk::CheckMenuItem *mi=manage(new Gtk::CheckMenuItem(text));
       anzeige_menu->append(*mi);
       if (find(signifikanz.begin(),signifikanz.end(),db_sigV[i])!= signifikanz.end()) mi->set_active(true);
       mi->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::setzeSignifikanz),db_sigV[i]));
//       mi->show();
      }
   }

   // Einträge für den Menüeintrag 'Optionen'
      Gtk::CheckMenuItem *autocomplete = manage(new class Gtk::CheckMenuItem("Automatisches Ergänzen"));      
      Gtk::CheckMenuItem *kombiniert = manage(new class Gtk::CheckMenuItem("Kombiniert"));      
      Gtk::CheckMenuItem *vertikal = manage(new class Gtk::CheckMenuItem("Vertikal anordnen"));      
      label = manage(new class Gtk::CheckMenuItem("Label anzeigen"));      
      Gtk::CheckMenuItem *einschr_mi = manage(new class Gtk::CheckMenuItem("Suche einschränken"));
      optionen_menu->append(*autocomplete);
      optionen_menu->append(*kombiniert);
      optionen_menu->append(*vertikal);
      optionen_menu->append(*label);
      optionen_menu->append(*einschr_mi);
//      autocomplete->show();
//      kombiniert->show();
//      vertikal->show();
//      label->show();
//      if (einschraenkung.size()) einschr_mi->show();

      if(autocompletebool) autocomplete->set_active(true);
      autocomplete->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::Autocomplete),autocomplete));
      if (kombiniertbool) kombiniert->set_active(true);
      kombiniert->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::kombiniert),kombiniert));
      if (vertikalbool) vertikal->set_active(true);
      vertikal->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::set_Vertikal),vertikal));
      if (labelbool) {label->set_active(true); show_label(true);}
      label->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::set_Label),label));
      if (eingeschraenkt) einschr_mi->set_active(true);
      einschr_mi->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::einschraenken_cb), einschr_mi));
   

   for (user_menus_t::const_iterator i=user_menus.begin();i!=user_menus.end();++i)
   {  Gtk::MenuItem *mi=manage(new Gtk::MenuItem(i->first));
      menu->append(*mi);
//      mi->show();
      mi->activate.connect(SigC::bind(MenueAusgewaehlt.slot(),i->second));
   }
 if(!alle_artikel_anzeigen_bool)
  {
    menu->show_all();
    allesanzeigenid->hide();
  }
 else 
   {
     allesanzeigen->show();
     allesanzeigenid->show();      
   }
 if (!neuanlegen()) neu->hide();
 if (!einschraenkung.size()) einschr_mi->hide();
// Wenn die Searchfunktionen fertig sind die folgende Zeile auskommentieren:
allesanzeigen->hide();
}

bool ArtikelBox::neuanlegen()
{
 exec sql begin declare section;
   bool B;
   char TABELLE[20];
 exec sql end declare section;
 std::string table=Tabellenname(schema);
 strncpy(TABELLE,table.c_str(),sizeof(TABELLE));
 exec sql select true into :B from artbez_insert where tabelle =:TABELLE; 
 SQLerror::test(__FILELINE__,100);
 if (sqlca.sqlcode) B=false;
 return B;
}

void ArtikelBox::Benutzerprofil_laden()
{ ArtikelBoxAnzeige anz=ArtikelBoxAnzeige::Laden(schema);
  signifikanz.clear();
  for (int i=-int(sizeof(int))*8;i<=int(sizeof(int))*8;++i)
     if (anz.Sichtbar(i)) signifikanz.push_back(i);
  autocompletebool=anz.AutoComplete();
  set_autoexpand(autocompletebool);
  kombiniertbool=anz.Kombiniert();
}

void ArtikelBox::Benutzerprofil_speichern()
{ 
  ArtikelBoxAnzeige anz(schema);
  for(std::vector<int>::const_iterator i=signifikanz.begin();i!=signifikanz.end();++i)
     anz.Sichtbar(*i,true);
  anz.AutoComplete(autocompletebool);
  anz.Kombiniert(kombiniertbool);
  anz.Speichern();
}

void ArtikelBox::Neuer_Eintrag()
{
// if(kombiniertbool) return;
 try {
// hier (und weiter unten) sollte man irgendwann mal 'ID' und 'EAN-Code' in die 
// Tabellenspalten der jeweiligen Schemata umwandeln.
// Dazu brauchte man dann wohl ein get_[id|ean]_spaltenname()
// in ExtBezSchema, oder?
 /* testen ob ID oder EAN eingetragen => FEHLER */
 // sollte wohl eher angezeigt werden CP
 for (unsigned int j=0;j<combos.size();++j)
  for (unsigned int i=0; i<combos[j].size(); ++i)
   { 
     if (labels[j][i]->get_text()=="ID" && combos[j][i]->get_text() !="")
      { std::cerr<<"FEHLER: ID darf nicht vorgegeben werden: Feld freilassen\n";
        return;
      }
     if (labels[j][i]->get_text()=="EAN-Code" && combos[j][i]->get_text() !="")
      { std::cerr<<"FEHLER: EAN darf nicht vorgegeben werden: Feld freilassen\n";
        return;
      }
   }
  /* testen, ob Artikel schon existiert */
  if(artikel_exist(false)!=ArtikelBase::none_id) 
    {
      std::cerr<<"FEHLER: Artikel existiert schon\n";
      return; 
    }
  exec sql begin declare section;
   int db_id,db_id_jumbo;
  exec sql end declare section;

  exec sql select nextval ('artikelbezeichnun_artikelid_seq') into :db_id;
  std::string where, what;
  where = "(id," ;
  what  = "("+itos(db_id)+",";
#ifdef MABELLA_EXTENSIONS  
  if(schema->Id()==ExtBezSchema::default_id)
   {
     where +="ean,";
     what  += EAN::next_value()+",";
   }  
#endif
  where_what(where,what,false);
  Neuer_Eintrag_sql(db_id,where,what,
#if (defined PETIG_EXTENSIONS) 
  		ppsInstanzID::Rollerei
#else
		ppsInstanzID::None
#endif
  						);

#ifdef PETIG_EXTENSIONS  // Jumborollen anlegen ?
 {  ArtikelBase::ID jumbo_id=artikel_exist(true);
    if(!jumbo_id)
      {
        exec sql select nextval ('artikelbezeichnun_artikelid_seq') into :db_id_jumbo;
        SQLerror::test(__FILELINE__);
        jumbo_id=db_id_jumbo;      
        where = "(id," ;
        what  = "("+itos(db_id_jumbo)+",";
        where_what(where,what,true);
   
        Neuer_Eintrag_sql(db_id_jumbo,where,what,ppsInstanzID::Bandlager);
      }
    if (jumbo_id && db_id!=jumbo_id)
       insert_into_artikelzusammensetzung(db_id,jumbo_id,ProzessID::Rollen,get_menge_from_artikelbox());
  }
#endif

  artikel=db_id;
  pixmap_setzen(true);
  new_article_inserted(db_id);
  activate();
  }catch (SQLerror &e)   {  /*std::cerr << e << '\n';*/}
}


void ArtikelBox::Neuer_Eintrag_sql(int id, std::string where, std::string what,int bestellen_bei)
{
  exec sql begin declare section;
   int db_id=id, db_warengruppe,db_schema,db_bestellen_bei=bestellen_bei;   
   int db_uid;
  exec sql end declare section;

  db_uid=getuid();
  std::string table = Tabellenname(schema);
  Query::Execute("insert into "+table +" "+ where+" values "+what);
  SQLerror::test(__FILELINE__);

  // Eintrag in Artikelbezeichnung
  db_warengruppe= schema->Typ().Id();
  db_schema = schema->Id();
  exec sql insert into artikelstamm (id,warengruppe,defaultschema,bestellen_bei,uid)
     values (:db_id,:db_warengruppe,:db_schema,:db_bestellen_bei,:db_uid);
  SQLerror::test(__FILELINE__);
}

void ArtikelBox::where_what(std::string& where, std::string& what, bool jumbo)
{ unsigned int l=0; 
  for (std::vector<int>::const_iterator i=signifikanz.begin();
  		i!=signifikanz.end(); ++i,++l)
   { vector<cH_EntryValue> v=get_content(l);
     unsigned int spalte=0;   
     for(ExtBezSchema::const_sigiterator j=schema->sigbegin(signifikanz[l]);
     	   j!=schema->sigend(signifikanz[l]); ++spalte,++j)
      {  if (j->spaltenname!="id")
         {  where += j->spaltenname+",";
#ifdef PETIG_EXTENSIONS
            if (jumbo && j->spaltenname==schema->JumboSpalte())
               what += "'"+schema->JumboBez()+"'," ;
            else 
#endif
               what += "'"+v[spalte]->getStrVal()+"',";
         }
      }
   }
   if (!where.empty() && where[where.size()-1]==',') where[where.size()-1]=')';
   if (!what.empty() && what[what.size()-1]==',') what[what.size()-1]=')';
}

ArtikelBase::ID ArtikelBox::artikel_exist(bool jumbo) 
{ std::string table = Tabellenname(schema);
  std::string squery = "select id from "+table+" where ";
  std::string where = "(";
  std::string what = "(";
  where_what(where,what,jumbo);
  squery += where + '=' + what;
 
 exec sql begin declare section;
 char *query;
 int ID;
 exec sql end declare section;
 
 const_cast<const char *>(query)=squery.c_str();
 exec sql prepare jein from :query;
 exec sql execute jein into :ID;
 SQLerror::test(__FILELINE__,100);
 if (sqlca.sqlcode) return ArtikelBase::none_id;
 return ID;
}

void ArtikelBox::insert_into_artikelzusammensetzung(int id, int id_jumbo, int prozess,double menge)
{
 exec sql begin declare section;
   int db_id=id,db_id_jumbo=id_jumbo,db_prozess=prozess;
   double db_menge=menge;
   int db_uid=getuid();
 exec sql end declare section;
 exec sql insert into artikelzusammensetzung (id,prozessid,altartikelid,menge,uid)
    values (:db_id,:db_prozess,:db_id_jumbo,:db_menge,:db_uid);
 SQLerror::test(__FILELINE__);
}

ArtikelBoxAnzeige ArtikelBoxAnzeige::Laden(cH_ExtBezSchema schema)
{  ArtikelBoxAnzeige res=ArtikelBoxAnzeige(schema);

   std::string qual=itos(schema->Typ().Id())+"_"+itos(schema->Id());
   std::string val=Global_Settings(getuid(),"ArtikelBox",qual).get_Wert();
   if (!val.empty())
   {  res.autocomplete=val.find('a')!=std::string::npos;
         res.kombiniert=val.find('k')!=std::string::npos;
         std::string::size_type komma1=val.find(','),komma2=std::string::npos;
         if (komma1!=std::string::npos) komma2=val.find(',',komma1+1);
         if (komma2!=std::string::npos)
         {  res.anzeige_pos=strtol(val.substr(0,komma1).c_str(),0,10);
            res.anzeige_neg=strtol(val.substr(komma1+1,komma2-(komma1+1)).c_str(),0,10);
         }
   }
   return res;
}

void ArtikelBoxAnzeige::Speichern() const
{  std::string qual=itos(schema->Typ().Id())+"_"+itos(schema->Id());
   std::string val=itos(anzeige_pos)+','+itos(anzeige_neg)+','
   	+(autocomplete?"a":"")+(kombiniert?"k":"");
   Global_Settings::create(getuid(),"ArtikelBox",qual,val);
}

std::string ArtikelBox::Tabellenname(cH_ExtBezSchema s)
{  return "artbez_"+itos(s->Typ().Id())+"_"+itos(s->Id());
}
