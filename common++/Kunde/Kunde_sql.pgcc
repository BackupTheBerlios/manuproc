// $Id: Kunde_sql.pgcc,v 1.8 2001/12/04 08:42:11 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Christof Petig
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */


#include "Kunde/Kunde.h"
#include <Aux/Transaction.h>


Kunde::Kunde(ID _id) throw(SQLerror) 
: Kundennr(_id), schema(ExtBezSchema::default_id)
{  exec sql begin declare section;
   int ID=_id,BEZSCHEMA,BANKINDEX,RNG_AN,PREISLISTE;
   char SORTNAME[31], IDNR[21];
   char NAME[61], STRASSE[36], HSNR[8], POSTFACH[21],ORT[31],BANKNAME[31],
         PLZ[11],POSTFACHPLZ[11],KTONR[11],BLZ[11],POSTANWVOR[41],POSTANWNACH[41];
   char LKZ[4];
   int FLAECHE,MITARBEITER;
   double KUNDENUMSATZ,PLANUMSATZ,UMSATZ, RABATT,EINZUGRABATT;
   int SKONTOFRIST;
   char VEREIN[31];
   bool BANKEINZUG,LIEFERADRESSE,RECHUNGSADRESSE;
   char NOTIZ[2048];
   char STAND[50];
   exec sql end declare section;

   if(_id == Kunde::none_id) return;   
  
   Transaction tr;

///XXX STAND 'now' stimmt noch nicht MAT
   exec sql select firma,coalesce(sortname,''),coalesce(extartbezid,1),
	 coalesce(strasse,''),
    coalesce(postanwvor,''),coalesce(postanwnach,''),
         coalesce(hsnr,''),coalesce(plz,''),coalesce(postfach,''),
         coalesce(postfplz,''),coalesce(ort,''),coalesce(text(ktonr),''),
         coalesce(text(b.blz),''), coalesce(b.name,''), coalesce(b.bankindex,0),
         coalesce(rechnung_an,kundennr), coalesce(preisliste,kundennr), 
         coalesce(idnr,''),
         lieferadresse, rechnungsadresse, 
         coalesce(flaeche,0),coalesce(mitarbeiter,0),coalesce(kundenumsatz,0),
         coalesce(planumsatz,0),coalesce(umsatz,0),
         coalesce(rabatt,0),coalesce(einzugrabatt,0),coalesce(skontofrist,0),
         coalesce(verein,''),coalesce(bankeinzug,false), coalesce(notiz,''), 
         coalesce(stand,'now'),	coalesce(lkz,'')
   	into :NAME, :SORTNAME, :BEZSCHEMA, :STRASSE, :POSTANWVOR, :POSTANWNACH,
           :HSNR, :PLZ, :POSTFACH,
           :POSTFACHPLZ, :ORT, :KTONR, :BLZ, :BANKNAME, :BANKINDEX, :RNG_AN,
           :PREISLISTE, :IDNR,
            :LIEFERADRESSE,:RECHUNGSADRESSE,
           :FLAECHE,:MITARBEITER,:KUNDENUMSATZ,:PLANUMSATZ,:UMSATZ,
	   :RABATT,:EINZUGRABATT,:SKONTOFRIST,:VEREIN,:BANKEINZUG,
	   :NOTIZ,:STAND, :LKZ
   	from kunden k left join banken b using(bankindex)
   	where kundennr= :ID;

   SQLerror::test(__FILELINE__);

   schema=BEZSCHEMA;
   adresse.firma=NAME;
   adresse.sortname=SORTNAME;
   adresse.strasse=STRASSE;
   adresse.postanwvor=POSTANWVOR;
   adresse.postanwnach=POSTANWNACH;
   adresse.hsnr=HSNR;
   adresse.plz=PLZ;
   adresse.postfach=POSTFACH;
   adresse.postfachplz=POSTFACHPLZ;
   adresse.ort=ORT;
   adresse.lkz = LKZ;
   IDnr=IDNR;
   lieferadresse=LIEFERADRESSE;
   rechnungsadresse=RECHUNGSADRESSE;
   bankverb.konto=strtoll(KTONR,NULL,10);
   bankverb.blz=strtoul(BLZ,NULL,10);
   bankverb.bank=BANKNAME;
   bankverb.bankindex=BANKINDEX;
   rngan=RNG_AN;
   kundendaten.preisliste=PREISLISTE;

   kundendaten.flaeche = FLAECHE;
   kundendaten.mitarbeiter=MITARBEITER;
   kundendaten.kundenumsatz=KUNDENUMSATZ;
   kundendaten.planumsatz=PLANUMSATZ;
   kundendaten.umsatz=UMSATZ;
   kundendaten.rabatt=RABATT;
   kundendaten.einzugrabatt=EINZUGRABATT;
   kundendaten.skontofrist=SKONTOFRIST;
   kundendaten.verein=VEREIN;
   kundendaten.bankeinzug=BANKEINZUG;
   kundendaten.stand=STAND;
   kundendaten.notiz=NOTIZ;
}


void Kunde::update() throw(SQLerror)
{
 exec sql begin declare section;
 char 	*IDNR, *FIRMA, *POSTANWVOR, *STRASSE,
   	*POSTANWNACH, *HSNR, *PLZ, *POSTFACH, *POSTFPLZ,
        *ORT, 
        *SORTNAME;
 bool LIEFERADRESSE, RECHNUNGSADRESSE;
 unsigned int KUNDENNR, RECHNUNG_AN, SCHEMA;  
   int FLAECHE,MITARBEITER;
   double KUNDENUMSATZ,PLANUMSATZ,UMSATZ, RABATT,EINZUGRABATT;
   int SKONTOFRIST;
   int BANKINDEX;
   int IBANKINDEX=0;
   int PREISLISTE;
   char *VEREIN;
   bool BANKEINZUG;
   char *NOTIZ;
   char *STAND;
 long long int KTONR;
 exec sql end declare section;

 KTONR=bankverb.konto;
 KUNDENNR = Kundennr;
 SCHEMA = schema;
 SORTNAME=(char *) adresse.sortname.c_str();
 FIRMA=(char *)adresse.firma.c_str();
 POSTANWVOR=(char *)adresse.postanwvor.c_str();
 STRASSE=(char *)adresse.strasse.c_str();
 HSNR=(char *)adresse.hsnr.c_str();
 POSTANWNACH=(char *)adresse.postanwnach.c_str();
 PLZ=(char *)adresse.plz.c_str();
 ORT=(char *)adresse.ort.c_str();
 POSTFACH=(char *)adresse.postfach.c_str();
 POSTFPLZ=(char *)adresse.postfachplz.c_str();
 IDNR=(char *)IDnr.c_str();
 STAND=(char *)kundendaten.stand.c_str();
 PREISLISTE=kundendaten.preisliste;

 LIEFERADRESSE = lieferadresse;
 RECHNUNGSADRESSE = rechnungsadresse;
 RECHNUNG_AN = rngan;

 FLAECHE=kundendaten.flaeche;
 MITARBEITER=kundendaten.mitarbeiter;
 KUNDENUMSATZ=kundendaten.kundenumsatz;
 PLANUMSATZ=kundendaten.planumsatz;
 UMSATZ=kundendaten.umsatz;
 RABATT=kundendaten.rabatt;
 EINZUGRABATT=kundendaten.einzugrabatt;
 SKONTOFRIST=kundendaten.skontofrist;
 VEREIN=(char *)kundendaten.verein.c_str();
 BANKEINZUG=kundendaten.bankeinzug;
 BANKINDEX=bankverb.bankindex;
 NOTIZ=(char *)kundendaten.notiz.c_str();


 if (BANKINDEX==0) IBANKINDEX=-1;
 Transaction tr;

/*
 exec sql UPDATE kunden SET
        kundennr                =       :KUNDENNR,
        sortname                =       :SORTNAME,
        extartbezid             =       :SCHEMA,
        firma                   =       :FIRMA,   
        postanwvor              =       :POSTANWVOR,
        strasse                 =       :STRASSE,   
        hsnr                    =       :HSNR,      
        postanwnach             =       :POSTANWNACH,
        plz                     =       :PLZ,
        ort                     =       :ORT,
        postfach                =       :POSTFACH,
        postfplz                =       :POSTFPLZ,
        idnr                    =       :IDNR,
        lieferadresse           =       :LIEFERADRESSE,
        rechnungsadresse        =       :RECHNUNGSADRESSE,
        rechnung_an             =       :RECHNUNG_AN,
        flaeche                 =       :FLAECHE,
        mitarbeiter             =       :MITARBEITER,
        kundenumsatz            =       :KUNDENUMSATZ,
        planumsatz              =       :PLANUMSATZ,
        umsatz                  =       :UMSATZ,
        rabatt                  =       :RABATT,
        einzugrabatt            =       :EINZUGRABATT,
        preisliste              =       :PREISLISTE,
        skontofrist             =       :SKONTOFRIST,
        verein                  =       :VEREIN,
        bankeinzug              =       :BANKEINZUG,
        bankindex               =       :BANKINDEX:IBANKINDEX,
        ktonr                   =       :KTONR,
        notiz                   =       :NOTIZ
     WHERE kundennr = :KUNDENNR ;
     SQLerror::test(__FILELINE__);
*/
 tr.commit();

}


const cH_Kunde Kunde::newKunde(const Kunde::ID kid, const std::string &firma) throw(SQLerror)
{
 exec sql begin declare section;
 int KID=kid;
 char *FIRMA;
 exec sql end declare section;

 Transaction tr;

 FIRMA=(char*)firma.c_str();
 
 exec sql insert into kunden (kundennr, firma) values (:KID, :FIRMA);
 SQLerror::test(__FILELINE__);
 
 tr.commit();

 return cH_Kunde(KID);
 
}

void Kunde::delete_Kunde(const Kunde::ID kid) throw(SQLerror)
{
 exec sql begin declare section;
    int KID=kid;
 exec sql end declare section;

 exec sql delete from kunden where kundennr = :KID;
 SQLerror::test(__FILELINE__);
}

unsigned int Kunde::nextval()
{
 exec sql begin declare section;
   unsigned int KUNDENNR;
 exec sql end declare section;
 exec sql select nextval('kunden_seq') into :KUNDENNR;
 SQLerror::test(__FILELINE__);
 return KUNDENNR;
}

void Kunde::get_blz_from_bankindex(unsigned int bankindex)
{
 exec sql begin declare section;
   unsigned int BANKINDEX=bankindex;
   unsigned long int BLZ;   
 exec sql end declare section;
 exec sql select blz into :BLZ from banken where bankindex=:BANKINDEX;
 SQLerror::test(__FILELINE__);
 bankverb.blz=BLZ;
}


unsigned long int Kunde::neue_bank_anlegen(const std::string& name, unsigned long int blz)
{
 exec sql begin declare section;
   unsigned int BANKINDEX;
   char NAME[50];
   unsigned long int BLZ=blz;   
 exec sql end declare section;
 exec sql select nextval('banken_bankindex_seq') into :BANKINDEX;
 SQLerror::test(__FILELINE__);
 strncpy(NAME,name.c_str(),sizeof(NAME));
 exec sql insert into banken (bankindex,name,blz)
   values (:BANKINDEX,:NAME,:BLZ);
 SQLerror::test(__FILELINE__);
 return BANKINDEX;
}


void Kunde::update_Bankeinzug(bool be) throw(SQLerror)
{
 exec sql begin declare section;
 unsigned int KUNDENNR = Kundennr;
 bool BANKEINZUG = be;
 exec sql end declare section;

 Transaction tr;

 exec sql UPDATE kunden SET bankeinzug= :BANKEINZUG, stand= now()
	WHERE kundennr = :KUNDENNR ;
 SQLerror::test(__FILELINE__);

 reread_Stand();
 
 tr.commit();

}


void Kunde::reread_Stand() throw(SQLerror)
{
 exec sql begin declare section;
 unsigned int KUNDENNR = Kundennr;
 char STAND[20];
 exec sql end declare section;

 exec sql select stand into :STAND from kunden where kundennr = :KUNDENNR;
 SQLerror::test(__FILELINE__);
 
 kundendaten.stand = STAND; 

}
