/*  pps: ManuProC's production planning system
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "RohwarenLager.h"
#include <Artikel/ArtikelBase.h>
#include <Artikel/ArtikelBezeichnung.h>
#include <Misc/Datum.h>
#include <Misc/string0.h>
<<<<<<< /tmp/mt.TWIN9I
exec sql include sqlca;
=======
>>>>>>> /tmp/mt.CJI8VV
#include <Misc/SQLerror.h>
#include <Misc/Transaction.h>
#include <Misc/itos.h>
<<<<<<< /tmp/mt.TWIN9I
=======
#include <Misc/Query.h>
>>>>>>> /tmp/mt.CJI8VV
#include <unistd.h>
#include <Misc/relops.h>
#include <Misc/TraceNV.h>
<<<<<<< /tmp/mt.TWIN9I
=======
#include <Misc/Ausgabe_neu.h> // for uses UTF8
>>>>>>> /tmp/mt.CJI8VV

std::string RohwarenLager::st_rohlager::Menge_als_Text(Einheit const& e) const
{  std::string s;
   if (kartons) s+=itos(kartons)+" Kartons Ã  " + itos(kg_pro_karton)+ e.Bezeichnung()+" ";
   if (reste||reste_kg) s+=itos(reste) +" Reste="+ itos(reste_kg) + e.Bezeichnung();
   if (s.empty()) s="nichts";
   return s;
}

AuftragBase::mengen_t RohwarenLager::st_rohlager::Menge_fuer_Auftrag() const
{  return kartons*kg_pro_karton  + reste_kg;
}

bool RohwarenLager::RL_Entnahme(st_rohlager& rohlager,std::string &os,bool force,bool ist_leer,bool fuer_auftrag)
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,
  	NV("kartons",rohlager.kartons),NV("reste",rohlager.reste),
  	NV("artikel",rohlager.artikel.Id()),
  	NV("position",rohlager.position.SPosition()));
  Transaction tr;
<<<<<<< /tmp/mt.TWIN9I
  exec sql begin declare section;
   int KARTONS;
   int RESTE;
   int RESTE_KG;
   char POSITION[5];
   char DATUM[11];
   bool DUMMY;
  exec sql end declare section;
  strncpy0(POSITION,rohlager.position.SPosition().c_str(),sizeof(POSITION));
  rohlager.datum.write_postgres(DATUM,sizeof DATUM);

  exec sql select true into :DUMMY from rl_inhalt where position_= :POSITION;
  SQLerror::test(__FILELINE__,100);
  if (sqlca.sqlcode==100) // nichts drin
=======
   bool DUMMY=false;

  try 
  { Query("select true from rl_inhalt where position_=?") 
    << rohlager.position.SPosition()
    >> DUMMY;
  } catch (SQLerror &e) {}
  if (!DUMMY) // nichts drin
>>>>>>> /tmp/mt.CJI8VV
   {
     os+="An Position " +rohlager.position.SPosition()+" steht nichts mehr.";
     return false;
   }

  st_rohlager was_ist_drin = RL_Inhalt(rohlager.position);
  
  if(!force)
   {
     if(was_ist_drin.artikel!=rohlager.artikel)
      {
        os+="Auf "+rohlager.position.SPosition()+" steht "
           +cH_ArtikelBezeichnung(was_ist_drin.artikel)->Bezeichnung() 
           +" vom "+was_ist_drin.datum.c_str()
           +" ("+was_ist_drin.Menge_als_Text(Einheit(was_ist_drin.artikel))+")\n";
        return false;
      }
     if (ist_leer && (was_ist_drin.kartons!=rohlager.kartons ||
                     was_ist_drin.reste!=rohlager.reste ||
                      was_ist_drin.reste_kg!=rohlager.reste_kg))
     {
         os+="Info: Auf " + rohlager.position.SPosition()
            +" standen noch "+was_ist_drin.Menge_als_Text(Einheit(was_ist_drin.artikel))+'\n';
     }
     else if(!ist_leer && (was_ist_drin.kartons<rohlager.kartons ||
                     was_ist_drin.reste<rohlager.reste ||
                      was_ist_drin.reste_kg<rohlager.reste_kg))
     {  os+="Info: Auf "+rohlager.position.SPosition()
            +" standen nur noch "+was_ist_drin.Menge_als_Text(Einheit(was_ist_drin.artikel)) + '\n';
     }
    }
   else // force
       {
         os+="Info: Auf "+rohlager.position.SPosition() + " stand "
           +cH_ArtikelBezeichnung(was_ist_drin.artikel)->Bezeichnung() 
           +" vom "+was_ist_drin.datum.c_str()
           +" ("+was_ist_drin.Menge_als_Text(Einheit(was_ist_drin.artikel))+")\n";
       }

  std::string misc;
  if(ist_leer || force)
    {
<<<<<<< /tmp/mt.TWIN9I
      exec sql delete from rl_inhalt where position_= :POSITION;
      SQLerror::test(__FILELINE__);                  
      if(force) misc="lösc";
=======
      (Query("delete from rl_inhalt where position_=?")
        << rohlager.position.SPosition()).Check100();
      if(force) misc=(Ausgabe_neu::TeX_uses_UTF8 ? "lÃ¶sc" : "lösc");
>>>>>>> /tmp/mt.CJI8VV
      else misc="leer";
      rohlager=was_ist_drin;
    }  
  else 
    {
<<<<<<< /tmp/mt.TWIN9I
=======
       int KARTONS;
       int RESTE;
       int RESTE_KG;
>>>>>>> /tmp/mt.CJI8VV
      rohlager.kg_pro_karton=was_ist_drin.kg_pro_karton;
      KARTONS=was_ist_drin.kartons-rohlager.kartons;
      if (KARTONS<0) 
      { KARTONS=0; rohlager.kartons=was_ist_drin.kartons; }
      RESTE=was_ist_drin.reste-rohlager.reste;
      if (RESTE<0) 
      { RESTE=0; rohlager.reste=was_ist_drin.reste; }
      RESTE_KG=was_ist_drin.reste_kg-rohlager.reste_kg; ;   
      if (RESTE_KG<0) 
      { RESTE_KG=0; rohlager.reste_kg=was_ist_drin.reste_kg; }

<<<<<<< /tmp/mt.TWIN9I
      exec sql update rl_inhalt set kartons= :KARTONS, reste= :RESTE,
          rest_kg=:RESTE_KG, letzte_entnahme= :DATUM 
          where position_= :POSITION;
=======
      Query("update rl_inhalt set kartons=?, reste=?,"
          "rest_kg=?, letzte_entnahme=? where position_=?")
          << KARTONS << RESTE << RESTE_KG << rohlager.datum
          << rohlager.position.SPosition();
>>>>>>> /tmp/mt.CJI8VV
       SQLerror::test(__FILELINE__);                  
    }

   raus_aus_lager(rohlager.artikel,rohlager.Menge_fuer_Auftrag(),fuer_auftrag);
   RL_Log(rohlager,RLEntnehmen,misc);

   tr.commit();
   return true;
}

void RohwarenLager::RL_Einlagern_real(st_rohlager& rohlager,bool geliefert)
{  if (geliefert) rein_ins_lager(rohlager.artikel,rohlager.Menge_fuer_Auftrag(),true);
   else wiedereinlagern(rohlager.artikel,rohlager.Menge_fuer_Auftrag());
   RL_Log(rohlager,RLEinlagern);
}

bool RohwarenLager::RL_Einlagern(const LagerPlatz position,st_rohlager& rohlager,std::string &os,bool force,bool geliefert)
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,
  	NV("kartons",rohlager.kartons),NV("reste",rohlager.reste),
  	NV("artikel",rohlager.artikel.Id()),
  	NV("position",position.SPosition()));
  Transaction tr;
  rohlager.setPosition(position);

<<<<<<< /tmp/mt.TWIN9I
  exec sql begin declare section;
=======
>>>>>>> /tmp/mt.CJI8VV
   int KARTONS=rohlager.kartons;
   int KG_PER_KARTON=rohlager.kg_pro_karton;
   int RESTE=rohlager.reste;
   int RESTE_KG=rohlager.reste_kg;
   int MATERIAL=rohlager.artikel.Id();
<<<<<<< /tmp/mt.TWIN9I
   char POSITION[5];
   char DATUM[11];
   bool DUMMY;
  exec sql end declare section;
  strncpy0(POSITION,rohlager.position.SPosition().c_str(),sizeof(POSITION));
  rohlager.datum.write_postgres(DATUM,sizeof DATUM);

  exec sql select true into :DUMMY from rl_inhalt where position_= :POSITION;
  SQLerror::test(__FILELINE__,100);
  if (sqlca.sqlcode==100) // nichts drin also rein damit
=======
   bool DUMMY=false;

  try 
  { Query("select true from rl_inhalt where position_=?") 
      << rohlager.position.SPosition()
      >> DUMMY;
  } catch (SQLerror &e) {}
  if (!DUMMY) // nichts drin also rein damit
>>>>>>> /tmp/mt.CJI8VV
   {
<<<<<<< /tmp/mt.TWIN9I
      exec sql insert into rl_inhalt
        (position_, kartons, MATERIAL, KG_PER_KARTON,
              reste, rest_kg, eingelagert)
        values (:POSITION, :KARTONS, :MATERIAL, :KG_PER_KARTON,
              nullif(:RESTE,0), nullif(:RESTE_KG,0), :DATUM);
      SQLerror::test(__FILELINE__);
=======
      Query("insert into rl_inhalt (position_, kartons, MATERIAL, "
            "KG_PER_KARTON, reste, rest_kg, eingelagert) "
        "values (?,?,?,?,?,?,?)")
        << rohlager.position.SPosition()
        << KARTONS << MATERIAL << KG_PER_KARTON
        << Query::NullIf(RESTE) << Query::NullIf(RESTE_KG)
        << rohlager.datum;
>>>>>>> /tmp/mt.CJI8VV
      RL_Einlagern_real(rohlager,geliefert);
      tr.commit();
      return true;
   }
  else  // ups, auf dieser Position liegt schon etwas
   {
     st_rohlager was_ist_drin = RL_Inhalt(rohlager.position);
     if(force) // überschreiben, ohne Rücksicht auf Material
      { // wird nicht als Verbrauch gerechnet
        RL_Entnahme(was_ist_drin,os,true,true,false);
        if (!os.empty()) os+='\n';
        tr.close();
        tr.open(); // neue Transaktion beginnen
<<<<<<< /tmp/mt.TWIN9I
        exec sql update rl_inhalt set 
           kartons=:KARTONS, material=:MATERIAL, 
           kg_per_karton=:KG_PER_KARTON, reste=nullif(:RESTE,0), 
           rest_kg=nullif(:RESTE_KG,0), eingelagert=:DATUM where position_=:POSITION;
        SQLerror::test(__FILELINE__);
=======
        (Query("update rl_inhalt set "
                 "kartons=?, material=?, kg_per_karton=?, reste=?, "
                 "rest_kg=?, eingelagert=? where position_=?")
                  << KARTONS << MATERIAL << KG_PER_KARTON
                  << Query::NullIf(RESTE) << Query::NullIf(RESTE_KG)
                  << rohlager.datum << rohlager.position.SPosition()).Check100();
>>>>>>> /tmp/mt.CJI8VV
        RL_Einlagern_real(rohlager,geliefert);
        tr.commit();
        return true;
      }
     else // mal schauen ...
      {
        if(was_ist_drin.artikel==rohlager.artikel)
         {
           if (!was_ist_drin.kg_pro_karton) was_ist_drin.kg_pro_karton=rohlager.kg_pro_karton;
           if (!rohlager.kg_pro_karton) rohlager.kg_pro_karton=was_ist_drin.kg_pro_karton;
             // gleicher Artikel, gleiche PaketgrÃ¶Ãe also
             // neue Menge zu alter Menge hinzuaddieren und rein damit
           if (rohlager.kg_pro_karton==was_ist_drin.kg_pro_karton)
            {
              KARTONS = rohlager.kartons + was_ist_drin.kartons;
              KG_PER_KARTON=rohlager.kg_pro_karton;
              RESTE=rohlager.reste + was_ist_drin.reste;
              RESTE_KG=rohlager.reste_kg + was_ist_drin.reste_kg;    
<<<<<<< /tmp/mt.TWIN9I
              exec sql update rl_inhalt set 
                 kartons=:KARTONS, material=:MATERIAL,
                  kg_per_karton=:KG_PER_KARTON, 
                       reste=nullif(:RESTE,0), rest_kg=nullif(:RESTE_KG,0),
                        eingelagert=:DATUM where position_=:POSITION;
              SQLerror::test(__FILELINE__);
=======
              (Query("update rl_inhalt set "
                 "kartons=?, material=?, kg_per_karton=?, reste=?, "
                 "rest_kg=?, eingelagert=? where position_=?")
                  << KARTONS << MATERIAL << KG_PER_KARTON
                  << Query::NullIf(RESTE) << Query::NullIf(RESTE_KG)
                  << rohlager.datum << rohlager.position.SPosition()).Check100();
>>>>>>> /tmp/mt.CJI8VV
              RL_Einlagern_real(rohlager,geliefert);
              tr.commit();
              return true;
            }
           else 
            {
              os = "  an Position " + rohlager.position.SPosition() + " sollen "
                + itos(was_ist_drin.kg_pro_karton) + Einheit(was_ist_drin.artikel).Bezeichnung() +" "
                +  cH_ArtikelBezeichnung(was_ist_drin.artikel)->Bezeichnung()
                +  " im Karton sein.\n";
              return false;
            }
         }
        else // Die Materiaien stimmen nicht überein
         {
           os ="  an Position " +rohlager.position.SPosition()+" befindet sich "
            + cH_ArtikelBezeichnung(was_ist_drin.artikel)->Bezeichnung() + " vom "
            + was_ist_drin.datum.c_str() + " ("+itos(was_ist_drin.kartons)+"K.Ã  "
            + itos(was_ist_drin.kg_pro_karton)+ Einheit(was_ist_drin.artikel).Bezeichnung()+" " +itos(was_ist_drin.reste)+ "R.="
            + itos(was_ist_drin.reste_kg) + Einheit(was_ist_drin.artikel).Bezeichnung()+")\n";
           return false;
         }
      }  
   }
 assert(!" RohwarenLager::RL_Einlagern: Fehler");
}

void RohwarenLager::RL_Log(const st_rohlager& rohlager,RL_LogTyp typ,const std::string& misc)
{
<<<<<<< /tmp/mt.TWIN9I
  exec sql begin declare section;
   int KARTONS=rohlager.kartons;
   int KG_PER_KARTON=rohlager.kg_pro_karton;
   int RESTE=rohlager.reste;
   int RESTE_KG=rohlager.reste_kg;
   int MATERIAL=rohlager.artikel.Id();
   char MISC[5];
   char POSITION[5];
   char DATUM[11];
   char TYP=typ;
  exec sql end declare section;
  strncpy0(POSITION,rohlager.position.SPosition().c_str(),sizeof(POSITION));
  strncpy0(MISC,misc.c_str(),sizeof(MISC));

  rohlager.datum.write_postgres(DATUM,sizeof DATUM);
  exec sql insert into rl_log 
       (zeit,position_, kartons, MATERIAL, KG_PER_KARTON, typ, valuta, reste, rest_kg,misc)
       values (now(),:POSITION,:KARTONS,:MATERIAL,:KG_PER_KARTON,:TYP,:DATUM,
            :RESTE,:RESTE_KG,nullif(:MISC,''));
  SQLerror::test(__FILELINE__);
=======
  Query("insert into rl_log "
       "(zeit,position_, kartons, MATERIAL, KG_PER_KARTON, typ, valuta, reste, rest_kg,misc) "
       "values (now(),?,?,?,?,?,?,?,?,?)")
       << rohlager.position.SPosition() << rohlager.kartons
       << rohlager.artikel.Id() << rohlager.kg_pro_karton
       << char(typ) << rohlager.datum << rohlager.reste
       << rohlager.reste_kg << Query::NullIf(misc);
>>>>>>> /tmp/mt.CJI8VV
}


RohwarenLager::st_rohlager RohwarenLager::RL_Inhalt(const LagerPlatz position) const
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__);
<<<<<<< /tmp/mt.TWIN9I
  exec sql begin declare section;
=======
>>>>>>> /tmp/mt.CJI8VV
   int KARTONS, KG_PER_KARTON, RESTE, RESTE_KG, MATERIAL;
<<<<<<< /tmp/mt.TWIN9I
   char POSITION[5];
   char DATUM[11];
  exec sql end declare section;
  strncpy(POSITION,position.SPosition().c_str(),5);
  exec sql select coalesce(kartons,0), coalesce(reste,0),
      int4(coalesce(kg_per_karton,0)), int4(coalesce(rest_kg,0)),
      material, eingelagert into :KARTONS, :RESTE, 
            :KG_PER_KARTON, :RESTE_KG, :MATERIAL, :DATUM
      from rl_inhalt where position_= :POSITION;
  SQLerror::test(__FILELINE__,100);
  ManuProC::Datum date; 
  if(sqlca.sqlcode)
   {
     return st_rohlager(position,0,0,0,0, ArtikelBase(0),date);
   }
  else 
=======
   ManuProC::Datum DATUM;
  
  try
  { Query q("select kartons,reste,kg_per_karton,rest_kg,material, eingelagert "
      "from rl_inhalt where position_=?");
    q << position.SPosition();
    q >> Query::Row::MapNull(KARTONS) >> Query::Row::MapNull(RESTE) 
      >> Query::Row::MapNull(KG_PER_KARTON) >> Query::Row::MapNull(RESTE_KG)
      >> MATERIAL >> DATUM;
    return st_rohlager(position,KARTONS,KG_PER_KARTON,RESTE,RESTE_KG,
                  ArtikelBase(MATERIAL),DATUM);
  }
  catch (SQLerror &e)
>>>>>>> /tmp/mt.CJI8VV
   {
<<<<<<< /tmp/mt.TWIN9I
     date.from_postgres(DATUM);
     return st_rohlager(position,KARTONS,KG_PER_KARTON,RESTE,RESTE_KG,
                  ArtikelBase(MATERIAL),date);
=======
     return st_rohlager(position,0,0,0,0, ArtikelBase(),ManuProC::Datum());
>>>>>>> /tmp/mt.CJI8VV
   }
}  

std::vector<class LagerInhalt> RohwarenLager::LagerInhalt_(const ArtikelBase& artikel) const
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__);
<<<<<<< /tmp/mt.TWIN9I
  exec sql begin declare section;
=======
>>>>>>> /tmp/mt.CJI8VV
   int KG, RESTE_KG, MATERIAL,KARTONS,RESTKARTONS;
   char QUERY[1024];
<<<<<<< /tmp/mt.TWIN9I
  exec sql end declare section;
=======
>>>>>>> /tmp/mt.CJI8VV

<<<<<<< /tmp/mt.TWIN9I
  std::string squery ="select material,coalesce(kartons,0),coalesce(reste,0), "
      " coalesce(int4(sum(kartons*kg_per_karton)),0),"
      " coalesce(int4(sum(coalesce(rest_kg,0))),0) "
      " from rl_inhalt ";
  if(artikel.valid()) squery += " where material ="+itos(artikel.Id());
  squery +=" group by material,kartons,reste ";

  strncpy(QUERY,squery.c_str(),sizeof(QUERY));
  exec sql prepare r_summe_ from :QUERY;
  exec sql declare r_summe cursor for r_summe_;
=======
  std::string squery ="select material,kartons,reste, "
      "sum(kartons*kg_per_karton), sum(coalesce(rest_kg,0)) "
      "from rl_inhalt ";
  if(artikel.valid()) squery += "where material=? ";
  squery +="group by material,kartons,reste";

>>>>>>> /tmp/mt.CJI8VV
  Transaction tr;
<<<<<<< /tmp/mt.TWIN9I
  exec sql open r_summe;
  SQLerror::test(__FILELINE__);
=======
  Query q("r_summe",squery);
  if (artikel.valid()) q << artikel.Id();
  Query::Row is;
>>>>>>> /tmp/mt.CJI8VV
  std::vector<class LagerInhalt> V;
<<<<<<< /tmp/mt.TWIN9I
  while(true)
=======
  while((q>>is).good())
>>>>>>> /tmp/mt.CJI8VV
   {
<<<<<<< /tmp/mt.TWIN9I
     exec sql fetch r_summe into :MATERIAL,:KARTONS,:RESTKARTONS,:KG,:RESTE_KG;
     SQLerror::test(__FILELINE__,100);
     if(sqlca.sqlcode) break;
=======
     is >> MATERIAL >> Query::Row::MapNull(KARTONS) >> Query::Row::MapNull(RESTKARTONS)
        >> Query::Row::MapNull(KG) >> Query::Row::MapNull(RESTE_KG);
>>>>>>> /tmp/mt.CJI8VV
     V.push_back(::LagerInhalt(ArtikelBase(MATERIAL),KARTONS,RESTKARTONS,KG,RESTE_KG));
   }
 return V;
}
