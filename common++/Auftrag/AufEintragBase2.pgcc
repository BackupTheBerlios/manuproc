// $Id: AufEintragBase2.pgcc,v 1.20 2001/11/26 14:44:33 cvs_malte Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/AufEintragBase2.h>
#include "AufEintragBase.h"
#include <Aux/Transaction.h>
#include <Auftrag/auftrag_status.h>
#include <Auftrag/AuftragsBaum.h> 

exec sql include sqlca;

void AufEintragBase2::setVerarbeitung(const cH_Prozess p) const throw(SQLerror)
{
 assert (Instanz()==ppsInstanz::Kundenauftraege);
 exec sql begin declare section;
  int AUFTRAGID=Id();
  int INSTANZ=Instanz();
  int ZEILENNR=ZNr();
  int PROZESSID;
 exec sql end declare section;
 PROZESSID=p->getProzessID();
 
 Transaction tr;
 
 exec sql update auftrag_prozess set prozessid= :PROZESSID,
 	datum= now() where auftragid= :AUFTRAGID and zeilennr= :ZEILENNR ;
 SQLerror::test("Prozessaktualisierung",100);
 
 if((sqlca.sqlcode==100) || sqlca.sqlerrd[2]==0)
   {
    exec sql insert into auftrag_prozess 
      (auftragid,instanz,zeilennr,prozessid,datum)
      values
    	(:AUFTRAGID, :INSTANZ, :ZEILENNR, :PROZESSID, now());
    SQLerror::test("Prozessaktualisierung");
   }
 tr.commit();
}


bool AufEintragBase2::deleteAuftragEntry() const throw(SQLerror)
{
 // Kundenaufträge DÜRFEN NICHT gelöscht werden !!!
 assert (Instanz()!=ppsInstanz::INST_KNDAUF) ;

 // Testen, ob dieser Auftrag Kinder hat, wenn ja, dann darf dieser 
 // Auftrag NICHT gelöscht werden
 AuftragsBaum AB(*this,true);
 if(AB.size()!=0) return false;

 exec sql begin declare section;
 int AUFTRAGID=auftragid;
 int ZEILENNR=zeilennr;
 int INSTANZ=Instanz();
 exec sql end declare section;
 // Löschen aus Auftragszuordnung
 exec sql delete from auftragsentryzuordnung where neuauftragid=:AUFTRAGID
      and neuinstanz=:INSTANZ and neuzeilennr=:ZEILENNR;
 SQLerror::test(__FILELINE__+(string)" DELETE AUFTRAG 1");

 // Löschen aus Auftragentry
 exec sql delete from auftragentry where auftragid=:AUFTRAGID
      and zeilennr =:ZEILENNR and instanz=:INSTANZ;
 SQLerror::test(__FILELINE__+(string)" DELETE AUFTRAG 2");
 return true;
}

// gibt geliefert zurück
int AufEintragBase2::abschreiben(int menge) const throw(SQLerror)
{
 exec sql begin declare section;
 int AUFID=Id();
 int AUFZNR=ZNr();
 int INSTANZ=Instanz();
 int STATUS; 
 int BESTELLT;
 int GELIEFERT;
 exec sql end declare section;
 
 Transaction tr;
 exec sql lock table auftragentry in exclusive mode;
 exec sql select bestellt, geliefert, status
   into :BESTELLT, :GELIEFERT, :STATUS
   from auftragentry where
   auftragid = :AUFID and zeilennr = :AUFZNR and instanz=:INSTANZ;
 SQLerror::test(__FILELINE__);
 if(menge>=0 && STATUS!=(AufStatVal)OPEN) 
    throw(SQLerror(__FILELINE__,-1,"Auftragszeile ist bereits geschlossen"));
 if(menge<0 && STATUS==(AufStatVal)UNCOMMITED) 
    throw(SQLerror(__FILELINE__,-1,"Auftragszeile ist nicht bestätigt"));
 GELIEFERT+=menge;
 if(GELIEFERT>=BESTELLT) STATUS=(AufStatVal)CLOSED;
 else if(menge<0 && GELIEFERT<BESTELLT) STATUS=(AufStatVal)OPEN;
 exec sql update auftragentry set geliefert= :GELIEFERT, status= :STATUS
   where auftragid= :AUFID and zeilennr= :AUFZNR and instanz=:INSTANZ;  
 SQLerror::test(__FILELINE__);
 tr.commit();

 return GELIEFERT;
}




list<AufEintragBaseList::st_reflist> AufEintragBaseList::get_Referenz_list(const AufEintragBase2& aeb,bool kinder) const throw(SQLerror) 
{
 exec sql begin declare section;
  int INSTANZ[30],AUFTRAGID[30],ZEILENNR[30];
  long MENGE[30];
  int ARTIKEL[30];
  char query[1024];
 exec sql end declare section;
 Transaction tr;
 std::string squery;
 if(kinder)
    squery = "select neuauftragid,neuinstanz,neuzeilennr,menge,artikelid
      from auftragsentryzuordnung 
      join auftragentry on (neuauftragid,neuinstanz,neuzeilennr)
         = (auftragid,instanz,zeilennr)
      where (altauftragid,altinstanz,altzeilennr) = 
       ("+itos(aeb.Id())+","+itos(aeb.Instanz())+","+itos(aeb.ZNr())+")";
 else
    squery = "select altauftragid,altinstanz,altzeilennr,menge,artikelid
      from auftragsentryzuordnung 
      join auftragentry on (altauftragid,altinstanz,altzeilennr)
         = (auftragid,instanz,zeilennr)
      where (neuauftragid,neuinstanz,neuzeilennr) = 
       ("+itos(aeb.Id())+","+itos(aeb.Instanz())+","+itos(aeb.ZNr())+")";
 strncpy(query,squery.c_str(),sizeof(query));
 exec sql prepare ONAUF_ from :query;
cout << query<<"\n\n\n";
 exec sql declare ONAUF cursor for ONAUF_;
 exec sql open ONAUF;
          
 list<st_reflist> vaeb;
 while(true)
  {
    exec sql fetch 30 in ONAUF into :AUFTRAGID,:INSTANZ,:ZEILENNR,:MENGE,:ARTIKEL;
    SQLerror::test(__FILELINE__,100);
    if (sqlca.sqlcode) break;
    int j=sqlca.sqlerrd[2];
    for (int i=0;i<j;++i)
     {
      vaeb.push_back(st_reflist(
         AufEintragBase2(cH_ppsInstanz((ppsInstanz::ppsInstId)INSTANZ[i]),
             AUFTRAGID[i],ZEILENNR[i]),ARTIKEL[i],MENGE[i]));
     }
    if(j<30) break;
  }
 return vaeb;
}

list<AufEintragBaseList::st_reflist> AufEintragBaseList::get_Referenz_listFull(bool kinder) const throw(SQLerror)
{
// AufEintragBase2 aeb=*this;
 list<st_reflist> tv=get_Referenz_list(AEB,kinder);
 list<st_reflist> vaeb;
 list<st_reflist> tvxx;
reloop:
 tv.splice(tv.end(),tvxx);
 for (list<st_reflist>::iterator i=tv.begin();i!=tv.end();++i)
   {
     tvxx=get_Referenz_list(i->AEB2,kinder);
     if (tvxx.size()==0) vaeb.splice(vaeb.end(),tv,i) ;
     else tv.erase(i) ; 
     goto reloop;
   }
 return vaeb;
}


list<cH_Kunde> AufEintragBaseList::get_Referenz_Kunden_long() const throw(SQLerror)
{
 list<cH_Kunde> LK;
// list<st_reflist> vaeb = get_Referenz_AufEintragBase2();
 list<st_reflist> vaeb = get_Referenz_listFull(false);
 exec sql begin declare section;
  int KUNDE;
  int INSTANZ;
  int AUFTRAGID;
 exec sql end declare section;
 for (list<st_reflist>::const_iterator i=vaeb.begin();i!=vaeb.end();++i)
  {
    INSTANZ=i->AEB2.Instanz();
    AUFTRAGID=i->AEB2.Id();
    exec sql select kundennr into :KUNDE from auftrag where
      auftragid=:AUFTRAGID and instanz=:INSTANZ; 
    SQLerror::test(__FILELINE__);
    LK.push_back(cH_Kunde(KUNDE));
  }
 return LK;
}

list<cH_Kunde> AufEintragBaseList::get_Referenz_Kunden() const throw(SQLerror)
{
 list<cH_Kunde> LK = get_Referenz_Kunden_long();
 LK.sort();
 LK.unique();
 return LK;
}

std::list<AufEintragBase2> AufEintragBaseList::get_AufEintragList_from_Artikel
               (const ArtikelBase& artikel,const cH_ppsInstanz& instanz)
{
  std::list<AufEintragBase2> L;
  exec sql begin declare section;
   char query[1024];
   int db_auftragid,db_zeilennr;
  exec sql end declare section;
  std::string squery = "select auftragid,zeilennr from auftragentry
      where artikelid="+itos(artikel.Id())+" 
      and instanz="+itos(instanz->Id())+" and status="+itos(OPEN);
  strncpy(query,squery.c_str(),sizeof(query));
  Transaction tr;
  exec sql prepare AELfAein_ from :query ;
  exec sql declare AELfAein cursor for AELfAein_ ;

  exec sql open AELfAein;
  SQLerror::test(__FILELINE__);
  while(true)
   {
     exec sql fetch AELfAein into :db_auftragid,:db_zeilennr;
     SQLerror::test(__FILELINE__,100);
     if (sqlca.sqlcode) break;
     L.push_back(AufEintragBase2(instanz,db_auftragid,db_zeilennr));
   }  
  return L;
}

/* siehe headerfile
AufEintragBase2 AufEintragBaseList::get_AufEintrag_from_Artikel_by_Lfdate   
               (const ArtikelBase& artikel,const cH_ppsInstanz& instanz)
{
  std::list<AufEintragBase2> LI=get_AufEintragList_from_Artikel(artikel,instanz);
  std::list<st_reflist> LR;
  for(std::list<AufEintragBase2>::const_iterator i=LI.begin();i!=LI.end();++i)
   {
     std::list<st_reflist> LRtmp =
               AufEintragBase(*i).get_Referenz_listFull(false);
     LR.splice(LR.end(),LRtmp);
   }
  Petig::Datum lieferdatum;
  AufEintragBase2 AEB;
  // lieferdatum initialisieren
  if(LR.begin()!=LR.end()) 
  { lieferdatum=AufEintragBase(LR.begin()->AEB2).getLieferdatum();
    AEB=LR.begin()->AEB2;
   for(std::list<st_reflist>::const_iterator i=LR.begin();i!=LR.end();++i)
   {
    Petig::Datum ld=AufEintragBase(i->AEB2).getLieferdatum();
    if(ld<lieferdatum) 
      {
        AEB=i->AEB2;
        lieferdatum=ld;
      }
   }
  }
}
*/

void AufEintragBase2::setLetztePlanungFuer(int planinstanz) const throw(SQLerror)
{
 assert (Instanz()==ppsInstanz::Kundenauftraege);
 exec sql begin declare section;
  int AUFTRAGID=Id();
  int ZEILENNR=ZNr();
  int INSTANZ=Instanz();
  int PLANUNG=planinstanz;
  int PID;//=Prozess::default_id;
 exec sql end declare section;
 PID=Prozess::default_id;
 Transaction tr;
 
 exec sql update auftrag_prozess set letztePlanInstanz= :PLANUNG,
   maxPlanInstanz=null, datum= now() where 
   auftragid= :AUFTRAGID and instanz=:INSTANZ and zeilennr= :ZEILENNR ;
 SQLerror::test("Prozessaktualisierung",100);
 
 if((sqlca.sqlcode==100) || sqlca.sqlerrd[2]==0)
   {
    exec sql insert into auftrag_prozess 
      (auftragid,instanz,zeilennr,prozessid,datum,letztePlanInstanz,maxPlanInstanz)
      values
    	(:AUFTRAGID, :INSTANZ, :ZEILENNR, :PID, now(),:PLANUNG,null);
    SQLerror::test("Prozessaktualisierung");
   }
 tr.commit();
}

void AufEintragBase2::calculateProzessInstanz()
{
  assert (Instanz()==ppsInstanz::Kundenauftraege);
  AuftragsBaum AB(*this,true);
  int anz=0;
cout << "CALCULATE :"<<AB.size()<<'\n';
  for(AuftragsBaum::const_iterator i=AB.begin();i!=AB.end();++i)
   {
cout << "Auftragid = "<<i->AEB2.Id()<<'\t'<<i->AEB2.Instanz()<<'\n';
     if(i->AEB2.Id()==0) continue; // 0 = ungeplante Aufträge
cout << Id()<<'\t'<<Instanz()<<'\t'
 << cH_ArtikelBezeichnung(AufEintragBase(*this).ArtId())->Bezeichnung()<<'\t'
 << AufEintragBase(i->AEB2).getStueck()
 <<'\t'<<i->menge<<'\n';
     if(AufEintragBase(i->AEB2).getStueck() == i->menge)
       ++anz;
   }
//   setMaxPlanInstanz(i->AEB2.Instanz());
   setMaxPlanInstanz(anz);
}   


void AufEintragBase2::setMaxPlanInstanz(int maxplaninstanz) const throw(SQLerror)
{
 exec sql begin declare section;
  int AUFTRAGID=Id();
  int ZEILENNR=ZNr();
  int INSTANZ=Instanz();
  int PLANUNG=maxplaninstanz;
 exec sql end declare section;

 Transaction tr;
 
 exec sql update auftrag_prozess set maxPlanInstanz= :PLANUNG,
   datum= now() where 
   auftragid= :AUFTRAGID and instanz=:INSTANZ and zeilennr= :ZEILENNR ;
 SQLerror::test("Prozessaktualisierung");
 
 tr.commit();
}


