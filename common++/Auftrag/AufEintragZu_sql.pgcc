// $Id: AufEintragZu_sql.pgcc,v 1.14 2002/12/17 13:55:32 thoma Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/AufEintragZu.h>
#include <Aux/Transaction.h>
#include <Auftrag/auftrag_status.h>
//#include <Auftrag/AuftragsBaum.h> 
#include <Aux/Changejournal.h>
#include <Artikel/ArtikelStamm.h>
#include <Artikel/ArtikelBezeichnung.h>
#include <Aux/FetchIStream.h>
#include <Aux/Trace.h>

exec sql include sqlca;


std::list<AufEintragZu::st_reflist> AufEintragZu::get_Referenz_list(const AufEintragBase& aeb,bool kinder) const throw(SQLerror) 
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,aeb,"Kinder=",kinder);
 exec sql begin declare section;
  int INSTANZ[30],AUFTRAGID[30],ZEILENNR[30];
  double MENGE[30];
  int ARTIKEL[30];
  char query[1024];
 exec sql end declare section;
 Transaction tr;
 std::string squery;
 if(kinder)
    squery = "select neuauftragid,neuinstanz,neuzeilennr,menge,artikelid "
      "from auftragsentryzuordnung "
      "join auftragentry on (neuinstanz,neuauftragid,neuzeilennr)"
         "= (instanz,auftragid,zeilennr)"
      "where (altinstanz,altauftragid,altzeilennr) = "
      "("+itos(aeb.InstanzID())+","+itos(aeb.Id())+","+itos(aeb.ZNr())+")"
      " order by neuinstanz,neuauftragid,neuzeilennr ";
 else
    squery = "select altauftragid,altinstanz,altzeilennr,menge,artikelid "
      "from auftragsentryzuordnung "
      "join auftragentry on (altinstanz,altauftragid,altzeilennr)"
         "= (instanz,auftragid,zeilennr)"
      "where (neuinstanz,neuauftragid,neuzeilennr) = "
       "("+itos(aeb.InstanzID())+","+itos(aeb.Id())+","+itos(aeb.ZNr())+")"
       " order by altinstanz,altauftragid,altzeilennr" ;
 strncpy(query,squery.c_str(),sizeof(query));
 exec sql prepare ONAUF_ from :query;
//std::cout << query<<"\n\n\n";
 exec sql declare ONAUF cursor for ONAUF_;
 exec sql open ONAUF;
 std::list<st_reflist> vaeb;
 while(true)
  {
    exec sql fetch 30 in ONAUF into :AUFTRAGID,:INSTANZ,:ZEILENNR,:MENGE,:ARTIKEL;
    SQLerror::test(__FILELINE__,100);
    if (sqlca.sqlcode) break;
    int j=sqlca.sqlerrd[2];
    for (int i=0;i<j;++i)
     {
      vaeb.push_back(st_reflist(
         AufEintragBase(cH_ppsInstanz((ppsInstanz::ID)INSTANZ[i]),
             AUFTRAGID[i],ZEILENNR[i]),ARTIKEL[i],MENGE[i]));
     }
    if(j<30) break;
  }
 exec sql close ONAUF;
 tr.close();
 return vaeb;
}

std::list<AufEintragZu::st_reflist> AufEintragZu::get_Referenz_list_without_child() const throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 exec sql begin declare section;
  int INSTANZ[30],AUFTRAGID[30],ZEILENNR[30];
  double MENGE[30];
  char query[1024];
 exec sql end declare section;
 Transaction tr;
 std::string squery;

    squery = "select neuauftragid,neuinstanz,neuzeilennr,menge "
      "from auftragsentryzuordnung "
      "where (altinstanz,altauftragid,altzeilennr) = "
      "("+itos(InstanzID())+","+itos(Id())+","+itos(ZNr())+")"
      " order by neuinstanz,neuauftragid,neuzeilennr" ;

 strncpy(query,squery.c_str(),sizeof(query));
 exec sql prepare ONAUFC_ from :query;
//std::cout << query<<"\n\n\n";
 exec sql declare ONAUFC cursor for ONAUFC_;
 exec sql open ONAUFC;
 std::list<st_reflist> vaeb;
 while(true)
  {
    exec sql fetch 30 in ONAUFC into :AUFTRAGID,:INSTANZ,:ZEILENNR,:MENGE;
    SQLerror::test(__FILELINE__,100);
    if (sqlca.sqlcode) break;
    int j=sqlca.sqlerrd[2];
    for (int i=0;i<j;++i)
     {
      vaeb.push_back(st_reflist(
         AufEintragBase(cH_ppsInstanz((ppsInstanz::ID)INSTANZ[i]),
             AUFTRAGID[i],ZEILENNR[i]),ArtikelBase(),MENGE[i]));
     }
    if(j<30) break;
  }
 exec sql close ONAUFC;
 tr.close();
 return vaeb;
}




std::list<cH_Kunde> AufEintragZu::get_Referenz_Kunden() const throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 std::list<cH_Kunde> LK;
 std::list<st_reflist> vaeb = get_Referenz_listFull(false);
 exec sql begin declare section;
  int KUNDE;
  int INSTANZ;
  int AUFTRAGID;
 exec sql end declare section;
 for (std::list<st_reflist>::const_iterator i=vaeb.begin();i!=vaeb.end();++i)
  {
    INSTANZ=i->AEB.InstanzID();
    AUFTRAGID=i->AEB.Id();
    exec sql select kundennr into :KUNDE from auftrag where
      (instanz,auftragid)=(:INSTANZ,:AUFTRAGID) order by kundennr; 
    SQLerror::test(__FILELINE__);
    LK.push_back(cH_Kunde(KUNDE));
  }
 LK.sort();
 LK.unique();
 return LK;
}

std::list<AufEintragBase> AufEintragZu::get_AufEintragList_from_Artikel
               (const ArtikelBase& artikel,ppsInstanz::ID instanz,AufStatVal status)
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"Artikel=",artikel,"Status=",status,"Instanz=",instanz);
  std::list<AufEintragBase> L;
  exec sql begin declare section;
   char query[1024];
   int db_auftragid,db_zeilennr;
  exec sql end declare section;
  std::string squery = "select auftragid,zeilennr from auftragentry "
      "where artikelid="+itos(artikel.Id()) +
      " and instanz!="+itos(ppsInstanzID::Kundenauftraege) //Nur interne Aufträge sind interessant
      +" and auftragid=0" // Nur die UNGEPLANTEN Aufträge bekommen neue Kinder
      " order by auftragid,zeilennr";
  if(status!=NOSTAT) squery += " and status="+itos(status);
  strncpy(query,squery.c_str(),sizeof(query));
  Transaction tr;
  exec sql prepare AELfAein_ from :query ;
  exec sql declare AELfAein cursor for AELfAein_ ;

  exec sql open AELfAein;
  SQLerror::test(__FILELINE__);
  while(true)
   {
     exec sql fetch AELfAein into :db_auftragid,:db_zeilennr;
     SQLerror::test(__FILELINE__,100);
     if (sqlca.sqlcode) break;
     L.push_back(AufEintragBase(instanz,db_auftragid,db_zeilennr));
//std::cout << "Liste: "<<I->Name()<<' '<<db_auftragid<<' '<<db_zeilennr<<'\n';
   }  
  return L;
}

void AufEintragZu::Neu(const AufEintragBase& neuAEB,
                       const mengen_t menge,const int oldZnr)
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,
      "Menge=",menge,"OldZNr=",oldZnr);

//ECPGdebug(true,stdout);
 exec sql begin declare section;
  int db_aaid=Id();
  int db_ains=InstanzID();
  int db_aznr=ZNr();
  double db_menge=menge.as_float();
  int db_naid=neuAEB.Id();
  int db_nins=neuAEB.InstanzID();
  int db_nznr=neuAEB.ZNr();
 exec sql end declare section;
 if(oldZnr!=0) db_aznr=oldZnr;
 try{ mengen_t mt=setMengeDiff__(neuAEB,menge); 
      assert(menge==mt);
    }
 catch (SQLerror &e)
 {
 exec sql insert into auftragsentryzuordnung
   (altinstanz,altauftragid,altzeilennr, menge, neuinstanz,neuauftragid,neuzeilennr) values
   (:db_ains,:db_aaid,:db_aznr, :db_menge, :db_nins,:db_naid,:db_nznr);
 SQLerror::test(__FILELINE__);
 }
//ECPGdebug(false,0);
}

#include <Aux/itos.h>

bool AufEintragZu::setMenge(const AufEintragBase& neuAEB,const mengen_t menge)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,neuAEB,"Menge=",menge);
 exec sql begin declare section;
  int db_aaid=Id();
  int db_ains=InstanzID();
  int db_aznr=ZNr();
  double db_menge=menge.as_float();
  int db_naid=neuAEB.Id();
  int db_nins=neuAEB.InstanzID();
  int db_nznr=neuAEB.ZNr();
 exec sql end declare section;
 exec sql update auftragsentryzuordnung
   set menge=:db_menge where
   (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid,neuzeilennr)
    = (:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid,:db_nznr);
 SQLerror::test(__FILELINE__,100);
 if (sqlca.sqlcode) return false;
 else return true;
}


AuftragBase::mengen_t AufEintragZu::setMengeDiff__(const AufEintragBase &neuAEB,const mengen_t menge)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,neuAEB,"Menge=",menge);
 exec sql begin declare section;
  int db_aaid=Id();
  int db_ains=InstanzID();
  int db_aznr=ZNr();
  double db_menge=menge.as_float();
  int db_naid=neuAEB.Id();
  int db_nins=neuAEB.InstanzID();
  int db_nznr=neuAEB.ZNr();
  double db_oldmenge;
 exec sql end declare section;
 if(menge<0)
  {
//ECPGdebug(true,stdout);
   exec sql select menge into :db_oldmenge from auftragsentryzuordnung where 
      (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid,neuzeilennr)
       = (:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid,:db_nznr);
   SQLerror::test(__FILELINE__);
   if(mengen_t(db_oldmenge)<-menge)
       db_menge=-db_oldmenge;
  } 
 exec sql update auftragsentryzuordnung
   set menge=menge+:db_menge where
   (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid,neuzeilennr)
    = (:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid,:db_nznr);
 SQLerror::test(__FILELINE__);
//ECPGdebug(false,0);
 return db_menge;
}


bool AufEintragZu::setKindZnr(const AufEintragBase& neuAEB)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,neuAEB);
 exec sql begin declare section;
  int db_aaid=Id();
  int db_ains=InstanzID();
  int db_aznr=ZNr();
  int db_naid=neuAEB.Id();
  int db_nins=neuAEB.InstanzID();
  int db_nznr=neuAEB.ZNr();
 exec sql end declare section;
 exec sql update auftragsentryzuordnung
   set neuzeilennr=:db_nznr where
   (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid)
    = (:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid);
 SQLerror::test(__FILELINE__,100);
 if (sqlca.sqlcode) return false;
 else return true;
}

void AufEintragZu::moveInstanz(const VonNachDel vdl,const AufEintragBase &oldAEB, const AufEintragBase &newAEB) throw(SQLerror)
{

 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,oldAEB,"VonNachDel=",vdl);
 exec sql begin declare section;
  int db_aaid=oldAEB.Id();
  int db_ains=oldAEB.Instanz()->Id();
  int db_aznr=oldAEB.ZNr();
  int db_naid=newAEB.Id();
  int db_nins=newAEB.Instanz()->Id();
  int db_nznr=newAEB.ZNr();
 exec sql end declare section;

 switch(vdl)
  {
   case Von:
    exec sql update auftragsentryzuordnung set 
      altauftragid=:db_naid, altinstanz=:db_nins, altzeilennr=:db_nznr where
      (altinstanz,altauftragid,altzeilennr)=(:db_ains,:db_aaid,:db_aznr);
    break;
   case Nach:
    exec sql update auftragsentryzuordnung set 
      neuauftragid=:db_naid, neuinstanz=:db_nins, neuzeilennr=:db_nznr where
      (neuinstanz,neuauftragid,neuzeilennr)=(:db_ains,:db_aaid,:db_aznr);
    break;
   case Delete:
    exec sql delete from auftragsentryzuordnung where
      (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid,neuzeilennr)
     =(:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid,:db_nznr);
    break;
  }
 SQLerror::test(__FILELINE__,100);
}


AuftragBase::mengen_t AufEintragZu::getMenge(const AufEintragBase& aeb) const
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,aeb);
 exec sql begin declare section;
  int db_aaid=Id();
  int db_ains=InstanzID();
  int db_aznr=ZNr();
  int db_naid=aeb.Id();
  int db_nins=aeb.InstanzID();
  int db_nznr=aeb.ZNr();
  int db_menge;   
 exec sql end declare section;
 exec sql select menge into :db_menge from auftragsentryzuordnung
   where
   (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid,neuzeilennr)
    = (:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid,:db_nznr);
 SQLerror::test(__FILELINE__);
 return db_menge;
}

bool AufEintragZu::remove(const AufEintragBase& alt,const AufEintragBase& neu)
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,alt,neu);

  std::string Q="delete from auftragsentryzuordnung where "
                 "(altinstanz,altauftragid,altzeilennr,"
                 "neuinstanz,neuauftragid,neuzeilennr)=("
                 +itos(alt.Instanz()->Id())+","+itos(alt.Id())+","+itos(alt.ZNr())+","
                 +itos(neu.Instanz()->Id())+","+itos(neu.Id())+","+itos(neu.ZNr())+")";
 Query::Execute(Q);
 SQLerror::test(__FILELINE__,100);
 if(sqlca.sqlcode) return false;
 return true;
}

