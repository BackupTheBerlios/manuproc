// $Id: AufEintrag_sql.pgcc,v 1.33 2002/12/09 11:22:28 thoma Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/AufEintrag.h>
#include <Auftrag/AuftragsBaum.h>
#include <stdio.h>
#include <Aux/string0.h>
#include <Aux/Transaction.h>
#include <Aux/FetchIStream.h>
#include "auftrag_status.h"
#include <Aux/Changejournal.h>
#include "selFullAufEntry.h"
#include <Auftrag/AufEintragZu.h>
#include <Lager/Lager.h>
#include <Lieferschein/Lieferschein.h>
#ifdef MABELLA_EXTENSIONS
#include <Lager/FertigWaren.h>
#include <Artikel/ArtikelBase.h>
#endif
#include <Artikel/ArtikelStamm.h>
#include <Auftrag/Auftrag.h>
#include <algorithm>
#include <unistd.h>
//#include <Instanzen/ppsInstanzProduziert.h>
#include <Aux/Trace.h>
#include <Artikel/ArtikelImLager.h>

exec sql include sqlca;

void AufEintrag::abschreiben(mengen_t menge,
    ManuProcEntity<>::ID lfrsid) throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,"Menge=",menge,"Lfrsid=",lfrsid);

 exec sql begin declare section;
  int AUFID=Id();
  int AUFZNR=ZNr();
  int INSTANZ=InstanzID();
  int STATUS=getEntryStatus();
  int GELIEFERT=(menge+getGeliefert()).as_int();
  int BESTELLT=getStueck().as_int();
  char LASTDATE[21];
 exec sql end declare section;
 Petig::Datum::today().write_postgres(LASTDATE,sizeof LASTDATE);
//if(Id()==2) ECPGdebug(1,stdout);

 if(menge>=0 && getEntryStatus()!=(AufStatVal)OPEN) 
    throw(SQLerror(__FILELINE__,-1,"Auftragszeile ist nicht offen sondern "+itos(STATUS)));
 if(menge<0 && getEntryStatus()==(AufStatVal)UNCOMMITED) 
    throw(SQLerror(__FILELINE__,-1,"Auftragszeile ist nicht bestätigt"));
 if (menge<0 && -menge>getGeliefert()) 
 {  menge=-getGeliefert(); GELIEFERT=0; }

 if (!menge) return;

 AufStatVal oldstatus=getEntryStatus();

 if(mengen_t(GELIEFERT)>=getStueck()) STATUS=(AufStatVal)CLOSED;
 else if(menge<0 && mengen_t(GELIEFERT)<getStueck()) STATUS=(AufStatVal)OPEN;

 Transaction tr;
 exec sql lock table auftragentry in exclusive mode;
 bool delete_entry=false;
#ifdef PETIG_EXTENSIONS
  if(menge<0 &&
     Instanz()!=ppsInstanzID::Kundenauftraege && 
     !Instanz()->ProduziertSelbst() && 
     Id()==AuftragBase::plan_auftrag_id)
   {
     BESTELLT+=menge.as_int();
     if(BESTELLT<0) BESTELLT=0;
     if(BESTELLT==GELIEFERT) STATUS=CLOSED;
     if(BESTELLT==0 && GELIEFERT==0 &&  STATUS==CLOSED) delete_entry=true;
   }   
#endif
 if(delete_entry)
   exec sql delete from auftragentry       
     where (instanz,auftragid,zeilennr) = (:INSTANZ,:AUFID,:AUFZNR);
 else
   exec sql update auftragentry set geliefert= :GELIEFERT, status= :STATUS,
     bestellt = :BESTELLT, letzte_lieferung=:LASTDATE
     where (instanz,auftragid,zeilennr) = (:INSTANZ,:AUFID,:AUFZNR);
 SQLerror::test(__FILELINE__);

#ifdef MABELLA_EXTENSIONS // Lager updaten
 if(Instanz() == ppsInstanzID::Kundenauftraege)
   {
    FertigWaren fw(Artikel(),(FertigWaren::enum_Aktion)'L',menge.as_int(),lfrsid);
    if(menge < 0) fw.Einlagern(1);
    else if(menge > 0) fw.Auslagern(1);
   }
#endif

 geliefert=GELIEFERT;
 if(geliefert>=bestellt) entrystatus=(AufStatVal)CLOSED;

#ifdef PETIG_EXTENSIONS
 if(STATUS!=oldstatus && Id()!=dispo_auftrag_id)
#else
 if(STATUS!=oldstatus)
#endif
     setStatus(AufStatVal(STATUS),true);

 tr.commit();
}


void AufEintrag::setStatus(AufStatVal newstatus,int uid,bool force) throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,"Status=",newstatus,"Force=",force);
 if(newstatus == STORNO) force=true;
 if(newstatus == STORNO && getGeliefert()!=mengen_t(0))  return;
 if(entrystatus == CLOSED && !force ) return; // nichts geht mehr
 if(newstatus == UNCOMMITED) return; // zurück geht nicht, nur vor
 if(entrystatus == newstatus) return;     // nichts geändert
 if(newstatus == OPEN && entrystatus != UNCOMMITED && !force) return;


 Transaction tr; 
 exec sql lock auftragentry in exclusive mode;
 SQLerror::test("setStatus: lock table auftragentry");

 if(newstatus == CLOSED || newstatus == STORNO)
     updateStkDiffInstanz__(uid,-getRestStk(),ManuProC::Auftrag::r_Closed);    

 std::string sqlcommand = "update auftragentry set status="+itos(newstatus);
 if(uid) sqlcommand+=", lasteditdate = now(), lastedit_uid="+itos(uid);
 sqlcommand +=" where (instanz,auftragid,zeilennr)=("+itos(Instanz()->Id())
              +","+itos(auftragid)+","+itos(zeilennr)+")";

 Query::Execute(sqlcommand);
 SQLerror::test("setStatus: update auftragentry");
 AufStatVal oldentrystatus=entrystatus;
 entrystatus=newstatus;


 if(newstatus==OPEN && auftragstatus==UNCOMMITED)
    setStatusAuftragBase(newstatus);

 if(newstatus == OPEN  &&  oldentrystatus==UNCOMMITED)
   {
     BaumAnlegen(*this,uid);
   }

 if(newstatus==OPEN)
   {
    pps_ChJournalEntry::newChange(
			instanz, *this, artikel,
			bestellt.as_float(),
			bestellt.as_float(),
			pps_ChJournalEntry::CH_MENGE);
  }
 else if(newstatus==CLOSED && oldentrystatus!=UNCOMMITED) 
 // UNCOMMITED->CLOSED => kein Eintrag
   {
    pps_ChJournalEntry::newChange(
			instanz, *this, artikel,
			geliefert.as_float(),
			(geliefert-bestellt).as_float(),
			pps_ChJournalEntry::CH_MENGE);
   }

 tr.commit(); 
}


void AufEintrag::setInstanzen(const AufStatVal newstatus,const int uid,const Petig::Datum &lieferdate,const mengen_t &Menge,const int myznr,const int yourznr)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,"Status=",newstatus,"Menge=",Menge,"MyZNr=",myznr,"YourZNr=",yourznr);
 std::list<AufEintragZu::st_reflist> KindListe = AufEintragZu(*this).get_Referenz_list(*this,true);
 for(std::list<AufEintragZu::st_reflist>::const_iterator i=KindListe.begin();i!=KindListe.end();++i)
  {
   mengen_t Mauftrag=AufEintrag(i->AEB).getRestStk();
   mengen_t Mzuordnung=i->Menge;
   AufEintrag AE(i->AEB);
   // AufEintrag splitten und Anlegen in der Zuordnungsliste
   int znr=0,newznr=0; mengen_t menge=0;
   if(!i->AEB.existEntry(i->Art,lieferdate,znr,newznr,menge,newstatus))
     {
      Auftrag A(i->AEB);
      AufEintragBase neuAEB=A.push_back(Mauftrag,lieferdate,i->Art,newstatus,uid,false); //false=KEINE Instanzen
      znr=neuAEB.ZNr();
      if(Instanz()==ppsInstanzID::Kundenauftraege) 
            AufEintragZu(*this).setKindZnr(neuAEB);
      else 
         {
            AufEintragZu(*this).Neu(neuAEB,Mzuordnung,myznr);
            AufEintragZu(*this).setMengeDiff__(AE,-Mzuordnung);
         }
     }
   else
     {
      AufEintragBase AEBZ(AE,znr); 
      mengen_t mt=AEBZ.updateStkDiffBase__(uid,Mauftrag);
      assert(mt==Mauftrag);
      if(Instanz()==ppsInstanzID::Kundenauftraege) 
            AufEintragZu(*this).setKindZnr(AEBZ);
      else 
         {
            mengen_t mts=AufEintragZu(*this).setMengeDiff__(AE,-Mzuordnung);
            assert(mts==-Mzuordnung);
            AufEintragZu(class AufEintragBase(*this,myznr)).Neu(AEBZ,Mzuordnung); // 'Neu' versucht erst ein 'update'
         }
     }
   AE.updateStkDiff__(uid,-Mauftrag,false,ManuProC::Auftrag::r_Anlegen); // macht auch das Lager
   if(auftragstatus==UNCOMMITED && newstatus==OPEN ) 
      AE.setStatusAuftragBase(newstatus);

   if(instanz->LagerInstanz() && Id()==plan_auftrag_id && 
       (newstatus==STORNO || Mauftrag < 0 ))
    {
      LagerBase L(instanz);
      L.rein_ins_lager(ArtId(),Mauftrag,uid);
    }
   AE.setInstanzen(newstatus,uid,lieferdate,Mauftrag,znr,newznr);
  }
}


AuftragBase::mengen_t AufEintrag::updateStkDiff__(int uid,mengen_t menge,bool instanzen,ManuProC::Auftrag::Action reason) throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,"Menge=",menge,"Instanzen(bool)=",instanzen,"Reason=",reason);
 if(reason==ManuProC::Auftrag::r_None) assert(!instanzen);
 if(menge==mengen_t(0))  return menge;
 if(auftragstatus==OPEN || auftragstatus==UNCOMMITED)
  {
   Transaction tr;
   exec sql lock auftragentry in exclusive mode;
   SQLerror::test("updateStkDiff: lock table auftragentry");
   mengen_t mt=updateStkDiffBase__(uid,menge);

//cout << "M;"<<menge<<'\t'<<mt<<'\n';

   if(instanzen || reason==ManuProC::Auftrag::r_Reparatur)
      updateStkDiffInstanz__(uid,mt,reason);
   bestellt+=menge;

   tr.commit();
   return mt;
  }
 return menge;
}


void AufEintrag::updateStkDiffInstanz__(int uid,mengen_t oldmenge,ManuProC::Auftrag::Action reason) throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,"OldMenge=",oldmenge,
   "Reason=",reason);
 std::list<AufEintragZu::st_reflist> KindListeU = AufEintragZu(*this).get_Referenz_list_ungeplant();
 try{
  std::vector<ArtikelBase> VA;
  std::list<AufEintragZu::st_reflist> ZU;
  if(reason==ManuProC::Auftrag::r_Anlegen || reason==ManuProC::Auftrag::r_Closed) 
         ZU=KindListeU;
  else
   for(std::list<AufEintragZu::st_reflist>::iterator i=KindListeU.begin();i!=KindListeU.end();++i)
    {
      // Nach dem Planen kann es zu einem Auftrag mehrere Kindaufträge 
      // mit demselben Artikel geben, nur bei EINEM darf die Menge geändert
      // werden
      std::vector<ArtikelBase>::iterator j=std::find(VA.begin(),VA.end(),i->Art);
      if(j!=VA.end()) continue; // Artikel schon bekannt
      // Nur wenn es keinen mit einer Menge!=null gibt diesen erhöhen.
      std::list<AufEintragZu::st_reflist>::iterator e=i;
      if(i->Menge!=mengen_t(0) || (ZU.empty() && KindListeU.end()==++e) )
       {                                         
         VA.push_back(i->Art);
         ZU.push_back(*i);
       }
     }

  for(std::list<AufEintragZu::st_reflist>::iterator i=ZU.begin();i!=ZU.end();++i)
   {
     ArtikelBaum::faktor_t faktor = ArtikelBaum(ArtId()).Faktor(i->Art);
     AuftragBase::mengen_t menge=faktor*oldmenge;
//cout <<*this<<'\t'<< menge<<'\t'<<faktor<<' '<<oldmenge<<'\n';
     AufEintrag AE(i->AEB);
//cout <<AE<<'\n';
     mengen_t mt=AE.updateStkDiff__(uid,menge,true,reason);
     AufEintragZu(*this).setMengeDiff__(i->AEB,menge);

     if(mt!=mengen_t(menge)) // es konnte nicht alles bei ungeplanten reduziert werden
      {
        AuftragBase::mengen_t restmenge=mt-menge;
        assert(restmenge>AuftragBase::mengen_t(0));
        AE.move_menge_to_dispo_zuordnung_or_lager(restmenge,uid,reason);
      }
    }

  }catch(NoAEB_Error &e) 
  {std::cerr <<"Falsche Anzahl von AufEinträgen: "<<e.what()<<'\n'; 
   exit(1);}

  // Wenn ein 0er ein geplantes Kind hat, für das noch freie Menge (2er)
  // verfügbar ist ...
  std::list<AufEintragZu::st_reflist> KindListeG = AufEintragZu(*this).get_Referenz_list(*this,true);
  mengen_t restmenge=oldmenge;
  for(std::list<AufEintragZu::st_reflist>::iterator i=KindListeG.begin();i!=KindListeG.end();++i)
   {
     //nur die 20000 sind wichtig
     if(i->AEB.Id()!=AuftragBase::dispo_auftrag_id &&
        i->AEB.Id()!=AuftragBase::plan_auftrag_id &&
        i->AEB.Id()!=AuftragBase::ungeplante_id )
      {
        mengen_t M=mengen_t(0);
        std::list<AufEintragZu::st_reflist> DispoList=AufEintragZu(i->AEB).get_Referenz_list_dispo(false);
        assert(DispoList.empty() || DispoList.size()==1);
        for(std::list<AufEintragZu::st_reflist>::iterator j=DispoList.begin();j!=DispoList.end();++j)
         {
           M=j->Menge;
           if(M>restmenge) M=restmenge;
           AufEintragZu(j->AEB).Neu(i->AEB,-M);
           j->AEB.updateStkDiffBase__(uid,-M);
//cout << *this<<'\t'<<i->AEB<<'\t'<<j->AEB<<'\t'<<M<<'\n';
         }
        AufEintragZu(*this).Neu(i->AEB,M);
        updateStkDiffBase__(uid,-M);
        restmenge-=M;
        if(restmenge==mengen_t(0)) break;
      }
   }  
}

void AufEintrag::updatePreis(const Preis &pr) throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__);
 exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int ZEILENNR = zeilennr;
 int INSTANZ=instanz->Id();
 float PREIS=pr.Wert().as_float();
 float PREISMENGE=pr.PreisMenge().as_float();
 exec sql end declare section;
 
 exec sql update auftragentry 
 	set preis= :PREIS, preismenge= :PREISMENGE
 	where (instanz,auftragid,zeilennr)=(:INSTANZ,:AUFTRAGID,:ZEILENNR);
 SQLerror::test("updatePreis: update preis in auftragentry");
 preis=pr;
}



void AufEintrag::updateRabatt(rabatt_t rb) throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__);
 exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int INSTANZ=instanz->Id();
 int ZEILENNR = zeilennr;
 float RABATT = rb.as_float();
 exec sql end declare section;

 exec sql update auftragentry set rabatt= :RABATT
 	where (instanz,auftragid,zeilennr)=(:INSTANZ,:AUFTRAGID,:ZEILENNR);
 SQLerror::test("updateRabatt: update rabatt in auftragentry");
 
 rabatt=RABATT;
}


void AufEintrag::updateLieferdatum(const Petig::Datum &ld,int uid) throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,
   "Datum=",ld);
 exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int INSTANZ=instanz->Id();
 int ZEILENNR = zeilennr;
 char LIEFERDATUM[21];
 exec sql end declare section;
//ECPGdebug(true,stdout);

 Transaction tr;
 exec sql lock auftragentry in exclusive mode;
 SQLerror::test("updateLieferdatum: lock table auftragentry");
  
 ld.write_postgres(LIEFERDATUM,sizeof LIEFERDATUM);
 
 exec sql update auftragentry set lieferdate= :LIEFERDATUM
 	where (instanz,auftragid,zeilennr)=(:INSTANZ,:AUFTRAGID,:ZEILENNR);
 SQLerror::test("updateLiefDatum: update lieferdate in auftragentry");

 //update Lieferdatum für Instanzen
 setInstanzen(entrystatus,uid,ld,getStueck()); 

 if(entrystatus==OPEN)// status->entrystatus
  {
   try 
    {
     pps_ChJournalEntry::newChange(
  			instanz, *this,
  			artikel, ld,
  			(double)(ld-getLieferdatum()),
  			pps_ChJournalEntry::CH_LIEFDAT);
    }
   catch(SQLerror &e)
     {tr.rollback(); throw; }
  }
 
 lieferdatum=ld;
 tr.commit(); 
}

#include <Misc/relops.h>
  
int AufEintrag::split(int uid,mengen_t newmenge, const Petig::Datum &newld,bool dispoplanung) throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,"NewMenge=",newmenge,"NewDatum=",newld,"dispoplanung(bool)=",dispoplanung);
 if(entrystatus==CLOSED) return none_znr;

 mengen_t BESTELLT_OLD=bestellt-newmenge;
 int STATUS=entrystatus;

 double GELIEFERT;
 double GELIEFERT_OLD;

 if(lieferdatum>newld)
   {GELIEFERT=(geliefert>newmenge ? mengen_t(newmenge) : geliefert).as_float();
    GELIEFERT_OLD=(geliefert>newmenge ? geliefert-mengen_t(newmenge) : mengen_t(0)).as_float();}
 else
   {GELIEFERT_OLD=(geliefert>BESTELLT_OLD ? mengen_t(BESTELLT_OLD) : geliefert).as_float();
    GELIEFERT=(geliefert>BESTELLT_OLD ? geliefert-mengen_t(BESTELLT_OLD) : mengen_t(0)).as_float();}
    
 Transaction tr;
 exec sql lock auftragentry in exclusive mode;
 SQLerror::test("split: lock table auftragentry");


 mengen_t mt=updateStkDiff__(uid,-newmenge,true,ManuProC::Auftrag::r_Anlegen);
 assert(mt==-newmenge);

 int ZEILENNR;
 if(Instanz()==ppsInstanzID::Kundenauftraege)
   {Auftrag A(*this);
    AufEintragBase newaeb=A.push_back(newmenge,newld,artikel,entrystatus,uid,true,preis,rabatt);
    ZEILENNR=newaeb.ZNr();
   }
 else
   ZEILENNR=split_zuordnungen_to(newmenge,newld,artikel,entrystatus,uid,dispoplanung);

 if(STATUS==OPEN)
   {   pps_ChJournalEntry::newChange(
    			instanz, *this,
    			artikel, BESTELLT_OLD.as_float(), (BESTELLT_OLD-bestellt).as_float(),
    			pps_ChJournalEntry::CH_MENGE);
       pps_ChJournalEntry::newChange(
    			instanz, *this,
    			artikel, newmenge.as_float(), newmenge.as_float(),
    			pps_ChJournalEntry::CH_MENGE);
   }

 tr.commit();
 return ZEILENNR;
}

AufEintrag::AufEintrag(const AufEintragBase &aebb) throw (SQLerror,NoAEB_Error)
  : AufEintragBase(aebb), 
    artikel(0),
    prozess(Prozess::default_id)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,aebb);
 try{
  SelectedFullAufList aufids((SQLFullAuftragSelector)
    (SQLFullAuftragSelector::sel_AufidZnr(aebb)));

  if ( aufids.aufidliste.size()!=1 ) throw NoAEB_Error(aufids.aufidliste.size());

  *this=*(aufids.aufidliste.begin());
 } catch (SQLerror &e) {std::cerr << e <<'\n';}
}


void AufEintrag::moveInstanz(int uid,const AuftragBase &newAuftrag) throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,"NewAuftrag=",newAuftrag);
 AufEintragBase oldAEB = *this;
 auftragid=newAuftrag.Id(); 
 instanz=newAuftrag.Instanz();

 exec sql begin declare section;
  int OLDAUFTRAGID = oldAEB.Id();
  int OLDINSTANZ   = oldAEB.Instanz()->Id();
  int OLDZEILENNR  = oldAEB.ZNr();  
 exec sql end declare section;

 AuftragBase::mengen_t menge=getRestStk();
 mengen_t mt=oldAEB.updateStkDiffBase__(uid,-menge);
 assert(mt==-menge);

 ArtikelImLager AIL(instanz,artikel,lieferdatum);
 AuftragBase::mengen_t lagermenge=AIL.getMengeDispo();

//cout << "AufEintrag_sql.pgcc: "<<lagermenge_new<<' '<<lagermenge<<'\n';
 
 mengen_t bestellmenge;
 if(lagermenge>=bestellt) bestellmenge = 0;
 else                     bestellmenge = bestellt-lagermenge;

 Auftrag A(newAuftrag);
 AufEintragBase newaeb= A.push_back(bestellmenge,getLieferdatum(),Artikel(),
                            getEntryStatus(),uid,false,EPreis(),Rabatt());
 zeilennr = newaeb.ZNr();
 AufEintragBase(newAuftrag,zeilennr).vormerken_oder_bestellen(uid,
     bestellt-bestellmenge,bestellt,Artikel(),getLieferdatum(),AIL.getDispoAuftraege());

// exec sql delete from prod_changejournal where 
//      (insid,auftragid,auftragzeile)=(:OLDINSTANZ,:OLDAUFTRAGID,:OLDZEILENNR);
 exec sql delete from auftragentry where 
   (instanz,auftragid,zeilennr) = (:OLDINSTANZ,:OLDAUFTRAGID,:OLDZEILENNR);
 SQLerror::test("moveInstanz: delete from auftragentry");

 if(oldAEB.Instanz()->LagerInstanz())
   {
     SQLFullAuftragSelector psel= SQLFullAuftragSelector::sel_Artikel(
//                                  oldAEB.Instanz()->LagerFuer()
                                  ppsInstanz::getProduktionsInstanz(Artikel())->Id()
                                  ,Artikel());
     SelectedFullAufList allaufids=SelectedFullAufList(psel);
     for(SelectedFullAufList::iterator i=allaufids.begin();i!=allaufids.end();++i)
      {
        OLDINSTANZ=i->Instanz()->Id();
        OLDAUFTRAGID=i->Id();
        OLDZEILENNR=i->ZNr();
        exec sql delete from auftragentry where 
            (instanz,auftragid,zeilennr) = (:OLDINSTANZ,:OLDAUFTRAGID,:OLDZEILENNR);
        SQLerror::test("moveInstanz: delete from auftragentry");
        AufEintragZu::moveInstanz(AufEintragZu::Delete,oldAEB,*i);
        AufEintragZu::moveInstanz(AufEintragZu::Von,*i,*this);
      }
   }
 else AufEintragZu::moveInstanz(AufEintragZu::Von,oldAEB,*this);
 AufEintragZu::moveInstanz(AufEintragZu::Nach,oldAEB,*this);
}




cH_Lieferschein AufEintrag::getLieferschein() const
{
  ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__);
  exec sql begin declare section;
   int LFRSID=0,LFRZNR=0;
   int AUFID=Id();
   int AUFZNR=ZNr();
   int INSTANZ=Instanz()->Id();
  exec sql end declare section;
  exec sql select lfrsid,zeile into :LFRSID,:LFRZNR
      from lieferscheinentry where 
      (instanz,refauftragid,refzeilennr)=(:INSTANZ,:AUFID,:AUFZNR) limit 1;
#warning kann es mehr als eine Zeile geben? 
 SQLerror::test(__FILELINE__,100);
 if(sqlca.sqlcode) // keine Zeile gefunden ... warum nicht throw?
   return cH_Lieferschein(ppsInstanzID::None,0);
 else 
   return cH_Lieferschein(Instanz(),LFRSID);
}
