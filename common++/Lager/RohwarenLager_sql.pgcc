/*  pps: ManuProC's production planning system
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "RohwarenLager.h"
#include <Artikel/ArtikelBase.h>
#include <Artikel/ArtikelBezeichnung.h>
#include <Misc/Datum.h>
#include <Misc/string0.h>
exec sql include sqlca;
#include <Misc/SQLerror.h>
#include <Misc/Transaction.h>
#include <Misc/itos.h>
#include <unistd.h>
#include <Misc/relops.h>
#include <Misc/TraceNV.h>

std::string RohwarenLager::st_rohlager::Menge_als_Text() const
{  std::string s;
   if (kartons) s+=itos(kartons)+" Kartons à " + itos(kg_pro_karton)+ "kg ";
   if (reste||reste_kg) s+=itos(reste) +" Reste="+ itos(reste_kg) + "kg";
   if (s.empty()) s="nichts";
   return s;
}

AuftragBase::mengen_t RohwarenLager::st_rohlager::Menge_fuer_Auftrag() const
{  return kartons*kg_pro_karton  + reste_kg;
}

bool RohwarenLager::RL_Entnahme(st_rohlager& rohlager,const int uid,std::string &os,bool force,bool ist_leer,bool fuer_auftrag)
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,
  	NV("kartons",rohlager.kartons),NV("reste",rohlager.reste),
  	NV("artikel",rohlager.artikel.Id()),
  	NV("position",rohlager.position.SPosition()));
  Transaction tr;
  exec sql begin declare section;
   int KARTONS;
   int RESTE;
   int RESTE_KG;
   char POSITION[5];
   char DATUM[11];
   bool DUMMY;
  exec sql end declare section;
  strncpy0(POSITION,rohlager.position.SPosition().c_str(),sizeof(POSITION));
  rohlager.datum.write_postgres(DATUM,sizeof DATUM);

  exec sql select true into :DUMMY from rl_inhalt where position_= :POSITION;
  SQLerror::test(__FILELINE__,100);
  if (sqlca.sqlcode==100) // nichts drin
   {
     os+="An Position " +rohlager.position.SPosition()+" steht nichts mehr.";
     return false;
   }

  st_rohlager was_ist_drin = RL_Inhalt(rohlager.position);
  
  if(!force)
   {
     if(was_ist_drin.artikel!=rohlager.artikel)
      {
        os+="Auf "+rohlager.position.SPosition()+" steht "
           +cH_ArtikelBezeichnung(was_ist_drin.artikel)->Bezeichnung() 
           +" vom "+was_ist_drin.datum.c_str()
           +" ("+was_ist_drin.Menge_als_Text()+")\n";
        return false;
      }
     if (ist_leer && (was_ist_drin.kartons!=rohlager.kartons ||
                     was_ist_drin.reste!=rohlager.reste ||
                      was_ist_drin.reste_kg!=rohlager.reste_kg))
     {
         os+="Info: Auf " + rohlager.position.SPosition()
            +" standen noch "+was_ist_drin.Menge_als_Text()+'\n';
     }
     else if(!ist_leer && (was_ist_drin.kartons<rohlager.kartons ||
                     was_ist_drin.reste<rohlager.reste ||
                      was_ist_drin.reste_kg<rohlager.reste_kg))
     {  os+="Info: Auf "+rohlager.position.SPosition()
            +" standen nur noch "+was_ist_drin.Menge_als_Text() + '\n';
     }
    }
   else // force
       {
         os+="Info: Auf "+rohlager.position.SPosition() + " stand "
           +cH_ArtikelBezeichnung(was_ist_drin.artikel)->Bezeichnung() 
           +" vom "+was_ist_drin.datum.c_str()
           +" ("+was_ist_drin.Menge_als_Text()+")\n";
       }

  std::string misc;
  if(ist_leer || force)
    {
      exec sql delete from rl_inhalt where position_= :POSITION;
      SQLerror::test(__FILELINE__);                  
      if(force) misc="lösc";
      else misc="leer";
      rohlager=was_ist_drin;
    }  
  else 
    {
      rohlager.kg_pro_karton=was_ist_drin.kg_pro_karton;
      KARTONS=was_ist_drin.kartons-rohlager.kartons;
      if (KARTONS<0) 
      { KARTONS=0; rohlager.kartons=was_ist_drin.kartons; }
      RESTE=was_ist_drin.reste-rohlager.reste;
      if (RESTE<0) 
      { RESTE=0; rohlager.reste=was_ist_drin.reste; }
      RESTE_KG=was_ist_drin.reste_kg-rohlager.reste_kg; ;   
      if (RESTE_KG<0) 
      { RESTE_KG=0; rohlager.reste_kg=was_ist_drin.reste_kg; }

      exec sql update rl_inhalt set kartons= :KARTONS, reste= :RESTE,
          rest_kg=:RESTE_KG, letzte_entnahme= :DATUM 
          where position_= :POSITION;
       SQLerror::test(__FILELINE__);                  
    }

   raus_aus_lager(rohlager.artikel,rohlager.Menge_fuer_Auftrag(),uid,fuer_auftrag);
   RL_Log(rohlager,RLEntnehmen,uid,misc);

   tr.commit();
   return true;
}

void RohwarenLager::RL_Einlagern_real(st_rohlager& rohlager,unsigned uid,bool geliefert)
{  if (geliefert) rein_ins_lager(rohlager.artikel,rohlager.Menge_fuer_Auftrag(),uid,true);
   else wiedereinlagern(rohlager.artikel,rohlager.Menge_fuer_Auftrag(),uid);
   RL_Log(rohlager,RLEinlagern,uid);
}

bool RohwarenLager::RL_Einlagern(const LagerPlatz position,st_rohlager& rohlager,const int uid,std::string &os,bool force,bool geliefert)
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,
  	NV("kartons",rohlager.kartons),NV("reste",rohlager.reste),
  	NV("artikel",rohlager.artikel.Id()),
  	NV("position",position.SPosition()));
  Transaction tr;
  rohlager.setPosition(position);

  exec sql begin declare section;
   int KARTONS=rohlager.kartons;
   int KG_PER_KARTON=rohlager.kg_pro_karton;
   int RESTE=rohlager.reste;
   int RESTE_KG=rohlager.reste_kg;
   int MATERIAL=rohlager.artikel.Id();
   char POSITION[5];
   char DATUM[11];
   bool DUMMY;
  exec sql end declare section;
  strncpy0(POSITION,rohlager.position.SPosition().c_str(),sizeof(POSITION));
  rohlager.datum.write_postgres(DATUM,sizeof DATUM);

  exec sql select true into :DUMMY from rl_inhalt where position_= :POSITION;
  SQLerror::test(__FILELINE__,100);
  if (sqlca.sqlcode==100) // nichts drin also rein damit
   {
      exec sql insert into rl_inhalt
        (position_, kartons, MATERIAL, KG_PER_KARTON,
              reste, rest_kg, eingelagert)
        values (:POSITION, :KARTONS, :MATERIAL, :KG_PER_KARTON,
              nullif(:RESTE,0), nullif(:RESTE_KG,0), :DATUM);
      SQLerror::test(__FILELINE__);
      RL_Einlagern_real(rohlager,uid,geliefert);
      tr.commit();
      return true;
   }
  else  // ups, auf dieser Position liegt schon etwas
   {
     st_rohlager was_ist_drin = RL_Inhalt(rohlager.position);
     if(force) // überschreiben, ohne Rücksicht auf Material
      { // wird nicht als Verbrauch gerechnet
        RL_Entnahme(was_ist_drin,uid,os,true,true,false);
        if (!os.empty()) os+='\n';
        tr.close();
        tr.open(); // neue Transaktion beginnen
        exec sql update rl_inhalt set 
           kartons=:KARTONS, material=:MATERIAL, 
           kg_per_karton=:KG_PER_KARTON, reste=nullif(:RESTE,0), 
           rest_kg=nullif(:RESTE_KG,0), eingelagert=:DATUM where position_=:POSITION;
        SQLerror::test(__FILELINE__);
        RL_Einlagern_real(rohlager,uid,geliefert);
        tr.commit();
        return true;
      }
     else // mal schauen ...
      {
        if(was_ist_drin.artikel==rohlager.artikel)
         {
           if (!was_ist_drin.kg_pro_karton) was_ist_drin.kg_pro_karton=rohlager.kg_pro_karton;
           if (!rohlager.kg_pro_karton) rohlager.kg_pro_karton=was_ist_drin.kg_pro_karton;
             // gleicher Artikel, gleiche Paketgröße also
             // neue Menge zu alter Menge hinzuaddieren und rein damit
           if (rohlager.kg_pro_karton==was_ist_drin.kg_pro_karton)
            {
              KARTONS = rohlager.kartons + was_ist_drin.kartons;
              KG_PER_KARTON=rohlager.kg_pro_karton;
              RESTE=rohlager.reste + was_ist_drin.reste;
              RESTE_KG=rohlager.reste_kg + was_ist_drin.reste_kg;    
              exec sql update rl_inhalt set 
                 kartons=:KARTONS, material=:MATERIAL,
                  kg_per_karton=:KG_PER_KARTON, 
                       reste=nullif(:RESTE,0), rest_kg=nullif(:RESTE_KG,0),
                        eingelagert=:DATUM where position_=:POSITION;
              SQLerror::test(__FILELINE__);
              RL_Einlagern_real(rohlager,uid,geliefert);
              tr.commit();
              return true;
            }
           else 
            {
              os = "  an Position " + rohlager.position.SPosition() + " sollen "
                + itos(was_ist_drin.kg_pro_karton) + "kg "
                +  cH_ArtikelBezeichnung(was_ist_drin.artikel)->Bezeichnung()
                +  " im Karton sein.\n";
              return false;
            }
         }
        else // Die Materiaien stimmen nicht überein
         {
           os ="  an Position " +rohlager.position.SPosition()+" befindet sich "
            + cH_ArtikelBezeichnung(was_ist_drin.artikel)->Bezeichnung() + " vom "
            + was_ist_drin.datum.c_str() + " ("+itos(was_ist_drin.kartons)+"K.à "
            + itos(was_ist_drin.kg_pro_karton)+ "kg " +itos(was_ist_drin.reste)+ "R.="
            + itos(was_ist_drin.reste_kg) + "kg)\n";
           return false;
         }
      }  
   }
 assert(!" RohwarenLager::RL_Einlagern: Fehler");
}

void RohwarenLager::RL_Log(const st_rohlager& rohlager,RL_LogTyp typ,const int uid,const std::string& misc)
{
  exec sql begin declare section;
   int KARTONS=rohlager.kartons;
   int KG_PER_KARTON=rohlager.kg_pro_karton;
   int RESTE=rohlager.reste;
   int RESTE_KG=rohlager.reste_kg;
   int MATERIAL=rohlager.artikel.Id();
   char MISC[5];
   char POSITION[5];
   char DATUM[11];
   char TYP=typ;
  exec sql end declare section;
  strncpy0(POSITION,rohlager.position.SPosition().c_str(),sizeof(POSITION));
  strncpy0(MISC,misc.c_str(),sizeof(MISC));

  rohlager.datum.write_postgres(DATUM,sizeof DATUM);
  exec sql insert into rl_log 
       (zeit,position_, kartons, MATERIAL, KG_PER_KARTON, typ, valuta, reste, rest_kg,misc)
       values (now(),:POSITION,:KARTONS,:MATERIAL,:KG_PER_KARTON,:TYP,:DATUM,
            :RESTE,:RESTE_KG,nullif(:MISC,''));
  SQLerror::test(__FILELINE__);
}


RohwarenLager::st_rohlager RohwarenLager::RL_Inhalt(const LagerPlatz position) const
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__);
  exec sql begin declare section;
   int KARTONS, KG_PER_KARTON, RESTE, RESTE_KG, MATERIAL;
   char POSITION[5];
   char DATUM[11];
  exec sql end declare section;
  strncpy(POSITION,position.SPosition().c_str(),5);
  exec sql select coalesce(kartons,0), coalesce(reste,0),
      int4(coalesce(kg_per_karton,0)), int4(coalesce(rest_kg,0)),
      material, eingelagert into :KARTONS, :RESTE, 
            :KG_PER_KARTON, :RESTE_KG, :MATERIAL, :DATUM
      from rl_inhalt where position_= :POSITION;
  SQLerror::test(__FILELINE__,100);
  ManuProC::Datum date; 
  if(sqlca.sqlcode)
   {
     return st_rohlager(position,0,0,0,0, ArtikelBase(0),date);
   }
  else 
   {
     date.from_postgres(DATUM);
     return st_rohlager(position,KARTONS,KG_PER_KARTON,RESTE,RESTE_KG,
                  ArtikelBase(MATERIAL),date);
   }
}  

std::vector<class LagerInhalt> RohwarenLager::LagerInhalt_(const ArtikelBase& artikel) const
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__);
  exec sql begin declare section;
   int KG, RESTE_KG, MATERIAL,KARTONS,RESTKARTONS;
   char QUERY[1024];
  exec sql end declare section;

  std::string squery ="select material,coalesce(kartons,0),coalesce(reste,0), "
      " coalesce(int4(sum(kartons*kg_per_karton)),0),"
      " coalesce(int4(sum(coalesce(rest_kg,0))),0) "
      " from rl_inhalt ";
  if(artikel.valid()) squery += " where material ="+itos(artikel.Id());
  squery +=" group by material,kartons,reste ";

  strncpy(QUERY,squery.c_str(),sizeof(QUERY));
  exec sql prepare r_summe_ from :QUERY;
  exec sql declare r_summe cursor for r_summe_;
  Transaction tr;
  exec sql open r_summe;
  SQLerror::test(__FILELINE__);
  std::vector<class LagerInhalt> V;
  while(true)
   {
     exec sql fetch r_summe into :MATERIAL,:KARTONS,:RESTKARTONS,:KG,:RESTE_KG;
     SQLerror::test(__FILELINE__,100);
     if(sqlca.sqlcode) break;
     V.push_back(class LagerInhalt(ArtikelBase(MATERIAL),KARTONS,RESTKARTONS,KG,RESTE_KG));
   }
 return V;
}
