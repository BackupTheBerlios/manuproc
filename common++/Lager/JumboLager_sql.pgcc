/*  pps: ManuProC's production planning system
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "JumboLager.h"
#include <Artikel/ArtikelBase.h>
#include <Artikel/ArtikelBezeichnung.h>
#include <Aux/Datum.h>
#include <Aux/string0.h>
exec sql include sqlca;
#include <Aux/SQLerror.h>
#include <Aux/Transaction.h>
#include <Aux/itos.h>
#include <unistd.h>
#include <Misc/Trace.h>


void JumboLager::Jumbo_Einlagern(const LagerPlatz position,JumboRolle& jumbo,Jumbo_LogTyp typ,
   const int uid,const std::string& user,const Zeitpunkt_new *zeit)
{
  ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__);
  Transaction tr;
  Zeitpunkt_new zeit_local_storage;
  exec sql begin declare section;
    int CODE=jumbo.Code()/10;
    int STATUS;
    int LAGERPLATZ=position.IPosition();
    bool REST;
    bool DUMMY;   
    char ZEIT[32];
  exec sql end declare section;
  REST = (typ==Rest || typ==Rest_L);
  STATUS=JumboRolle::ImLager;

  if (zeit) zeit->write(PostgresTimestamp(ZEIT,sizeof ZEIT));
  else 
  {  exec sql select now() into :ZEIT;
     SQLerror::test("select now",true);
     zeit_local_storage=Zeitpunkt_new(ZEIT);
     zeit=&zeit_local_storage;
  }

  if (jumbo.VerarbDatum().valid() &&  *zeit<jumbo.VerarbDatum()) 
   { STATUS=JumboRolle::Verarbeitet;
     LAGERPLATZ=0;
   }

  exec sql select true into :DUMMY from rohjumbo where code= :CODE;
  SQLerror::test(__FILELINE__,100);
  if (sqlca.sqlcode==100)
   {
     exec sql insert into rohjumbo 
            (code,maschine,webmaschine,soll_meter,plan_datum,verarb_datum,
             status,lauf,gang,barcoist,barcofert_datum,wiederinslager,
             artikelid)
      select code,maschine,webmaschine,soll_meter,plan_datum,verarb_datum,
             status,lauf,gang,barcoist,barcofert_datum,wiederinslager,
             artikelid
            from rohjumbo_archiv where code=:CODE;
     SQLerror::test("JumboRolle::buchen archiv-kopie",100);
     if (sqlca.sqlcode==100)
         throw SQLerror("JumboRolle::buchen",100,"Rolle nicht im Archiv");
     exec sql delete from rohjumbo_archiv where code=:CODE;
     SQLerror::test("JumboRolle::buchen archiv-löschen",100);
   }
  exec sql update rohjumbo
       set wiederinslager=:ZEIT,rest= :REST,status=:STATUS ,
             lagerplatz=nullif(:LAGERPLATZ,0)
           where code= :CODE;
  SQLerror::test("LagerSQL einlagern");

  jumbo.setLagerPosition_nodb(position);
  jumbo.setInsLager_nodb(*zeit);
  if(jumbo.getStatus()==JumboRolle::ImLager) typ=Umraeumen;
  jumbo.setStatus_nodb(JumboRolle::Jumbo_Status(STATUS));
  if(typ!=Umraeumen && STATUS=JumboRolle::ImLager)
     rein_ins_lager(jumbo.Artikel(),jumbo.Meter(),uid);
  Jumbo_Log(jumbo,typ,uid,user,zeit);
  tr.commit();
}

void JumboLager::Jumbo_Entnahme(JumboRolle& jumbo,Jumbo_LogTyp typ,
   const int uid,const std::string& user,const Zeitpunkt_new *zeit)
{  
  ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__);
  Transaction tr;
  Zeitpunkt_new zeit_local_storage;
  exec sql begin declare section;
    int CODE=jumbo.Code()/10;
    int STATUS;
    char ZEIT[32];
    int LAGERPLATZ=jumbo.LagerPosition().IPosition();
  exec sql end declare section;
  bool throw100=false;
  STATUS=JumboRolle::Verarbeitet;

  if (zeit) zeit->write(PostgresTimestamp(ZEIT,sizeof ZEIT));
  else 
  {  exec sql select now() into :ZEIT;
     SQLerror::test("select now",true);
     zeit_local_storage=Zeitpunkt_new(ZEIT);
     zeit=&zeit_local_storage;
  }

  if (jumbo.InsLagerDatum().valid() && *zeit<jumbo.InsLagerDatum()) 
     STATUS=JumboRolle::ImLager;
  else 
  {  LAGERPLATZ=0;
     if (jumbo.VerarbDatum().valid() && jumbo.VerarbDatum()<*zeit)
     {  Zeitpunkt_new old=jumbo.VerarbDatum(),
     		      newzt=*zeit;
        old.Precision(Zeitpunkt_new::seconds);
        newzt.Precision(Zeitpunkt_new::seconds);
        // 5 minuten
        if (newzt-old<300) throw100=true;
     }
  }
  
  exec sql update rohjumbo set verarb_datum=:ZEIT, status=:STATUS,
  		lagerplatz=nullif(:LAGERPLATZ,0)
      where code= :CODE;  
  SQLerror::test("JumboRolle::buchen entnahme");

#if defined PETIG_EXTENSIONS && defined MANUPROC_DYNAMICENUMS_CREATED
  jumbo.setLagerPosition_nodb(LagerPlatz(ppsInstanzID::Bandlager,LAGERPLATZ));
#endif
  jumbo.setVerarbDatum_nodb(*zeit);
  if (jumbo.getStatus()==JumboRolle::Verarbeitet) typ=SchonDraussen;
  jumbo.setStatus_nodb(JumboRolle::Jumbo_Status(STATUS));
  if(typ!=SchonDraussen && STATUS==JumboRolle::Verarbeitet)
     raus_aus_lager(jumbo.Artikel(),jumbo.Meter(),uid);
  Jumbo_Log(jumbo,typ,uid,user,zeit);
  // hupen
  if (throw100) throw SQLerror("Entnahme",100,"Rolle schon erfasst");
  tr.commit();
}

void JumboLager::Jumbo_Log(const JumboRolle& jumbo,Jumbo_LogTyp typ,const int uid,const std::string& user,const Zeitpunkt_new *zeit)
{
  ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__);
  exec sql begin declare section;
   int CODE=jumbo.Code()/10;
   char ACTION=typ;
   char NAME[5];
   char ZEIT[32];
   int POSITION=jumbo.LagerPosition().IPosition();
  exec sql end declare section;
  if (zeit) zeit->write(PostgresTimestamp(ZEIT,sizeof ZEIT));
  else strncpy0(ZEIT,"now",sizeof ZEIT);
  strncpy0(NAME,user.c_str(),sizeof(NAME));
  exec sql  insert into lager_bewegung 
      (code,action,name,lagerplatz,zeit) 
      values (:CODE,:ACTION,:NAME,:POSITION, :ZEIT);  
} 

std::vector<class LagerInhalt> JumboLager::LagerInhalt_(const ArtikelBase& artikel) const
{
  ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__);
  exec sql begin declare section;
    int ID,ROLLEN,RESTROLLEN,METER,RESTMETER;
    char QUERY[1024];
  exec sql end declare section;

  std::string squery = "select coalesce(artikelid,0),"
         " sum(case rest when true then 0 else 1 end),"
         " sum(case rest when true then 1 else 0 end),"
         " sum(coalesce(barcoist,soll_meter,0) * (case rest when true then 0 else 1 end)),"
         " sum(coalesce(barcoist,soll_meter,0) * (case rest when true then 1 else 0 end))"
         " from rohjumbo where status="+itos(JumboRolle::ImLager)+
         " and lagerplatz is not null";
  if(artikel.valid()) squery += " and artikelid ="+itos(artikel.Id());
  squery += " group by artikelid";
  strncpy(QUERY,squery.c_str(),sizeof(QUERY));
//cout << QUERY<<'\n';
  exec sql prepare summe_cursor_ from :QUERY;
  exec sql declare summe_cursor cursor for summe_cursor_;
  Transaction tr;  
  exec sql open summe_cursor;
  SQLerror::test(__FILELINE__);
  std::vector<class LagerInhalt> V;
  while(true)
   {
    exec sql fetch summe_cursor into :ID,:ROLLEN,:RESTROLLEN,:METER,:RESTMETER;
    SQLerror::test(__FILELINE__,100);  
    if (sqlca.sqlcode) break;
    V.push_back(class LagerInhalt(ID,ROLLEN,RESTROLLEN,METER,RESTMETER*reste_faktor));    
   }
  exec sql close summe_cursor;
  tr.close();
  return V;
}
