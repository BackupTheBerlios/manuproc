// $Id: AufEintragZu_sql.pgcc,v 1.9 2002/10/24 14:06:49 thoma Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/AufEintragZu.h>
#include <Aux/Transaction.h>
#include <Auftrag/auftrag_status.h>
#include <Auftrag/AuftragsBaum.h> 
#include <Aux/Changejournal.h>
#include <Artikel/ArtikelStamm.h>
#include <Artikel/ArtikelBezeichnung.h>
#include <Aux/FetchIStream.h>
#include <Aux/Trace.h>

exec sql include sqlca;


std::list<AufEintragZu::st_reflist> AufEintragZu::get_Referenz_list(const AufEintragBase& aeb,bool kinder) const throw(SQLerror) 
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,*this,aeb,"Kinder="+itos(kinder));
 exec sql begin declare section;
  int INSTANZ[30],AUFTRAGID[30],ZEILENNR[30];
  double MENGE[30];
  int ARTIKEL[30];
  char query[1024];
 exec sql end declare section;
 Transaction tr;
 std::string squery;
 if(kinder)
    squery = "select neuauftragid,neuinstanz,neuzeilennr,menge,artikelid "
      "from auftragsentryzuordnung "
      "join auftragentry on (neuinstanz,neuauftragid,neuzeilennr)"
         "= (instanz,auftragid,zeilennr)"
      "where (altinstanz,altauftragid,altzeilennr) = "
      "("+itos(aeb.InstanzID())+","+itos(aeb.Id())+","+itos(aeb.ZNr())+")";
 else
    squery = "select altauftragid,altinstanz,altzeilennr,menge,artikelid "
      "from auftragsentryzuordnung "
      "join auftragentry on (altinstanz,altauftragid,altzeilennr)"
         "= (instanz,auftragid,zeilennr)"
      "where (neuinstanz,neuauftragid,neuzeilennr) = "
       "("+itos(aeb.InstanzID())+","+itos(aeb.Id())+","+itos(aeb.ZNr())+")";
 strncpy(query,squery.c_str(),sizeof(query));
 exec sql prepare ONAUF_ from :query;
//std::cout << query<<"\n\n\n";
 exec sql declare ONAUF cursor for ONAUF_;
 exec sql open ONAUF;
 std::list<st_reflist> vaeb;
 while(true)
  {
    exec sql fetch 30 in ONAUF into :AUFTRAGID,:INSTANZ,:ZEILENNR,:MENGE,:ARTIKEL;
    SQLerror::test(__FILELINE__,100);
    if (sqlca.sqlcode) break;
    int j=sqlca.sqlerrd[2];
    for (int i=0;i<j;++i)
     {
      vaeb.push_back(st_reflist(
         AufEintragBase(cH_ppsInstanz((ppsInstanz::ID)INSTANZ[i]),
             AUFTRAGID[i],ZEILENNR[i]),ARTIKEL[i],MENGE[i]));
     }
    if(j<30) break;
  }
 exec sql close ONAUF;
 tr.close();
 return vaeb;
}


std::list<AufEintragZu::st_reflist> AufEintragZu::get_Referenz_list_id(const int id,bool kinder) const throw(SQLerror)
{
   ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,*this,"Id="+itos(id),"Kinder="+itos(kinder));
   std::list<st_reflist> L=get_Referenz_list(AEB,kinder);
   std::list<st_reflist> N;
   for(std::list<AufEintragZu::st_reflist>::const_iterator i=L.begin();i!=L.end();++i)
     {
       if(i->AEB.Id()==id) N.push_back(*i);
     }
   return N;
}

std::list<AufEintragZu::st_reflist> AufEintragZu::get_Referenz_list_geplant(bool kinder) const throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,*this,"Kinder="+itos(kinder));

 if(Instanz()->LagerInstanz())
     return get_Referenz_list_id(AuftragBase::plan_auftrag_id,kinder);

 std::list<st_reflist> L=get_Referenz_list(AEB,kinder);
 std::list<st_reflist> N;
 for(std::list<AufEintragZu::st_reflist>::const_iterator i=L.begin();i!=L.end();++i)
   {
     if(i->AEB.Id()!=AuftragBase::dispo_auftrag_id &&
        i->AEB.Id()!=AuftragBase::plan_auftrag_id &&
        i->AEB.Id()!=AuftragBase::ungeplante_id &&
        i->AEB.Id()!=AuftragBase::invalid_id ) 
       N.push_back(*i);
   }
 return N;
}
      


std::list<AufEintragZu::st_reflist> AufEintragZu::get_Referenz_listFull(bool kinder,bool nur_ende) const throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,*this,"Kinder="+itos(kinder),"NurEnde="+itos(nur_ende));
 std::list<st_reflist> tv=get_Referenz_list(AEB,kinder);
 std::list<st_reflist> vaeb;
 std::list<st_reflist> tvxx;
reloop:
 tv.splice(tv.end(),tvxx);
 for (std::list<st_reflist>::iterator i=tv.begin();i!=tv.end();++i)
   {
     tvxx=get_Referenz_list(i->AEB,kinder);
     if(nur_ende)
      {
        if (tvxx.empty()) vaeb.splice(vaeb.end(),tv,i) ;
        else tv.erase(i) ; 
      }
     else vaeb.splice(vaeb.end(),tv,i) ;
     goto reloop;
   }
 return vaeb;
}


std::list<AufEintragZu::st_reflist> AufEintragZu::get_Referenz_list_for_geplant(bool kinder) const throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,*this,"Kinder="+itos(kinder));
//cout << AEB.Instanz()->Name()<<' '<<AEB.Id()<<' '<<AEB.ZNr()<<'\n';
  // Ungeplante Referenz Aufträge
  std::list<st_reflist> URA=get_Referenz_list(AEB,false);
 //NEU
  std::list<st_reflist> L;
  for(std::list<st_reflist>::const_iterator i=URA.begin();i!=URA.end();++i)
   {
     std::list<st_reflist> l=AufEintragZu(i->AEB).get_Referenz_list(i->AEB,kinder);
     if(kinder) // sich selber aus der Liste entfernen
        for (std::list<st_reflist>::iterator j=l.begin();j!=l.end();++j)
           if(j->AEB==AEB) {L.erase(j); break;}
     L.merge(l);
   }
  return L; 
}


std::list<cH_Kunde> AufEintragZu::get_Referenz_Kunden() const throw(SQLerror)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,*this);
 std::list<cH_Kunde> LK;
 std::list<st_reflist> vaeb = get_Referenz_listFull(false);
 exec sql begin declare section;
  int KUNDE;
  int INSTANZ;
  int AUFTRAGID;
 exec sql end declare section;
 for (std::list<st_reflist>::const_iterator i=vaeb.begin();i!=vaeb.end();++i)
  {
    INSTANZ=i->AEB.InstanzID();
    AUFTRAGID=i->AEB.Id();
    exec sql select kundennr into :KUNDE from auftrag where
      (instanz,auftragid)=(:INSTANZ,:AUFTRAGID); 
    SQLerror::test(__FILELINE__);
    LK.push_back(cH_Kunde(KUNDE));
  }
 LK.sort();
 LK.unique();
 return LK;
}

std::list<AufEintragBase> AufEintragZu::get_AufEintragList_from_Artikel
               (const ArtikelBase& artikel,ppsInstanz::ID instanz,AufStatVal status)
{
  ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,"Artikel="+cH_ArtikelBezeichnung(artikel)->Bezeichnung(),"Status="+itos(status),"Instanz="+cH_ppsInstanz(instanz)->Name());
  std::list<AufEintragBase> L;
  exec sql begin declare section;
   char query[1024];
   int db_auftragid,db_zeilennr;
  exec sql end declare section;
  std::string squery = "select auftragid,zeilennr from auftragentry "
      "where artikelid="+itos(artikel.Id()) +
      " and instanz!="+itos(ppsInstanzID::Kundenauftraege) //Nur interne Aufträge sind interessant
      +" and auftragid=0"; // Nur die UNGEPLANTEN Aufträge bekommen neue Kinder
  if(status!=NOSTAT) squery += " and status="+itos(status);
  strncpy(query,squery.c_str(),sizeof(query));
  Transaction tr;
  exec sql prepare AELfAein_ from :query ;
  exec sql declare AELfAein cursor for AELfAein_ ;

  exec sql open AELfAein;
  SQLerror::test(__FILELINE__);
  while(true)
   {
     exec sql fetch AELfAein into :db_auftragid,:db_zeilennr;
     SQLerror::test(__FILELINE__,100);
     if (sqlca.sqlcode) break;
     L.push_back(AufEintragBase(instanz,db_auftragid,db_zeilennr));
//std::cout << "Liste: "<<I->Name()<<' '<<db_auftragid<<' '<<db_zeilennr<<'\n';
   }  
  return L;
}

void AufEintragZu::Neu(const AufEintragBase& neuAEB,
                       const mengen_t menge,const int oldZnr)
{
  ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,*this,"Menge="+dtos(menge),"OldZNr="+itos(oldZnr));

//ECPGdebug(true,stdout);
 exec sql begin declare section;
  int db_aaid=AEB.Id();
  int db_ains=AEB.InstanzID();
  int db_aznr=AEB.ZNr();
  double db_menge=menge;
  int db_naid=neuAEB.Id();
  int db_nins=neuAEB.InstanzID();
  int db_nznr=neuAEB.ZNr();
 exec sql end declare section;
 if(oldZnr!=0) db_aznr=oldZnr;
 try{ mengen_t mt=setMengeDiff__(neuAEB,menge); 
      assert(menge==mt);
    }
 catch (SQLerror &e)
 {
 exec sql insert into auftragsentryzuordnung
   (altinstanz,altauftragid,altzeilennr, menge, neuinstanz,neuauftragid,neuzeilennr) values
   (:db_ains,:db_aaid,:db_aznr, :db_menge, :db_nins,:db_naid,:db_nznr);
 SQLerror::test(__FILELINE__);
 }
//ECPGdebug(false,0);
}

#include <Aux/itos.h>

bool AufEintragZu::setMenge(const AufEintragBase& neuAEB,const mengen_t menge)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,*this,neuAEB,"Menge="+dtos(menge));
 exec sql begin declare section;
  int db_aaid=AEB.Id();
  int db_ains=AEB.InstanzID();
  int db_aznr=AEB.ZNr();
  double db_menge=menge;
  int db_naid=neuAEB.Id();
  int db_nins=neuAEB.InstanzID();
  int db_nznr=neuAEB.ZNr();
 exec sql end declare section;
 exec sql update auftragsentryzuordnung
   set menge=:db_menge where
   (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid,neuzeilennr)
    = (:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid,:db_nznr);
 SQLerror::test(__FILELINE__,100);
 if (sqlca.sqlcode) return false;
 else return true;
}


AuftragBase::mengen_t AufEintragZu::setMengeDiff__(const AufEintragBase &neuAEB,const mengen_t menge)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,*this,neuAEB,"Menge="+dtos(menge));
 exec sql begin declare section;
  int db_aaid=AEB.Id();
  int db_ains=AEB.InstanzID();
  int db_aznr=AEB.ZNr();
  double db_menge=menge;
  int db_naid=neuAEB.Id();
  int db_nins=neuAEB.InstanzID();
  int db_nznr=neuAEB.ZNr();
  double db_oldmenge;
 exec sql end declare section;
 if(menge<0)
  {
   exec sql select menge into :db_oldmenge from auftragsentryzuordnung where 
      (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid,neuzeilennr)
       = (:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid,:db_nznr);
   SQLerror::test(__FILELINE__);
   if(db_oldmenge<-menge)
     {
       db_menge=-db_oldmenge;
     }
  } 
//ECPGdebug(true,stdout);
 exec sql update auftragsentryzuordnung
   set menge=menge+:db_menge where
   (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid,neuzeilennr)
    = (:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid,:db_nznr);
 SQLerror::test(__FILELINE__);
//ECPGdebug(false,0);
 return db_menge;
}


bool AufEintragZu::setKindZnr(const AufEintragBase& neuAEB)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,*this,neuAEB);
 exec sql begin declare section;
  int db_aaid=AEB.Id();
  int db_ains=AEB.InstanzID();
  int db_aznr=AEB.ZNr();
  int db_naid=neuAEB.Id();
  int db_nins=neuAEB.InstanzID();
  int db_nznr=neuAEB.ZNr();
 exec sql end declare section;
 exec sql update auftragsentryzuordnung
   set neuzeilennr=:db_nznr where
   (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid)
    = (:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid);
 SQLerror::test(__FILELINE__,100);
 if (sqlca.sqlcode) return false;
 else return true;
}

void AufEintragZu::moveInstanz(const VonNachDel vdl,const AufEintragBase &oldAEB, const AufEintragBase &newAEB) throw(SQLerror)
{

 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,oldAEB,"VonNachDel="+itos(vdl));
 exec sql begin declare section;
  int db_aaid=oldAEB.Id();
  int db_ains=oldAEB.Instanz()->Id();
  int db_aznr=oldAEB.ZNr();
  int db_naid=newAEB.Id();
  int db_nins=newAEB.Instanz()->Id();
  int db_nznr=newAEB.ZNr();
 exec sql end declare section;

 switch(vdl)
  {
   case Von:
    exec sql update auftragsentryzuordnung set 
      altauftragid=:db_naid, altinstanz=:db_nins, altzeilennr=:db_nznr where
      (altinstanz,altauftragid,altzeilennr)=(:db_ains,:db_aaid,:db_aznr);
    break;
   case Nach:
    exec sql update auftragsentryzuordnung set 
      neuauftragid=:db_naid, neuinstanz=:db_nins, neuzeilennr=:db_nznr where
      (neuinstanz,neuauftragid,neuzeilennr)=(:db_ains,:db_aaid,:db_aznr);
    break;
   case Delete:
    exec sql delete from auftragsentryzuordnung where
      (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid,neuzeilennr)
     =(:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid,:db_nznr);
    break;
  }
 SQLerror::test(__FILELINE__,100);
}


bool AufEintragZu::remove(const AufEintragBase& alt,const AufEintragBase& neu)
{
  ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,alt,neu);

  std::string Q="delete from auftragsentryzuordnung where "
                 "(altinstanz,altauftragid,altzeilennr,"
                 "neuinstanz,neuauftragid,neuzeilennr)=("
                 +itos(alt.Instanz()->Id())+","+itos(alt.Id())+","+itos(alt.ZNr())+","
                 +itos(neu.Instanz()->Id())+","+itos(neu.Id())+","+itos(neu.ZNr())+")";
 Query::Execute(Q);
 SQLerror::test(__FILELINE__,100);
 if(sqlca.sqlcode) return false;
 return true;
}

AuftragBase::mengen_t AufEintragZu::getMenge(const AufEintragBase& aeb) const
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,*this,aeb);
 exec sql begin declare section;
  int db_aaid=AEB.Id();
  int db_ains=AEB.InstanzID();
  int db_aznr=AEB.ZNr();
  int db_naid=aeb.Id();
  int db_nins=aeb.InstanzID();
  int db_nznr=aeb.ZNr();
  int db_menge;   
 exec sql end declare section;
 exec sql select menge into :db_menge from auftragsentryzuordnung
   where
   (altinstanz,altauftragid,altzeilennr, neuinstanz,neuauftragid,neuzeilennr)
    = (:db_ains,:db_aaid,:db_aznr, :db_nins,:db_naid,:db_nznr);
 SQLerror::test(__FILELINE__);
 return db_menge;
}

AuftragBase::mengen_t AufEintragZu::verteileMenge(std::list<st_reflist> L, mengen_t menge,bool add)
{
 ManuProC::Trace _t(ManuProC::Tracer::Auftrag, __FUNCTION__,*this,"Menge="+dtos(menge),"Add="+itos(add));
  for(std::list<st_reflist>::const_iterator i=L.begin();i!=L.end();++i)
   {
     if(menge==AuftragBase::mengen_t(0)) return menge;
     AuftragBase::mengen_t M;
     if(i->Menge >= menge) M=menge;
     else M=i->Menge;
     if(add)  setMengeDiff__(i->AEB,M)  ;
     else     setMengeDiff__(i->AEB,-M) ;
     menge-=M;
   }
  if(menge!=AuftragBase::mengen_t(0)) 
      std::cerr << "WARNING: 'AufEintragZu::verteileMenge' Restmenge = "<<menge<<'\n';
  return menge;
}


