/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 2002 Adolf Petig GmbH & Co. KG
 *  written by Jacek Jakubowski, Christof Petig, Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */


#include <Kunde/PreisListeFull.h>
#include <Misc/itos.h>
#include <Misc/Transaction.h>
#include <ExtBezSchema/ExtBezSchemaHandle.h>
#include <ExtBezSchema/ExtBezSchema.h>

void PreisListeFull::load_preisliste(bool with_artbez,
	ID id, bool art_in_list, ArtikelTyp at)
{
 std::string bezkomps;
 std::string beztable;
 int signifikanz=1;
 cH_ExtBezSchema ebz(ExtBezSchema::default_id,at);
 if(with_artbez)
   {
    ExtBezSchema::const_sigiterator bezit=ebz->sigbegin(signifikanz);
    ExtBezSchema::const_sigiterator bezend=ebz->sigend(signifikanz);    
    for(;bezit!=bezend;++bezit)
      bezkomps+=" b."+(*bezit).spaltenname+",";
    beztable = " artbez_"+itos(at)+"_"+itos(ebz->Id());
   }

 std::string qu;
 payoff.erase(payoff.begin(),payoff.end());

 
 std::string plid=itos(id);

 if(art_in_list)
   {qu=std::string("select ");
	if(with_artbez)
          qu+=bezkomps;
	qu+=" artikelid,preis,preismenge,coalesce(mindestmenge,1) from artikelpreise p"
 	" join artikelstamm s on (p.artikelid=s.id and "
	" s.warengruppe="+itos(at.Id())+") ";
    if(with_artbez)
      qu+=" join "+beztable+" b using (id) ";
    qu+=" where  kundennr = "+plid;
   }
 else
   {
    qu=std::string("select ");
    if(with_artbez)
      qu+=bezkomps;
    qu+=" id,coalesce(preis_alt,0),0,"
	" coalesce(c.mindestmenge,1) from artikelstamm s "
	" left join preis_change_journal c on "
	" (c.artikelid=s.id and c.prlsnr="+plid;
    qu+=" and preis_alt is not null and cast(preis_neu as float) = 0.0) ";
    if(with_artbez)
      qu+=" join "+beztable+" b using (id) ";
    qu+=" where not exists"
 	" (select p.artikelid from artikelpreise p"
	"  where p.artikelid=s.id and kundennr = ";
    qu+=plid+") and s.warengruppe="+itos(at.Id())+" order by zeitpunkt";
   }
 
 Query q(qu);

 FetchIStream is=q.Fetch();

 while(is.good())
   {
    int ARTIKELID;
    float PREIS;
    int PREISMENGE;
    int MINDMENGE;
    std::string beztext;
    struct PayOff po;
    
    if(with_artbez)
      {
       for(unsigned int i=0; i<ebz->size(signifikanz); i++)
         {is >> FetchIStream::MapNull(beztext);
          po.b.push_back(cH_EntryValueIntString(beztext));
         }
      }
    is >> ARTIKELID >> PREIS >> PREISMENGE >> MINDMENGE;  

    po.p=Preis(PREIS,getWaehrung(),PREISMENGE);
    payoff[UniqPreis(ARTIKELID,MINDMENGE)]=po;

    is=q.Fetch();
   }

}


PreisListeFull::PreisListeFull(ID id, bool art_in_list,
			ArtikelTyp at) throw(SQLerror) : PreisListe(id)
{
 load_preisliste(false,id,art_in_list,at);
}

PreisListeFull::PreisListeFull(bool with_artbez,ID id, bool art_in_list,
		ArtikelTyp at) throw(SQLerror) : PreisListe(id)
{
 load_preisliste(with_artbez,id,art_in_list,at);
}


