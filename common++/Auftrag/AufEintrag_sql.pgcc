// $Id: AufEintrag_sql.pgcc,v 1.46 2003/01/31 07:23:09 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/AufEintrag.h>
#include <Auftrag/AuftragsBaum.h>
#include <stdio.h>
#include <Misc/string0.h>
#include <Misc/Transaction.h>
#include <Misc/FetchIStream.h>
#include "auftrag_status.h"
#include <Misc/Changejournal.h>
#include "selFullAufEntry.h"
#include <Auftrag/AufEintragZu.h>
#include <Lager/Lager.h>
#include <Lieferschein/Lieferschein.h>
#ifdef MABELLA_EXTENSIONS
#include <Lager/FertigWaren.h>
#include <Artikel/ArtikelBase.h>
#endif
#include <Artikel/ArtikelStamm.h>
#include <Auftrag/Auftrag.h>
#include <algorithm>
#include <unistd.h>
//#include <Instanzen/ppsInstanzProduziert.h>
#include <Misc/Trace.h>
#include <Auftrag/VerfuegbareMenge.h>
#include <Misc/FetchIStream_ops.h>

exec sql include sqlca;

// Menge wurde geliefert. Um die Pfeile über uns muss sich jemand anderes
// kümmern - sinnvoll?
void AufEintrag::abschreiben(mengen_t menge,
    ManuProcEntity<>::ID lfrsid) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"Menge=",menge,"Lfrsid=",lfrsid);

 exec sql begin declare section;
  int AUFID=Id();
  int AUFZNR=ZNr();
  int INSTANZ=InstanzID();
  int STATUS=getEntryStatus();
  int GELIEFERT=(menge+getGeliefert()).as_int();
  int BESTELLT=getStueck().as_int();
  char LASTDATE[21];
 exec sql end declare section;
 // Ihhh
 Petig::Datum::today().write_postgres(LASTDATE,sizeof LASTDATE);

 if(menge>=0 && getEntryStatus()!=(AufStatVal)OPEN) 
    throw(SQLerror(__FILELINE__,-1,"Auftragszeile ist nicht offen sondern "+itos(STATUS)));
 if(menge<0 && getEntryStatus()==(AufStatVal)UNCOMMITED) 
    throw(SQLerror(__FILELINE__,-1,"Auftragszeile ist nicht bestätigt"));
 if (menge<0 && -menge>getGeliefert()) 
 {  menge=-getGeliefert(); GELIEFERT=0; }

 if (!menge) return;

 AufStatVal oldstatus=getEntryStatus();

 if(mengen_t(GELIEFERT)>=getStueck()) STATUS=(AufStatVal)CLOSED;
 else if(menge<0 && mengen_t(GELIEFERT)<getStueck()) STATUS=(AufStatVal)OPEN;

 Transaction tr;
 exec sql lock table auftragentry in exclusive mode;
 bool delete_entry=false;

#ifdef PETIG_EXTENSIONS
  if(menge<0 &&
     Instanz()!=ppsInstanzID::Kundenauftraege && 
     !Instanz()->ProduziertSelbst() && 
     Id()==AuftragBase::plan_auftrag_id)
   {
     BESTELLT+=menge.as_int();
     if(BESTELLT<0) BESTELLT=0;
     if(BESTELLT==GELIEFERT) STATUS=CLOSED;
     if(BESTELLT==0 && GELIEFERT==0 &&  STATUS==CLOSED) delete_entry=true;
   }   
#endif

 if(delete_entry)
   exec sql delete from auftragentry       
     where (instanz,auftragid,zeilennr) = (:INSTANZ,:AUFID,:AUFZNR);
 else
   exec sql update auftragentry set geliefert= :GELIEFERT, status= :STATUS,
     bestellt = :BESTELLT, letzte_lieferung=:LASTDATE
     where (instanz,auftragid,zeilennr) = (:INSTANZ,:AUFID,:AUFZNR);
 SQLerror::test(__FILELINE__);

#ifdef MABELLA_EXTENSIONS // Lager updaten
#warning Jacek: Das muss raus, sobald es mehrstufig ist
 if(Instanz() == ppsInstanzID::Kundenauftraege)
   {
    FertigWaren fw(Artikel(),(FertigWaren::enum_Aktion)'L',menge.as_int(),lfrsid);
    if(menge < 0) fw.Einlagern(1);
    else if(menge > 0) fw.Auslagern(1);
   }
#endif

 geliefert=GELIEFERT;
 if(geliefert>=bestellt) entrystatus=(AufStatVal)CLOSED;

 // zumindest 2er werden nie geschlossen, nur auf 0 gesetzt
 if(STATUS!=oldstatus && Id()!=dispo_auftrag_id)
     setStatus(AufStatVal(STATUS),getuid(),true);

 tr.commit();
}


void AufEintrag::setStatus(AufStatVal newstatus,int uid,bool force) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"Status=",newstatus,"Force=",force);
 if(entrystatus == newstatus)
 {  ManuProC::Trace(AuftragBase::trace_channel,__FILELINE__,*this,"status bereits",newstatus);
    return;
 }
 if(newstatus == STORNO) force=true;
 if(newstatus == STORNO && getGeliefert()!=mengen_t(0))  
 {  std::cerr << "Kann nicht storniert werden da bereits geliefert\n";
    return;
 }
 if(entrystatus == CLOSED && !force )
 {  std::cerr << "Auftragszeile bereits geschlossen\n";
    return;
 }
 if(newstatus == UNCOMMITED)
 {  std::cerr << "bestätigte Zeilen können nicht wieder unbestätigt werden\n";
    return;
 }
 if(newstatus == OPEN && entrystatus != UNCOMMITED && !force)
 {  std::cerr << "nur unbestätigte Zeilen können geöffnet werden\n";
    return;
 }

 Transaction tr; 
 Query("lock auftragentry in exclusive mode");
 SQLerror::test("setStatus: lock table auftragentry");

 // InternAbbestellen
 if(newstatus == CLOSED || newstatus == STORNO)
     ArtikelInternAbbestellen(uid,getRestStk(),ManuProC::Auftrag::r_Closed);

 std::string sqlcommand = "update auftragentry set status="+itos(newstatus);
 if(uid) sqlcommand+=", lasteditdate = now(), lastedit_uid="+itos(uid);
 sqlcommand +=" where (instanz,auftragid,zeilennr)=("+itos(Instanz()->Id())
              +","+itos(auftragid)+","+itos(zeilennr)+")";

 Query::Execute(sqlcommand);
 SQLerror::test("setStatus: update auftragentry");
 AufStatVal oldentrystatus=entrystatus;
 entrystatus=newstatus;


 if(newstatus==OPEN && auftragstatus==UNCOMMITED)
 {  setStatusAuftragBase(newstatus);
    auftragstatus=newstatus;
 }

 if(newstatus == OPEN  &&  oldentrystatus==UNCOMMITED)
    ArtikelInternNachbestellen(uid,getRestStk(),ManuProC::Auftrag::r_Anlegen);

 if(newstatus==OPEN)
   {
    pps_ChJournalEntry::newChange(
			instanz, *this, artikel,
			bestellt.as_float(),
			bestellt.as_float(),
			pps_ChJournalEntry::CH_MENGE);
  }
 else if(newstatus==CLOSED && oldentrystatus!=UNCOMMITED) 
 // UNCOMMITED->CLOSED => kein Eintrag
   {
    pps_ChJournalEntry::newChange(
			instanz, *this, artikel,
			geliefert.as_float(),
			(geliefert-bestellt).as_float(),
			pps_ChJournalEntry::CH_MENGE);
   }

 tr.commit(); 
}

#if 0
#warning Kontrollieren !!!
// wird bei Lieferdatumsänderung aufgerufen
void AufEintrag::setInstanzen(const AufStatVal newstatus,const int uid,const Petig::Datum &lieferdate,const mengen_t &Menge,const int myznr,const int yourznr)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"Status=",newstatus,"lieferdate=",lieferdate,"Menge=",Menge,"MyZNr=",myznr,"YourZNr=",yourznr);

 ArtikelInternAbbestellen(uid,Menge,ManuProC::Auftrag::r_Anlegen);
 ArtikelInternNachbestellen(uid,Menge,ManuProC::Auftrag::r_Anlegen);
#if 0 
 std::list<AufEintragZu::st_reflist> KindListe = AufEintragZu(*this).get_Referenz_list(*this,true);
 for(std::list<AufEintragZu::st_reflist>::const_iterator i=KindListe.begin();i!=KindListe.end();++i)
  {
   AufEintrag AE(i->AEB);
   mengen_t Mauftrag=AE.getRestStk();
   mengen_t Mzuordnung=i->Menge;
   // AufEintrag splitten und Anlegen in der Zuordnungsliste
   int znr=ManuProcEntity<>::none_id,newznr=ManuProcEntity<>::none_id; 
   mengen_t menge=0;
   
   if(!i->AEB.existEntry(i->Art,lieferdate,znr,newznr,menge,newstatus))
     {
      Auftrag A(i->AEB);
      AufEintragBase neuAEB=A.push_back(Mauftrag,lieferdate,i->Art,newstatus,uid,false); //false=KEINE Instanzen
      znr=neuAEB.ZNr();
      if(Instanz()==ppsInstanzID::Kundenauftraege) 
            AufEintragZu(*this).setKindZnr(neuAEB);
      else 
         {
            AufEintragZu(*this).Neu(neuAEB,Mzuordnung,myznr);
            AufEintragZu(*this).setMengeDiff__(AE,-Mzuordnung);
         }
     }
   else
     {
      AufEintragBase AEBZ(AE,znr); 
      mengen_t mt=AEBZ.updateStkDiffBase__(uid,Mauftrag);
      assert(mt==Mauftrag);
      if(Instanz()==ppsInstanzID::Kundenauftraege) 
            AufEintragZu(*this).setKindZnr(AEBZ);
      else 
         {
            mengen_t mts=AufEintragZu(*this).setMengeDiff__(AE,-Mzuordnung);
            assert(mts==-Mzuordnung);
            AufEintragZu(class AufEintragBase(*this,myznr)).Neu(AEBZ,Mzuordnung); // 'Neu' versucht erst ein 'update'
         }
     }
   AE.MengeAendern(uid,-Mauftrag,false,AufEintragBase(),ManuProC::Auftrag::r_Anlegen);

   if(auftragstatus==UNCOMMITED && newstatus==OPEN ) 
      AE.setStatusAuftragBase(newstatus);

   if(instanz->LagerInstanz() && Id()==plan_auftrag_id && 
       (newstatus==STORNO || Mauftrag < 0 ))
    {
      LagerBase L(instanz);
      L.rein_ins_lager(ArtId(),Mauftrag,uid);
    }
   AE.setInstanzen(newstatus,uid,lieferdate,Mauftrag,znr,newznr);
  }
#endif
}
#endif

// statische Variante (behandelt z.B. Vormerkungen, freie Menge etc.)
AufEintragBase AufEintrag::ArtikelInternNachbestellen(const cH_ppsInstanz &wo,
  mengen_t menge,const ManuProC::Datum &lieferdatum,const ArtikelBase& artikel,
  int uid,const AufEintragBase& ElternAEB)
{  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,
   	wo,menge,lieferdatum,artikel,"ElternAEB=",ElternAEB);
   if (!menge) return AufEintragBase(); // hmmm
   assert(menge>0);
   assert(ElternAEB.valid());

   // 2er Menge (freie Menge im Lager, freie Produktionsplanung)
   // vormerken
   VerfuegbareMenge AIL(wo,artikel,lieferdatum);
   mengen_t M_dispo=AuftragBase::min(AIL.getMengeDispo(),menge);
   if(M_dispo>0) menge-=AIL.reduce_in_dispo(uid,M_dispo,ElternAEB);

   // Im Lager von späteren Aufträgen vorgemerkte Menge wegschnappen
   if (menge>0 && wo->LagerInstanz())
   {  M_dispo=AuftragBase::min(AIL.getMengePlan(),menge);
      menge-=AIL.reduce_in_plan(uid,M_dispo,ElternAEB);
   }
   // Rest nachbestellen
   AuftragBase ab(wo,ungeplante_id);
   int znr=ManuProcEntity<>::none_id;
   if (menge>0)
      znr=ab.BestellmengeAendern(menge,lieferdatum,artikel,OPEN,uid,ElternAEB,
   		st_BestellmengeAendern());
   return AufEintragBase(ab,znr);
}

// ehemals updateStkDiffInstanz__ mit menge>0
// + ehemals BaumAnlegen
void AufEintrag::ArtikelInternNachbestellen(int uid,mengen_t menge,
	ManuProC::Auftrag::Action reason) const
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,
   "menge=",menge,"Reason=",reason);
  assert(menge>0);
  assert(Id()!=dispo_auftrag_id);

  if (Instanz()==ppsInstanzID::Kundenauftraege)  
  {  cH_ppsInstanz i=ppsInstanz::getBestellInstanz(Artikel());
     if (i!=ppsInstanzID::None && i!=ppsInstanzID::Kundenauftraege)
     {  AufEintrag::ArtikelInternNachbestellen(i,menge,
		getLieferdatum(),Artikel(),uid,*this);
     }
  }
  else if (Instanz()->LagerInstanz())
  {  assert(Id()==ungeplante_id);
     ArtikelInternNachbestellen(ppsInstanz::getProduktionsInstanz(Artikel()),
     		menge,getLieferdatum(),Artikel(),uid,*this);
  }
  else
  {  ManuProC::Datum newdate=getLieferdatum()-Instanz()->ProduktionsDauer();

     ArtikelBaum AB(Artikel());
     for(ArtikelBaum::const_iterator i=AB.begin();i!=AB.end();++i)
     {  ArtikelInternNachbestellen(ppsInstanz::getBestellInstanz(i->rohartikel),
  		i->menge*menge,newdate,i->rohartikel,uid,*this);
     }
  }
}

AuftragBase::mengen_t AufEintrag::MengeAendern(int uid,mengen_t menge,bool instanzen,
     const AufEintragBase &ElternAEB,ManuProC::Auftrag::Action reason) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"AE=",*this,
   "ElternAEB=",ElternAEB,
   "Menge=",menge,"Instanzen(bool)=",instanzen,"Reason=",reason);
 assert(reason!=ManuProC::Auftrag::r_None);
// if (reason==ManuProC::Auftrag::r_None) assert(!instanzen);
 if (!menge)  return menge;
 Transaction tr;
 Query("lock auftragentry in exclusive mode");
 SQLerror::test("updateStkDiff: lock table auftragentry");

 menge=updateStkDiffBase__(uid,menge);

 if(auftragstatus==OPEN)
  {
   // Rekursion von 2ern verbieten
   assert(Id()!=dispo_auftrag_id || !instanzen); 
   // keine Rekursion bei 1er im Lager 
   // Rekursion bei 1er oder 3er in Produktion
   if ((!Instanz()->LagerInstanz() || Id()==AuftragBase::ungeplante_id) 
   	&& instanzen)
      updateStkDiffInstanz__(uid,menge,*this,reason);
  }
  tr.commit();

 bestellt+=menge;
 return menge;
}

void AufEintrag::ArtikelInternAbbestellen(int uid,mengen_t menge,ManuProC::Auftrag::Action reason) const
{ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,
   "menge=",menge,"Reason=",reason);

 assert(menge>0);
 std::list<AufEintragZu::st_reflist> KindListeU = AufEintragZu(*this).get_Referenz_list(*this,true);
 try{
   typedef  std::map<ArtikelBase,std::list<AufEintragZu::st_reflist> > MapArt_t;
   MapArt_t MapArt;

   for(std::list<AufEintragZu::st_reflist>::iterator i=KindListeU.begin();i!=KindListeU.end();++i)
    {
      // Nach dem Planen kann es zu einem Auftrag mehrere Kindaufträge 
      // mit demselben Artikel geben, nur bei EINEM darf die Menge geändert
      // werden
      MapArt[i->Art].push_back(*i);
     }
  for(MapArt_t::iterator i=MapArt.begin();i!=MapArt.end();++i)
   {
     ArtikelBaum::faktor_t faktor = ArtikelBaum(ArtId()).Faktor(i->first);
     AuftragBase::mengen_t menge2=faktor*menge;
     
     for(std::list<AufEintragZu::st_reflist>::iterator j=i->second.begin();j!=i->second.end();++j)
      {
        AufEintrag AE(j->AEB);
        mengen_t M=AuftragBase::min(j->Menge,menge2);
        
        if(j->AEB.Id()==AuftragBase::ungeplante_id || j->AEB.Instanz()->LagerInstanz())
           M=-AE.MengeAendern(uid,-M,true,AufEintragBase(),reason);
        else // Abbestellung im Lager
          {
            assert(j->AEB.Id()!=AuftragBase::dispo_auftrag_id);
            dispo_auftrag_aendern(uid,j->AEB.Instanz(),i->first,M,AE.getLieferdatum(),j->AEB);
          } 
        AufEintragZu(*this).setMengeDiff__(j->AEB,-M);
        if(j->AEB.Instanz()->LagerInstanz() && 
           j->AEB.Id()==AuftragBase::plan_auftrag_id)
            dispo_auftrag_aendern(uid,j->AEB.Instanz(),i->first,M,LagerBase::Lagerdatum(),AufEintragBase());
        menge2-=M;
        if(!menge2) break;
      }
    }

  }catch(NoAEB_Error &e) 
  {std::cerr <<"Falsche Anzahl von AufEinträgen: "<<e.what()<<'\n'; 
   exit(1);}
}

void AufEintrag::updateStkDiffInstanz__(int uid,mengen_t menge,const AufEintragBase &ElternAEB,ManuProC::Auftrag::Action reason) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,
   "ElternAEB=",ElternAEB,"Menge=",menge,"Reason=",reason);
 if (menge<0) 
 {  assert(ElternAEB==AufEintragBase(*this)); // ?
    ArtikelInternAbbestellen(uid,-menge,reason);
 }
 else 
 {  assert(ElternAEB==AufEintragBase(*this));
    ArtikelInternNachbestellen(uid,menge,reason);
 }
}

void AufEintrag::updatePreis(const Preis &pr) throw(SQLerror)
{ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__);
 Query("update auftragentry "
 	"set preis=?, preismenge=? "
 	"where (instanz,auftragid,zeilennr)=(?,?,?)").lvalue()
 	<< pr.Wert() << pr.PreisMenge() 
 	<< instanz->Id() << auftragid << zeilennr;
 SQLerror::test("updatePreis: update preis in auftragentry");
 preis=pr;
}



void AufEintrag::updateRabatt(rabatt_t rb) throw(SQLerror)
{ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__);
 Query("update auftragentry "
 	"set rabatt=? "
 	"where (instanz,auftragid,zeilennr)=(?,?,?)").lvalue()
 	<< rb 
 	<< instanz->Id() << auftragid << zeilennr;
 SQLerror::test("updateRabatt: update rabatt in auftragentry");
 rabatt=rb;
}


void AufEintrag::updateLieferdatum(const Petig::Datum &ld,int uid) throw(SQLerror)
{ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"Datum=",ld);
 Transaction tr;
 Query("lock auftragentry in exclusive mode"); // unnötig? CP
 SQLerror::test("updateLieferdatum: lock table auftragentry");

 ArtikelInternAbbestellen(uid,getStueck(),ManuProC::Auftrag::r_Anlegen);

 Query("update auftragentry "
 	"set lieferdate=? "
 	"where (instanz,auftragid,zeilennr)=(?,?,?)").lvalue()
 	<< ld
 	<< instanz->Id() << auftragid << zeilennr;
 SQLerror::test("updateLiefDatum: update lieferdate in auftragentry");
 lieferdatum=ld;

 ArtikelInternNachbestellen(uid,getStueck(),ManuProC::Auftrag::r_Anlegen);

 if(entrystatus==OPEN)// status->entrystatus
  {
   try 
    {
     pps_ChJournalEntry::newChange(
  			instanz, *this,
  			artikel, ld,
  			(double)(ld-getLieferdatum()),
  			pps_ChJournalEntry::CH_LIEFDAT);
    }
   catch(SQLerror &e)
     {tr.rollback(); throw; }
  }
 
 tr.commit(); 
}

#include <Misc/relops.h>
  
int AufEintrag::split(int uid,mengen_t newmenge, const Petig::Datum &newld,bool dispoplanung) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"NewMenge=",newmenge,"NewDatum=",newld,"dispoplanung(bool)=",dispoplanung);
 if(entrystatus==CLOSED) return none_znr;

 mengen_t BESTELLT_OLD=bestellt-newmenge;
 int STATUS=entrystatus;

 double GELIEFERT;
 double GELIEFERT_OLD;

 if(lieferdatum>newld)
   {GELIEFERT=(geliefert>newmenge ? mengen_t(newmenge) : geliefert).as_float();
    GELIEFERT_OLD=(geliefert>newmenge ? geliefert-mengen_t(newmenge) : mengen_t(0)).as_float();}
 else
   {GELIEFERT_OLD=(geliefert>BESTELLT_OLD ? mengen_t(BESTELLT_OLD) : geliefert).as_float();
    GELIEFERT=(geliefert>BESTELLT_OLD ? geliefert-mengen_t(BESTELLT_OLD) : mengen_t(0)).as_float();}
    
 Transaction tr;
 exec sql lock auftragentry in exclusive mode;
 SQLerror::test("split: lock table auftragentry");


 mengen_t mt=MengeAendern(uid,-newmenge,true,AufEintragBase(),ManuProC::Auftrag::r_Anlegen);
 assert(mt==-newmenge);

 int ZEILENNR;
 if(Instanz()==ppsInstanzID::Kundenauftraege)
   {Auftrag A(*this);
    AufEintragBase newaeb=A.push_back(newmenge,newld,artikel,entrystatus,uid,true,preis,rabatt);
    ZEILENNR=newaeb.ZNr();
   }
 else
   ZEILENNR=split_zuordnungen_to(newmenge,newld,artikel,entrystatus,uid,dispoplanung);

 if(STATUS==OPEN)
   {   pps_ChJournalEntry::newChange(
    			instanz, *this,
    			artikel, BESTELLT_OLD.as_float(), (BESTELLT_OLD-bestellt).as_float(),
    			pps_ChJournalEntry::CH_MENGE);
       pps_ChJournalEntry::newChange(
    			instanz, *this,
    			artikel, newmenge.as_float(), newmenge.as_float(),
    			pps_ChJournalEntry::CH_MENGE);
   }

 tr.commit();
 return ZEILENNR;
}

AufEintrag::AufEintrag(const AufEintragBase &aebb) throw (SQLerror,NoAEB_Error)
  : AufEintragBase(aebb), 
    artikel(0),
    prozess(Prozess::default_id)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,aebb);
 try{
  SelectedFullAufList aufids((SQLFullAuftragSelector)
    (SQLFullAuftragSelector::sel_AufidZnr(aebb)));

  if ( aufids.aufidliste.size()!=1 ) throw NoAEB_Error(aufids.aufidliste.size());

  *this=*(aufids.aufidliste.begin());
 } catch (SQLerror &e) {std::cerr << e <<'\n';}
}

// hässlich ! warum denn ein cH_Lieferschein statt eines LieferscheinEntryBase?
cH_Lieferschein AufEintrag::getLieferschein() const
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__);
  int LFRSID,LFRZNR;
 // bislang cH_Lieferschein(ppsInstanzID::None,0); wenn keine Zeile
 // jetzt SQLerror
 Query("select lfrsid,zeile from lieferscheinentry "
 	"where (instanz,refauftragid,refzeilennr)=(?,?,?) "
 	"limit 1").lvalue()
 	<< instanz->Id() << Id() << ZNr()
 	>> LFRSID >> LFRZNR;
#warning kann es mehr als eine Zeile geben? 
 return cH_Lieferschein(Instanz(),LFRSID);
}
