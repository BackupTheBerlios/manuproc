// $Id: AufEintrag_sql.pgcc,v 1.5 2002/04/11 12:01:07 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/AufEintrag.h>
#include <Auftrag/AuftragsBaum.h>
#include <stdio.h>
#include <Aux/string0.h>
#include <Aux/Transaction.h>
#include "auftrag_status.h"
#include <Aux/Changejournal.h>
#include "selFullAufEntry.h"
#include <Auftrag/AuftragsEntryZuordnung.h>
#include <Lager/Lager_Vormerkungen.h>

exec sql include sqlca;

void AufEintrag::setStatus(AufStatVal newstatus,bool force) throw(SQLerror)
{exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int INSTANZ=instanz->Id();
 int ZEILENNR = zeilennr;
 int STATUS=newstatus;
 exec sql end declare section;

// Braucht man die Warnung noch? 14.11.2001 MAT
#warning was ist mit status (Auftragsstatus), kann das ignoriert werden?
 if(entrystatus == CLOSED && !force ) return; // nichts geht mehr
 if(newstatus == UNCOMMITED) return; // zurück geht nicht, nur vor
 if(entrystatus == newstatus) return;     // nichts geändert
 if(newstatus == OPEN && entrystatus != UNCOMMITED && !force) return;


 Transaction tr; 
 exec sql lock auftragentry in exclusive mode;
 SQLerror::test("setStatus: lock table auftragentry");
  
 
 exec sql update auftragentry set status= :STATUS
	where (instanz,auftragid,zeilennr)=(:INSTANZ,:AUFTRAGID,:ZEILENNR);
 SQLerror::test("setStatus: update auftragentry");

 if(newstatus==OPEN && auftragstatus==UNCOMMITED)
    setStatusAuftragBase(newstatus);

 // Status für die Instanzen setzen
 setInstanzen(newstatus,getLieferdatum(),getStueck());

 if(newstatus==OPEN)
   {
    pps_ChJournalEntry::newChange(
			instanz, *this, artikel,
			(double)bestellt,
			(double)bestellt,
			pps_ChJournalEntry::CH_MENGE);
  }
 else if(newstatus==CLOSED && entrystatus!=UNCOMMITED) 
 // UNCOMMITED->CLOSED => kein Eintrag
   {
    pps_ChJournalEntry::newChange(
			instanz, *this, artikel,
			(double)geliefert,
			(double)geliefert-bestellt,
			pps_ChJournalEntry::CH_MENGE);
   }

 entrystatus=newstatus;
 tr.commit(); 
}

void AufEintrag::setInstanzen(AufStatVal newstatus,Petig::Datum lieferdate,mengen_t Menge,int myznr,int yourznr)
{
 std::list<AufEintragZu::st_reflist> KindListe = AufEintragZu(*this).get_Referenz_list(*this,true);
 for(std::list<AufEintragZu::st_reflist>::const_iterator i=KindListe.begin();i!=KindListe.end();++i)
  {
    ArtikelBaum::menge_t f=ArtikelBaum(artikel).Faktor(i->AB);
    mengen_t M=Menge*f;    
//std::cout << "\n\nsetStatusInstanz: Ich bin  : "<<Instanz()<<' '<<Id()<<' '<<ZNr()<<'\t';
//std::cout << " Kinde ist: "<<i->AEB2.Instanz()<<' '<<i->AEB2.Id()<<' '<<i->AEB2.ZNr()<<'\n';
   AufEintrag AEB(i->AEB2);
   // AufEintrag splitten und Anlegen in der Zuordnungsliste
   int znr=0,newznr=0; mengen_t menge=0;
   if(!i->AEB2.existEntry(i->AB,lieferdate,znr,newznr,menge,newstatus))
     {
      znr=AEB.insertNewEntry(M,lieferdate,i->AB,newstatus,false);
      if(Instanz()==ppsInstanz::INST_KNDAUF) 
            AufEintragZu(*this).setKindZnr(AEB,znr);
      else 
         {
//cout << Instanz()->Id()<<' '<<Id()<<' '<<ZNr()<<'\t'<<-M<<'\n';
            AufEintragZu(*this).AuftragsEntryZuordnung(M,AEB,znr,myznr);
            AufEintragZu(*this).setMengeDiff(-M,AEB,AEB.ZNr());
         }
     }
   else
     {
//std::cout << "existEntry :"<<Instanz()<<' '<<Id()<<' '<<AEB.Instanz()<<' '
//      <<AEB.Id()<<" Myznr:"<<myznr<<" Yourznr: "<<yourznr<<" Znr: "<<znr
//<<" NEWZnr: "<<newznr<<'\t';
//std::cout << menge<<'+'<<M<<'='<<menge+M<<'\n';
      AufEintragBase(AEB,znr).updateStkDiff(M);
      if(Instanz()==ppsInstanz::INST_KNDAUF) 
            AufEintragZu(*this).setKindZnr(AEB,znr);
      else 
         {
//std::cout<<"Reduce:   "<<Id()<<' '<<ZNr()<<'\t'<<AEB.Id()<<' '<<AEB.ZNr()<<'\t'<<i->Menge<<'\n';
            AufEintragZu(*this).setMengeDiff(-M,AEB,AEB.ZNr());
//std::cout<<"Increase: "<<Id()<<' '<<myznr<<'\t'<<AEB.Id()<<' '<<znr<<'\n';
            if(!AufEintragZu(class AufEintragBase(*this,myznr)).setMengeDiff(M,AEB,znr))
                AufEintragZu(class AufEintragBase(*this,myznr)).AuftragsEntryZuordnung(M,AEB,znr);
         }
     }
//cout << AEB.Instanz()->Id()<<' '<<AEB.Id()<<' '<<AEB.ZNr()<<'\t';
   AEB.updateStk(AEB.getStueck()-M,false); // macht auch das Lager
   if(auftragstatus==UNCOMMITED && newstatus==OPEN ) 
      AEB.setStatusAuftragBase(newstatus);

   if(instanz->LagerInstanz() && Id()==Lager_Vormerkungen::LagerAuftragsId && 
       (newstatus==STORNO || M < 0 ))
    {
#warning noch nicht getestet!!!!
#warning kommt aber bald  21.2.02 MAT
//      Lager_Vormerkungen::freigegeben_menge_neu_verplanen(instanz,ArtId(),M);
    }

   AufEintrag(i->AEB2).setInstanzen(newstatus,lieferdate,M,znr,newznr);
  }
}


void AufEintrag::updateStk(mengen_t stk,bool instanz) throw(SQLerror)
{
//cout << Instanz()->Id()<<' '<<Id()<<' '<<ZNr()<<' '<<
//"Auftragstatus= "<< auftragstatus<<'\n';
 if(auftragstatus==OPEN || auftragstatus==UNCOMMITED)
  {
   Transaction tr;
   exec sql lock auftragentry in exclusive mode;
   SQLerror::test("updateStk: lock table auftragentry");

//std::cout << "AufEintrag::updateStk: "<<stk<<' '<<bestellt<<'\n';
   AufEintragBase::updateStkDiff(stk-bestellt);
   if(instanz) updateStkInstanz(stk,bestellt);
/*
   if(ppsInstanz::LagerInstanz(Instanz()->Id())) 
    {
      ProdLager PL(*this);
      PL.vormerkung_updateStk(stk);
    }
*/
   bestellt=stk;
   tr.commit();
  }
}

void AufEintrag::updateStkInstanz(mengen_t neu_stk,mengen_t alt_stk) throw(SQLerror)
{
  std::list<AufEintragZu::st_reflist> KindListe = AufEintragZu(*this).get_Referenz_list(*this,true);
 try{
  for(std::list<AufEintragZu::st_reflist>::const_iterator i=KindListe.begin();i!=KindListe.end();++i)
   {
//std::cout << i->AEB2.Instanz()->Id()<<' '<<i->AEB2.Id()<<' '<<i->AEB2.ZNr()<<'\n';
     AufEintrag AEB(i->AEB2);
     ArtikelBaum::menge_t faktor = ArtikelBaum(ArtId()).Faktor(i->AB);
//std::cout << i->AEB2.Instanz()->Id()<<' '<<i->AEB2.ZNr()<<'\t';
//std::cout << i->Menge<<' '<<AEB.getStueck()<<' '<<getStueck()*faktor<<' '<<alt_stk*faktor<<' '<<neu_stk*faktor<<' '<<'\n';
     mengen_t neue_menge=neu_stk*faktor;
     mengen_t alte_menge=alt_stk*faktor;
     AEB.updateStk(AEB.getStueck()+neue_menge-alte_menge,true);
     AufEintragZu(*this).setMengeDiff(mengen_t(neu_stk*faktor) - i->Menge,i->AEB2,i->AEB2.ZNr());
   }
  }catch(NoAEB_Error &e) 
  {cerr <<"Falsche Anzahl von AufEinträgen: "<<e.what()<<'\n'; 
   exit(1);}
}

/*
void AufEintrag::moveStk(AufEintrag& ae,mengen_t stk,bool instanz) throw(SQLerror)
{
  updateStk(stk,instanz);
  ae.updateStk(-stk,instanz);
}
*/



void AufEintrag::updatePreis(const Preis &pr) throw(SQLerror)
{exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int ZEILENNR = zeilennr;
 int INSTANZ=instanz->Id();
 float PREIS=pr.Wert();
 float PREISMENGE=pr.PreisMenge();
 exec sql end declare section;
 
 exec sql update auftragentry 
 	set preis= :PREIS, preismenge= :PREISMENGE
 	where (instanz,auftragid,zeilennr)=(:INSTANZ,:AUFTRAGID,:ZEILENNR);
 SQLerror::test("updatePreis: update preis in auftragentry");
 preis=pr;
}


void AufEintrag::updateRabatt(int rb) throw(SQLerror)
{exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int INSTANZ=instanz->Id();
 int ZEILENNR = zeilennr;
 int RABATT = rb;
 exec sql end declare section;

 exec sql update auftragentry set rabatt= :RABATT/100.0
 	where (instanz,auftragid,zeilennr)=(:INSTANZ,:AUFTRAGID,:ZEILENNR);
 SQLerror::test("updateRabatt: update rabatt in auftragentry");
 
 rabatt=RABATT;
}


void AufEintrag::updateLieferdatum(const Petig::Datum &ld) throw(SQLerror)
{exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int INSTANZ=instanz->Id();
 int ZEILENNR = zeilennr;
 char LIEFERDATUM[21];
 exec sql end declare section;

 Transaction tr;
 exec sql lock auftragentry in exclusive mode;
 SQLerror::test("updateLieferdatum: lock table auftragentry");
  
 ld.write_postgres(LIEFERDATUM,sizeof LIEFERDATUM);
 
 exec sql update auftragentry set lieferdate= :LIEFERDATUM
 	where (instanz,auftragid,zeilennr)=(:INSTANZ,:AUFTRAGID,:ZEILENNR);
 SQLerror::test("updateLiefDatum: update lieferdate in auftragentry");

 //update Lieferdatum für Instanzen
 setInstanzen(entrystatus,ld,getStueck()); // status->entrystatus

 if(entrystatus==OPEN)// status->entrystatus
  {
   try 
    {
     pps_ChJournalEntry::newChange(
  			instanz, *this,
  			artikel, ld,
  			(double)(ld-getLieferdatum()),
  			pps_ChJournalEntry::CH_LIEFDAT);
    }
   catch(SQLerror &e)
     {tr.rollback(); throw; }
  }
 
 lieferdatum=ld;
 tr.commit(); 
}

void AufEintrag::split(mengen_t newmenge, const Petig::Datum &newld) throw(SQLerror)
{
 if(entrystatus==CLOSED) return;

 mengen_t BESTELLT_OLD=bestellt-newmenge;
 int STATUS=entrystatus;

 double GELIEFERT;
 double GELIEFERT_OLD;

 if(lieferdatum>newld)
   {GELIEFERT=geliefert>newmenge ? mengen_t(newmenge) : geliefert;
    GELIEFERT_OLD=geliefert>newmenge ? geliefert-mengen_t(newmenge) : mengen_t(0);}
 else
   {GELIEFERT_OLD=geliefert>BESTELLT_OLD ? mengen_t(BESTELLT_OLD) : geliefert;
    GELIEFERT=geliefert>BESTELLT_OLD ? geliefert-mengen_t(BESTELLT_OLD) : mengen_t(0);}
    
 Transaction tr;
// exec sql lock auftragentry in share mode;
 // don't we need access exclusive mode???
 // what if two people split concurrently seperate lines - second will fail
 exec sql lock auftragentry in exclusive mode;
 SQLerror::test("split: lock table auftragentry");

 int ZEILENNR=insertNewEntry(newmenge,newld,artikel,entrystatus,true,preis,rabatt);
 updateStk(bestellt-newmenge,true);
 
 if(STATUS==OPEN)
   {   pps_ChJournalEntry::newChange(
    			instanz, *this,
    			artikel, BESTELLT_OLD, +(BESTELLT_OLD-bestellt),
    			pps_ChJournalEntry::CH_MENGE);
       pps_ChJournalEntry::newChange(
    			instanz, *this,
    			artikel, newmenge, +newmenge,
    			pps_ChJournalEntry::CH_MENGE);
   }

 tr.commit();
}

AufEintrag::AufEintrag(const AufEintragBase &aebb) throw (SQLerror,NoAEB_Error)
  : AufEintragBase(aebb), 
    artikel(0),
    prozess(Prozess::default_id)
{
 try{
  SelectedFullAufList aufids((SQLFullAuftragSelector)
    (SQLFullAuftragSelector::sel_AufidZnr(aebb)));

  if ( aufids.aufidliste.size()!=1 ) throw NoAEB_Error(aufids.aufidliste.size());
//  assert(aufids.aufidliste.size()==1);

//  (*this)=aufids.aufidliste[0];
  *this=*(aufids.aufidliste.begin());
 } catch (SQLerror &e) {std::cerr << e <<'\n';}
}

int AufEintrag::Planen(mengen_t menge, const AuftragBase &zielauftrag)
{
   assert(!Id());

   int znr=-1,dummy;
   mengen_t mdummy;
   if (!zielauftrag.existEntry(Artikel(),getLieferdatum(),znr,dummy,mdummy,OPEN))
      znr = zielauftrag.insertNewEntry(0,getLieferdatum(),Artikel(),OPEN,false);

   if(menge==AuftragBase::mengen_t(0)) return znr;
   assert(menge>0);
   move_to(AufEintragBase(zielauftrag,znr),menge);

   std::list<AufEintragZu::st_reflist> ReferenzAufEintrag =
			         AufEintragZu(*this).get_Referenz_listFull(false);

   for (std::list<AufEintragZu::st_reflist>::iterator i=ReferenzAufEintrag.begin();i!=ReferenzAufEintrag.end();++i)
   {
     if(i->AEB2.Instanz()->Id()!=ppsInstanz::Kundenauftraege) continue;
     i->AEB2.setLetztePlanungFuer(instanz);
     i->AEB2.calculateProzessInstanz();
   }
 return znr;
}

void AufEintrag::moveInstanz(const AuftragBase &newAuftrag) throw(SQLerror)
{
 AufEintragBase oldAEB = *this;
 auftragid=newAuftrag.Id(); 
 instanz=newAuftrag.Instanz();

 exec sql begin declare section;
  int OLDAUFTRAGID = oldAEB.Id();
  int OLDINSTANZ   = oldAEB.Instanz()->Id();
  int OLDZEILENNR  = oldAEB.ZNr();  
 exec sql end declare section;

 if(newAuftrag.Instanz()->LagerInstanz())
   {
    AuftragBase::mengen_t menge=getRestStk();
    oldAEB.updateStkDiff(-menge);
    zeilennr = newAuftrag.insertNewEntry(menge,getLieferdatum(),Artikel(),
                               getEntryStatus(),false,EPreis(),Rabatt());
    Lager_Vormerkungen(class AufEintrag(newAuftrag.Instanz()->Id(),newAuftrag.Id()
            ,zeilennr,menge,Artikel(),getLieferdatum(),getEntryStatus())).vormerken_oder_bestellen();
   }
 else 
  { 
    zeilennr = newAuftrag.insertNewEntry(getStueck(),getLieferdatum(),Artikel(),
                        getEntryStatus(),false,EPreis(),Rabatt());
  }
// exec sql delete from prod_changejournal where 
//      (insid,auftragid,auftragzeile)=(:OLDINSTANZ,:OLDAUFTRAGID,:OLDZEILENNR);
 exec sql delete from auftragentry where 
   (instanz,auftragid,zeilennr) = (:OLDINSTANZ,:OLDAUFTRAGID,:OLDZEILENNR);
 SQLerror::test("moveInstanz: delete from auftragentry");

 if(oldAEB.Instanz()->LagerInstanz())
   {
     SQLFullAuftragSelector psel= SQLFullAuftragSelector::sel_Artikel(
                                  oldAEB.Instanz()->LagerFuer(),Artikel());
     SelectedFullAufList allaufids=SelectedFullAufList(psel);
     for(SelectedFullAufList::iterator i=allaufids.begin();i!=allaufids.end();++i)
      {
        OLDINSTANZ=i->Instanz()->Id();
        OLDAUFTRAGID=i->Id();
        OLDZEILENNR=i->ZNr();
        exec sql delete from auftragentry where 
            (instanz,auftragid,zeilennr) = (:OLDINSTANZ,:OLDAUFTRAGID,:OLDZEILENNR);
        SQLerror::test("moveInstanz: delete from auftragentry");
        AufEintragZu::moveInstanz(AufEintragZu::Delete,oldAEB,*i);
        AufEintragZu::moveInstanz(AufEintragZu::Von,*i,*this);
      }
   }
 else AufEintragZu::moveInstanz(AufEintragZu::Von,oldAEB,*this);
 AufEintragZu::moveInstanz(AufEintragZu::Nach,oldAEB,*this);
}

cH_Lieferschein AufEintrag::getLieferschein() const
{
  exec sql begin declare section;
   int LFRSID=0,LFRZNR=0;
   int AUFID=Id();
   int AUFZNR=ZNr();
   int INSTANZ=Instanz()->Id();
  exec sql end declare section;
  exec sql select lfrsid,zeile into :LFRSID,:LFRZNR
      from lieferscheinentry where 
      (instanz,refauftragid,refzeilennr)=(:INSTANZ,:AUFID,:AUFZNR) limit 1;
#warning kann es mehr als eine Zeile geben? 
 SQLerror::test(__FILELINE__,100);
 if(sqlca.sqlcode) // keine Zeile gefunden ... warum nicht throw?
   return cH_Lieferschein(ppsInstanz::None,0);
 else 
   return cH_Lieferschein(Instanz(),LFRSID);
}
