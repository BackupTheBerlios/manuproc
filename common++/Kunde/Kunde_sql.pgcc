// $Id: Kunde_sql.pgcc,v 1.65 2004/10/11 16:44:10 jacek Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Christof Petig
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */


#include "Kunde/Kunde.h"
//#include <Kunde/Person.h>
#include <Misc/Transaction.h>
#include <Kunde/Telefon.h>
#include <Misc/FetchIStream.h>
exec sql include sqlca;

void Kunde::setVerkNr(Kunde::ID v) throw(SQLerror)
{
 if(Id()==Kunde::none_id) return;

 Transaction tr;

 Query("update kunden set verknr=? where kundennr=?")
 << Query::NullIf(v,Kunde::none_id) << Id();
 SQLerror::test(__FILELINE__);

 if(v==Kunde::none_id)
   Query("delete from prov_config where kundennr=?") << Id();
 SQLerror::test(__FILELINE__,100);

 tr.commit(); 

 verkaeufer = v;
}

const std::string Kunde::VerkName() const throw(SQLerror) { 
 cH_Kunde v(verkaeufer);

 if(v->Id()==Kunde::none_id) return "";

 return v->getFullName(); 
}

Kunde::Kunde(ID _id) throw(SQLerror) 
: ManuProcHandle<>(_id), KundenGruppennr(0),schema(ExtBezSchema::default_id),rngan(0),
  rng_an_postfach(false),
  ab_an_rngadresse(false),
//lieferadresse(false),
//rechnungsadresse(false),
  entsorg(false),
  mwst(true),
  waehrung(WaehrungID::EUR),
  lieferung_frei_haus(true)
{ 
   // return ersetzen
   if(_id == Kunde::none_id) return;
   exec sql begin declare section;
   int ID=_id,BEZSCHEMA,BANKINDEX,RNG_AN,LFR_AN;
   int BRANRID;
   char SORTNAME[31], IDNR[21];
   char NAME[61], STRASSE[36], HSNR[8], POSTFACH[21],ORT[31],BANKNAME[51],
         PLZ[11],POSTFACHPLZ[11],KTONR[11],BLZ[11],POSTANWVOR[41],POSTANWNACH[41];
   char *NAME2=0;
   int LANDESID;
   int ILLEGALLANDID;
   int FLAECHE,MITARBEITER;
   double KUNDENUMSATZ,PLANUMSATZ,UMSATZ, RABATT;
   bool ZEILENRABATT;
   int ZAHLUNGSART;
   char VEREIN[31];
/*   bool LIEFERADRESSE,RECHUNGSADRESSE; */
   bool ENTSORGUNG,RNGANLFRA,ABANRNG,MWST;
   char NOTIZ[2048];
   char STAND[50];
   int WAEHRUNGID;
   int VERKNR;
   int BETREUER;
   int LIEFERANTENKONTO,GEGENKONTO;
   char UNSERE_KUNDENNR[128];
   int ANZFIRMA,ANZWEISS;
   bool FREIHAUS;
   bool AKTIV;
   bool PREISAUTO;
   bool SHOWEAN;
   char *GEBDATUM=0; int IGEBDATUM;
   exec sql end declare section;
   ILLEGALLANDID=LandesListe::none_id;
  
   Transaction tr;
 
   WAEHRUNGID = WaehrungID::EUR;

   exec sql select firma,
	coalesce(name2,''),
	coalesce(sortname,firma),
    coalesce(extartbezid,1),
	 coalesce(strasse,''),
    coalesce(postanwvor,''),coalesce(postanwnach,''),
         coalesce(hsnr,''),coalesce(plz,''),coalesce(postfach,''),
         coalesce(postfplz,''),coalesce(ort,''),coalesce(text(ktonr),''),
         coalesce(text(b.blz),''), coalesce(b.name,''), coalesce(b.bankindex,0),
         coalesce(rechnung_an,kundennr), 
	 coalesce(lieferung_an,kundennr),
	 coalesce(branr,-1),
	 gebdatum,
         coalesce(idnr,''),
/*         coalesce(lieferadresse,false), coalesce(rechnungsadresse,false), */
         coalesce(rng_an_postfach,false),
	 coalesce(ab_an_rngadresse,false),
         coalesce(flaeche,0),coalesce(mitarbeiter,0),
   /* the 0.0s are to make typing more strict, which gives an error
      once it is read into the wrong variable */
         coalesce(kundenumsatz,0.0),
         coalesce(planumsatz,0.0),coalesce(umsatz,0.0),
         coalesce(rabatt,0.0),coalesce(zeilenrabatt,false)
         ,coalesce(zahlungsart,0),
         coalesce(verein,''), coalesce(notiz,''), 
         coalesce(stand,now()),	coalesce(landid,:ILLEGALLANDID),
	 coalesce(waehrungid,:WAEHRUNGID),
	 coalesce(entsorgung,false),
    coalesce(verknr,-1),coalesce(lieferantenkonto,0),
    coalesce(gegenkonto,0),coalesce(unsere_kundennr,''),
	coalesce(betreuer,-1),coalesce(anz_firmenpapier,1),
	coalesce(anz_weissespapier,1),coalesce(lieferung_frei_haus,'t'),
	coalesce(aktiv,true), coalesce(preisauto,true),
	coalesce(showean,false),
	coalesce(mwst,true)
   	into :NAME, :NAME2, :SORTNAME, :BEZSCHEMA, :STRASSE, :POSTANWVOR, :POSTANWNACH,
           :HSNR, :PLZ, :POSTFACH,
           :POSTFACHPLZ, :ORT, :KTONR, :BLZ, :BANKNAME, :BANKINDEX, :RNG_AN,
	   :LFR_AN, :BRANRID, :GEBDATUM:IGEBDATUM,
           :IDNR,
/*           :LIEFERADRESSE,:RECHUNGSADRESSE, */
	   :RNGANLFRA,:ABANRNG,
           :FLAECHE,:MITARBEITER,:KUNDENUMSATZ,:PLANUMSATZ,:UMSATZ,
	   :RABATT,:ZEILENRABATT,:ZAHLUNGSART, :VEREIN, 
	   :NOTIZ,:STAND, :LANDESID, :WAEHRUNGID, :ENTSORGUNG, :VERKNR,
      :LIEFERANTENKONTO,:GEGENKONTO,:UNSERE_KUNDENNR,:BETREUER,
      :ANZFIRMA,:ANZWEISS,:FREIHAUS,:AKTIV,:PREISAUTO,:SHOWEAN,
	:MWST
   	from kunden k left join banken b using(bankindex)
   	where kundennr= :ID;

   SQLerror::test(__FILELINE__);


   lieferung_frei_haus=FREIHAUS;
   schema=BEZSCHEMA;
   adresse.firma=NAME;
   adresse.name2=NAME2;
   adresse.branr=BRANRID;
   SORTNAME[30]=0; // mit FetchIStream wäre das nicht passiert ...
   adresse.sortname=SORTNAME;
   adresse.strasse=STRASSE;
   adresse.postanwvor=POSTANWVOR;
   adresse.postanwnach=POSTANWNACH;
   adresse.hsnr=HSNR;
   adresse.plz=PLZ;
   adresse.postfach=POSTFACH;
   adresse.postfachplz=POSTFACHPLZ;
   adresse.ort=ORT;
   adresse.land = cH_LandesListe(LANDESID);
   adresse.unsere_kundennr = UNSERE_KUNDENNR;
   IDnr=IDNR;
//   lieferadresse=LIEFERADRESSE;
//   rechnungsadresse=RECHUNGSADRESSE;
   rng_an_postfach=RNGANLFRA;
   ab_an_rngadresse=ABANRNG;
   bankverb.konto=strtoll(KTONR,NULL,10);
   bankverb.blz=strtoul(BLZ,NULL,10);
   bankverb.bank=BANKNAME;
   bankverb.bankindex=BANKINDEX;
   bankverb.lieferantenkonto=LIEFERANTENKONTO;
   bankverb.gegenkonto=GEGENKONTO;
   try{
   bankverb.zahlungsart=cH_Zahlungsart(ZAHLUNGSART);
   }catch(SQLerror &e) 
   { 
    std::cerr << e<<"\tZahlungsart nicht gefunden\n";
    bankverb.zahlungsart=cH_Zahlungsart(Zahlungsart::none_id);
   }

   rngan=RNG_AN;
   lfran=LFR_AN;
   
   entsorg = ENTSORGUNG;

   kundendaten.flaeche = FLAECHE;
   kundendaten.mitarbeiter=MITARBEITER;
   kundendaten.kundenumsatz=KUNDENUMSATZ;
   kundendaten.planumsatz=PLANUMSATZ;
   kundendaten.umsatz=UMSATZ;
   kundendaten.rabatt=RABATT;
   kundendaten.zeilenrabatt=ZEILENRABATT;
//   kundendaten.einzugrabatt=EINZUGRABATT;
//   kundendaten.skontosatz=SKONTOSATZ;
   kundendaten.anzahl_ausdruck_firmenpapier=ANZFIRMA;
   kundendaten.anzahl_ausdruck_weissespapier=ANZWEISS;
   kundendaten.verein=VEREIN;
//   kundendaten.bankeinzug=BANKEINZUG;
   kundendaten.stand=STAND;
   kundendaten.gebdatum=IGEBDATUM?ManuProC::Datum(GEBDATUM):ManuProC::Datum();
   kundendaten.notiz=NOTIZ;
   waehrung = cP_Waehrung(Waehrung::ID(WAEHRUNGID));

   verkaeufer=VERKNR;
   betreuer=BETREUER;
   prlist_valid=false;
   isaktiv=AKTIV;
   preisautomatik=PREISAUTO;
   showean=SHOWEAN;
   mwst=MWST;
}

#ifdef MANUPROC_DYNAMICENUMS_CREATED
const cH_Kunde Kunde::newKunde(const Kunde::ID kid, const std::string &firma,
	const std::string &name2,
	Kundengruppe::ID kgrid) throw(SQLerror)
{
 exec sql begin declare section;
  int KID=kid;
  char *FIRMA;
  char *NAME2; int INAME2=0;
  int WAEHRUNG;
  int GRPNR=kgrid;
 exec sql end declare section;
 WAEHRUNG=WaehrungID::EUR;
 Transaction tr;

 FIRMA=(char*)firma.c_str();
 NAME2=(char*)name2.c_str();

 if(name2.empty()) INAME2=-1;

 exec sql insert into kunden (kundennr, firma, name2, waehrungid,rechnung_an,
		lieferung_an,aktiv) 
      values (:KID, :FIRMA, :NAME2:INAME2, :WAEHRUNG,:KID,:KID,true);
 SQLerror::test(__FILELINE__);
// exec sql insert into ku_warenkorb (prlsnr,kundennr,suchfolge)
//   values (1,:KID,1);
 exec sql insert into ku_gruppen_map (kundennr,grpnr)
   values (:KID,:GRPNR);
 SQLerror::test(__FILELINE__);
 tr.commit();

 return cH_Kunde(KID);
}

#endif

//void Kunde::delete_Kunde(const Kunde::ID kid) throw(SQLerror)
//{
//#ifdef MABELLA_EXTENSIONS
// exec sql begin declare section;
//    int KID=kid;
// exec sql end declare section;
//
// exec sql delete from kunden where kundennr = :KID;
// SQLerror::test(__FILELINE__);
//#endif
//}

const Kunde::ID Kunde::nextval() throw(SQLerror)
{
 exec sql begin declare section;
   int KUNDENNR;
   int OLDKUNDENNR,IOLDKUNDENNR;
 exec sql end declare section;
 exec sql select nextval('kunden_seq') into :KUNDENNR;
 SQLerror::test(__FILELINE__);

 while(1)
  {
   OLDKUNDENNR=-1;
   exec sql select kundennr into :OLDKUNDENNR:IOLDKUNDENNR 
   	from kunden where kundennr=:KUNDENNR;
   SQLerror::test(__FILELINE__,"select kundennr",100);

   if(sqlca.sqlcode==100) break;

   // search next new kundennr
   exec sql select nextval('kunden_seq') into :KUNDENNR;
   SQLerror::test(__FILELINE__);
  }

 return KUNDENNR;
}

void Kunde::get_blz_from_bankindex(unsigned int bankindex)
{
 exec sql begin declare section;
   unsigned int BANKINDEX=bankindex;
   unsigned long int BLZ;   
 exec sql end declare section;
 exec sql select blz into :BLZ from banken where bankindex=:BANKINDEX;
 SQLerror::test(__FILELINE__);
 bankverb.blz=BLZ;
}


unsigned long int Kunde::neue_bank_anlegen(const std::string& name, unsigned long int blz)
{
 exec sql begin declare section;
   unsigned int BANKINDEX;
   char *NAME;
   unsigned long int BLZ=blz;   
 exec sql end declare section;

 NAME = (char*)name.c_str();
 
 exec sql insert into banken (name,blz) values (:NAME,:BLZ);
 SQLerror::test(__FILELINE__);
 exec sql select bankindex into :BANKINDEX from banken where blz=:BLZ;
 SQLerror::test(__FILELINE__);

 return BANKINDEX;
}

unsigned long int Kunde::bankname_aendern(unsigned long int blz, const std::string& name)
{
 Query("update banken set name=? where blz=?")
	<< name << blz;
  SQLerror::test(__FILELINE__);

 int bankindex;
 Query("select bankindex from banken where blz=?") << blz >> bankindex;
 SQLerror::test(__FILELINE__); 

 return bankindex;
}


void Kunde::reread_Stand() throw(SQLerror)
{
 exec sql begin declare section;
 unsigned int KUNDENNR = entityid;
 char STAND[20];
 exec sql end declare section;

 exec sql select stand into :STAND from kunden where kundennr = :KUNDENNR;
 SQLerror::test(__FILELINE__);
 
 kundendaten.stand = STAND; 

}

std::vector<Kunde::st_ansprech> Kunde::getPersonen() const
{
  exec sql begin declare section;
      char *QUERY;
      int PERSNR;
      char NOTIZ[1024];
      char POSITION[100];
  exec sql end declare section;

  std::string QU=" SELECT a.persnr,coalesce(a._position,''),coalesce(a.notiz,'') FROM "
         "kunden p, ku_ansprech a"
         " WHERE p.kundennr=a.persnr and a.kundennr ="+
         itos(Id())+" ORDER BY name";

  QUERY=(char*)QU.c_str();

  Transaction tr;

  exec sql prepare ein_ from :QUERY;
  exec sql declare ein cursor for ein_ ;
  exec sql open ein;
  SQLerror::test(__FILELINE__);
  std::vector<st_ansprech> VP;
  while (true)
   {
     exec sql fetch ein into :PERSNR,:POSITION,:NOTIZ;
     SQLerror::test(__FILELINE__,"ein",100);
     if (sqlca.sqlcode) break;
     VP.push_back(st_ansprech(PERSNR,POSITION,NOTIZ));
   }
  exec sql close ein;

  tr.close();
  return VP;  
}

std::list<cH_Telefon> Kunde::getTelefon(Kunde::ID pid) const
{
 exec sql begin declare section;
   int TELID;   
   char *QU;
 exec sql end declare section;

 int KUNDENNR=Id();

 std::string query("SELECT telid FROM ku_telefon WHERE kundennr= ");
 
 query += itos(KUNDENNR);

 if(pid==Kunde::none_id) query += " and persnr is null";
 else query += " and persnr="+itos(pid);
 
 QU=(char *)query.c_str();
 Transaction tr;
 
 exec sql prepare telein_ from :QU;
 exec sql declare telein cursor for telein_;
 exec sql open telein;

 SQLerror::test(__FILELINE__);
 std::list<cH_Telefon> T;
 while(true)
   {
      exec sql fetch telein into :TELID;
      SQLerror::test(__FILELINE__,"teleein",100);
      if (sqlca.sqlcode) break;
      T.push_back(cH_Telefon(TELID));
   }
 exec sql close telein;
 tr.close(); 
 return T;
}

/*
const Kunde::Verkaeufer &Kunde::getVerkaeufer() const throw(SQLerror)
{
 if(verkaeufer.verknr == Kunde::none_id) return verkaeufer;
  exec sql begin declare section;
   int VERKNR=verkaeufer.verknr;
   char *NAME=0, *KURZ=0;
  exec sql end declare section;

  exec sql select name,kurz into :NAME,:KURZ
      from ku_verkaeufer where vknr=:VERKNR;
  SQLerror::test(__FILELINE__);
  verkaeufer.name=NAME;
  verkaeufer.kurz=KURZ;
 
  ECPGfree_auto_mem(); 

  return verkaeufer;
}
*/

enum Kunde::B_UPDATE_BITS_ADRESSE &operator++(enum Kunde::B_UPDATE_BITS_ADRESSE &s)
{  ++(int&)s;
   return s;
}
enum Kunde::B_UPDATE_BITS_FIRMA &operator++(enum Kunde::B_UPDATE_BITS_FIRMA &s)
{  ++(int&)s;
   return s;
}
enum Kunde::B_UPDATE_BITS_BANK &operator++(enum Kunde::B_UPDATE_BITS_BANK &s)
{  ++(int&)s;
   return s;
}
enum Kunde::B_UPDATE_BITS_SONST &operator++(enum Kunde::B_UPDATE_BITS_SONST &s)
{  ++(int&)s;
   return s;
}

void Kunde::update_e(UpdateBitsAdresse e)
{
  std::string query ="update kunden set ";
  for(B_UPDATE_BITS_ADRESSE i=B_UPDATE_BITS_ADRESSE(0);i<B_MaxAnzA;++i)
   {
     if(!(e&(1<<i))) continue;
//     if      (i==B_Gruppennr  ) query += "gruppennr = '"+itos(GruppenId())+"',";
//     else 
     if (i==B_Sortname   ) query += "sortname = nullif('"+sortname()+"',''),";
     else if (i==B_Idnr       ) query += "idnr = '"+idnr()+"',";
     else if (i==B_Firma      ) query += "firma  = '"+firma()+"',";
     else if (i==B_Name2      ) query += "name2  = '"+name2()+"',";
     else if (i==B_BrAnrede   ) query += "branr  = '"+itos(Anrede()->Id())+"',";
     else if (i==B_Postanwvor ) query += "postanwvor  = '"+postanwvor()+"',";
     else if (i==B_Strasse    ) query += "strasse  = '"+strasse()+"',";
     else if (i==B_Postanwnach) query += "postanwnach  = '"+postanwnach()+"',";
     else if (i==B_Hsnr       ) query += "hsnr  = '"+hausnr()+"',";
     else if (i==B_Plz        ) query += "plz  = '"+plz()+"',";
     else if (i==B_Postfach   ) query += "postfach  = '"+postfach()+"',";
     else if (i==B_Postfachplz) query += "postfplz  = '"+postfachplz()+"',";
     else if (i==B_Ort        ) query += "ort  = '"+ort()+"',";
     else if (i==B_Lkz           ) query += "landid  = '"+itos(land()->Id())+"',";
//     else if (i==B_Lieferadresse  ) query += "lieferadresse  = "+btos(isLieferadresse())+",";
//     else if (i==B_Rechnungadresse) query += "rechnungsadresse  = "+btos(isRechnungsadresse())+",";
//     else if (i==B_Auftragadresse) query += "auftragsadresse  = "+btos(isAuftragsadresse())+",";
     else if (i==B_Rng_an_postfach) query += "rng_an_postfach  = "+btos(Rng_an_postfach())+",";
   }
 query += "stand  = now() where kundennr = "+itos(Id());
 Query::Execute(query);
 SQLerror::test(__FILELINE__);
} 

void Kunde::update_e(UpdateBitsFirma e)
{
  std::string query ="update kunden set ";
  for(B_UPDATE_BITS_FIRMA i=B_UPDATE_BITS_FIRMA(0);i<B_MaxAnzF;++i)
   {
     if(!(e&(1<<i))) continue;
     if      (i==B_Planumsatz    ) query += "planumsatz  = "+planumsatz().String()+",";
     else if (i==B_Umsatz        ) query += "umsatz  = "+umsatz().String()+",";
     else if (i==B_Mitarbeiter   ) query += "mitarbeiter  = "+itos(mitarbeiter())+",";
     else if (i==B_Kundenumsatz  ) query += "kundenumsatz  = "+kundenumsatz().String()+",";
     else if (i==B_Flaeche       ) query += "flaeche  = "+itos(flaeche())+",";
     else if (i==B_UnsereKundenNr) query += "unsere_kundennr  = '"+UnsereKundenNr()+"',";
     else if (i==B_Verein     ) query += "verein = '"+verein()+"',";
   }
 query += "stand  = now() where kundennr = "+itos(Id());
 Query::Execute(query);
 SQLerror::test(__FILELINE__);
} 

void Kunde::update_e(UpdateBitsBank e)
{
  std::string query ="update kunden set ";
  for(B_UPDATE_BITS_BANK i=B_UPDATE_BITS_BANK(0);i<B_MaxAnzB;++i)
   {
     if(!(e&(1<<i))) continue;
     if      (i==B_Ktonr       ) query += "ktonr  = '"+ulltos(getKtnr())+"',";
//     else if (i==B_Blz         ) query += "bankindex  = "+itos(getindex())+",";
     else if (i==B_Bankindex   ) query += "bankindex  = "+itos(getindex())+",";
//     else if (i==B_Bankeinzug  ) query += "bankeinzug  = "+btos(bankeinzug())+",";
     else if (i==B_Rabatt      ) query += "rabatt      = "+rabatt().String()+",";
     else if (i==B_Zeilenrabatt) query += "zeilenrabatt= "+btos(zeilenrabatt())+",";
     else if (i==B_Waehrungid  ) query += "waehrungid  = "+itos(getWaehrung()->Id())+",";
//     else if (i==B_Einzugrabatt) query += "einzugrabatt= "+einzugrabatt().String()+",";
//     else if (i==B_Skontosatz  ) query += "skontosatz  = "+skontosatz().String()+",";
     else if (i==B_Zahlungsart ) query += "zahlungsart = "+itos(zahlungsart()->Id())+",";
     else if (i==B_Lieferantenkonto ) query += "lieferantenkonto = "+itos(getLieferantenkonto())+",";
     else if (i==B_Gegenkonto  ) query += "gegenkonto = "+itos(getGegenkonto())+",";
   }
 query += "stand  = now() where kundennr = "+itos(Id());
 Query::Execute(query);
 SQLerror::test(__FILELINE__);
} 

void Kunde::update_e(UpdateBitsSonst e)
{
  std::string query ="update kunden set ";
  for(B_UPDATE_BITS_SONST i=B_UPDATE_BITS_SONST(0);i<B_MaxAnzS;++i)
   {
std::cout << i<<'\t'<<e<<'\t'<<(e&(1<<i))<<'\n';
     if(!(e&(1<<i))) continue;
     if      (i==B_Rechnungan ) query += "rechnung_an  = "+itos(Rngan())+",";
     else if (i==B_Lieferscheinan ) query += "lieferung_an  = "+itos(Lfran())+",";
     else if (i==B_Extartbezid) query += "extartbezid = "+itos(getSchemaId())+",";
     else if (i==B_Notiz      ) query += "notiz  = '"+notiz()+"',";
     else if (i==B_GebDatum      ) query += "gebdatum  = '"+getGebDatum().postgres_null_if_invalid()+"',";
     else if (i==B_Entsorgung ) query += "entsorgung  = "+btos(entsorgung())+",";
     else if (i==B_Verknr     ) query += "verknr  = "+itos(verkaeufer)+",";
     else if (i==B_Betreuer     ) query += "betreuer  = "+itos(betreuer)+",";
     else if (i==B_AnzAusFirmenPapier) query += "anz_firmenpapier  = "+itos(anzahl_ausdruck_firmenpapier())+",";
     else if (i==B_AnzAusWeissesPapier) query += "anz_weissespapier  = "+itos(anzahl_ausdruck_weissespapier())+",";
     else if (i==B_lieferung_frei_haus) query += "lieferung_frei_haus  = "+btos(get_lieferung_frei_haus())+",";
//     else if (i==B_Kalkulation) query += "kalkulation  = "+itos(kalkulation())+",";
   }
 query += "stand  = now() where kundennr = "+itos(Id());
 Query::Execute(query);
 SQLerror::test(__FILELINE__);
} 

const std::list<std::pair<int,PreisListe::ID> > &Kunde::Preislisten() const
{
 if(prlist_valid) return preislisten;
 
 preislisten.erase(preislisten.begin(),preislisten.end());

  exec sql begin declare section;
   int P,S;
   char *QU;
  exec sql end declare section;
  Transaction tr;

  std::string squery="select prlsnr,suchfolge from ku_warenkorb"
         " where kundennr="+itos(Id())+" order by suchfolge";        
  QU=(char*)squery.c_str();
  exec sql prepare preiscursor_ from :QU;
  exec sql declare preiscursor cursor for preiscursor_;
  exec sql open preiscursor;
  SQLerror::test(__FILELINE__);

  while(!sqlca.sqlcode)
   {
     exec sql fetch preiscursor into :P,:S;
     SQLerror::test(__FILELINE__,100);
     if(sqlca.sqlcode) break;
     preislisten.push_back(std::pair<int,PreisListe::ID>(S,P));
   }
 prlist_valid=true;
 return preislisten;
}


void Kunde::newKontaktperson(const cH_Kunde Person) const
{
  std::string query="insert into ku_ansprech (kundennr,persnr) "
      "values ("+itos(Id())+","+itos(Person->Id())+")";
  Query::Execute(query);  
  SQLerror::test(__FILELINE__);
}

void Kunde::updateKontaktperson(const st_ansprech &A) const
{
  std::string query="update ku_ansprech set _position='"+A.position
      +"', notiz='"+A.notiz+"' "
      " where (kundennr,persnr) = ("+itos(Id())+","+itos(A.Person)+")";
  Query::Execute(query);  
  SQLerror::test(__FILELINE__);
}

void Kunde::deleteKontaktperson(const H_Kunde K,const cH_Kunde P)
{
  std::string query="delete from ku_ansprech  "
      " where (kundennr,persnr) = ("+itos(K->Id())+","+itos(P->Id())+")";
  Query::Execute(query);  
  SQLerror::test(__FILELINE__);
}

void Kunde::deletePreisListe(const PreisListe::ID p) throw(SQLerror)
{
 exec sql begin declare section;
 int KID=Id();
 int PRLSID=p; 
 int SEQ;
 exec sql end declare section;
 Transaction tr;

 exec sql lock table ku_warenkorb in exclusive mode; 
 SQLerror::test(__FILELINE__);   	

 exec sql select suchfolge into :SEQ from ku_warenkorb where
 	kundennr= :KID and prlsnr= :PRLSID;
 SQLerror::test(__FILELINE__);
 
 exec sql delete from ku_warenkorb where kundennr= :KID and prlsnr= :PRLSID;
 SQLerror::test(__FILELINE__);  
 
 exec sql update ku_warenkorb set suchfolge = suchfolge-1 where
 	kundennr= :KID and suchfolge > :SEQ;
 SQLerror::test(__FILELINE__,100);   	

 prlist_valid=false;
 Preislisten(); 
 tr.commit();
}



void Kunde::push_backPreisListe(const PreisListe::ID p) throw(SQLerror)
{
 exec sql begin declare section;
 int KID=Id();
 int PRLSID=p; 
 int SEQ;
 exec sql end declare section;
 Transaction tr;

 exec sql lock table ku_warenkorb in exclusive mode; 
 SQLerror::test(__FILELINE__);   	

 exec sql select coalesce(max(suchfolge),0)+1 into :SEQ from ku_warenkorb
	where kundennr= :KID;
 SQLerror::test(__FILELINE__);   	
 
 exec sql insert into ku_warenkorb (kundennr,prlsnr,suchfolge) values
	(:KID, :PRLSID, :SEQ);
 SQLerror::test(__FILELINE__);   	

 prlist_valid=false;
 Preislisten(); 
 tr.commit();
}



void Kunde::setAktiv(bool _aktiv) throw(SQLerror)
{
 exec sql begin declare section;
 unsigned int KUNDENNR = entityid;
 bool AKTIV=_aktiv;
 exec sql end declare section;

 Transaction tr;

 exec sql update kunden set aktiv = :AKTIV where kundennr = :KUNDENNR;
 SQLerror::test(__FILELINE__);

 isaktiv=_aktiv;
 
 tr.commit();
}

void Kunde::setBetreuer(const ID pid) throw(SQLerror)
{
 exec sql begin declare section;
 unsigned int KUNDENNR = entityid;
 int  BETREUER =pid;
 exec sql end declare section;

 Transaction tr;

 exec sql update kunden set betreuer = :BETREUER where kundennr = :KUNDENNR;
 SQLerror::test(__FILELINE__);

 betreuer=pid;
 
 tr.commit();
}

void Kunde::Preisautomatik(bool pa) throw(SQLerror)
{
 exec sql begin declare section;
 unsigned int KUNDENNR = entityid;
 bool  PREISAUTO =pa;
 exec sql end declare section;

 Transaction tr;

 exec sql update kunden set preisauto = :PREISAUTO where kundennr = :KUNDENNR;
 SQLerror::test(__FILELINE__);

 preisautomatik=pa; 

 tr.commit();
}



void Kunde::showEAN(bool ea) throw(SQLerror)
{
 exec sql begin declare section;
 unsigned int KUNDENNR = entityid;
 bool  SHOWEAN =ea;
 exec sql end declare section;

 Transaction tr;

 exec sql update kunden set showean = :SHOWEAN where kundennr = :KUNDENNR;
 SQLerror::test(__FILELINE__);

 showean=ea; 

 tr.commit();
}


int Kunde::Sprache() const throw(SQLerror)
{
 exec sql begin declare section;
 int SPRID;
 char *LKZ;
 exec sql end declare section;

 LKZ=(char*)land()->LKZ().c_str();

 exec sql select sprid into :SPRID from lkz_sprache
	where lkz = :LKZ;
 SQLerror::test(__FILELINE__,100);

 if(sqlca.sqlcode)
   return 1;

 return SPRID;
}



#ifdef MABELLA_EXTENSIONS
std::string Kunde::getIBAN_Code(bool force) const
{
 if(iban.size() && !force)
   return iban;
 
 init_AuslandZahlung();

 return iban;
}

std::string Kunde::getCAB_Code(bool force) const
{
 if(cab.size() && !force)
   return cab;
 
 init_AuslandZahlung();

 return cab;
}

std::string Kunde::getABI_Code(bool force) const
{
 if(abi.size() && !force)
   return abi;
 
 init_AuslandZahlung();

 return abi;
}

std::string Kunde::getRiBaACC(bool force) const
{
 if(acc.size() && !force)
   return acc;
 
 init_AuslandZahlung();

 return acc;
}


std::string Kunde::getABIBankName(bool force) const
{
 if(abi.size() && !force)
   return bankname;

 init_AuslandZahlung();

 return bankname;
}

void Kunde::init_AuslandZahlung() const throw(SQLerror)
{
 exec sql begin declare section;
 unsigned int KUNDENNR = entityid;
 char *CAB=0;
 char *ABI=0;
 char *IBAN=0;
 char *BANK=0;
 char *ACC=0;
 int ICAB,IABI,IIBAN,IACC;
 exec sql end declare section;

 exec sql select iban,lpad(cab,5,'0'), lpad(abi,5,'0'), account
	into :IBAN:IIBAN,:CAB:ICAB,:ABI:IABI,:ACC:IACC 
	from ausland_bankverbindung where
	kundennr= :KUNDENNR;
 SQLerror::test(__FILELINE__,100);

 if(sqlca.sqlcode==100)
   {abi="";cab="";iban="";acc="";}
 else
   {
    abi=std::string(ABI);
    cab=std::string(CAB);
    iban=std::string(IBAN);
    acc=std::string(ACC);

    exec sql select bankname into :BANK from banken_abicab
	where abi = :ABI;
    SQLerror::test(__FILELINE__,100);
    if(sqlca.sqlcode==100)
      bankname="";
    else
      bankname=BANK;
   }
    
 ECPGfree_auto_mem(); 
}

void Kunde::setABI_CAB(const std::string _abi, const std::string _cab,
			const std::string _acc) const throw(SQLerror)
{
 exec sql begin declare section;
 unsigned int KUNDENNR = entityid;
 char *CAB;
 char *ABI;
 char *ACC;
 int ICAB=0,IABI=0, IACC=0;
 exec sql end declare section;

 CAB=(char*)_cab.c_str();
 ABI=(char*)_abi.c_str();
 ACC=(char*)_acc.c_str();
 
 if(_abi.empty()) IABI=-1;
 if(_cab.empty()) ICAB=-1;
 if(_acc.empty()) IACC=-1;

 Transaction tr;

 exec sql update ausland_bankverbindung set cab=:CAB:ICAB, abi=:ABI:IABI,
		account=:ACC:IACC
	where kundennr= :KUNDENNR;
 SQLerror::test(__FILELINE__,100);

 if(sqlca.sqlcode)
   {exec sql insert into ausland_bankverbindung 
	(kundennr,cab,abi,account) values (:KUNDENNR,:CAB,:ABI,:ACC);
    SQLerror::test(__FILELINE__);
   }

 abi=_abi;
 cab=_cab;
 acc=_acc;

 tr.commit(); 
}


void Kunde::setIBAN(const std::string _iban) const throw(SQLerror)
{
 exec sql begin declare section;
 unsigned int KUNDENNR = entityid;
 char *IBAN;
 exec sql end declare section;

 IBAN=(char*)_iban.c_str();
 
 Transaction tr;

 exec sql update ausland_bankverbindung set iban=:IBAN
	where kundennr= :KUNDENNR;
 SQLerror::test(__FILELINE__,100);

 if(sqlca.sqlcode)
   {exec sql insert into ausland_bankverbindung 
	(kundennr,iban) values (:KUNDENNR,:IBAN);
    SQLerror::test(__FILELINE__);
   }

 iban=_iban;

 tr.commit(); 

}
#endif

std::string Kunde::fixeNotiz(const NotizZiel nz) throw(SQLerror)
{
 std::string column;
 std::string notiz;

 switch(nz)
  {case RNG_NOTIZ : column="rng_notiz"; break;
   case AUF_NOTIZ : column="auf_notiz"; break;
   case LIEF_NOTIZ : column="lief_notiz"; break;
   default : return "";
  }

 std::string query="select "+column+" from kunden where kundennr=?";
 Query(query) << entityid >> FetchIStream::MapNull(notiz,"");
 SQLerror::test(__FILELINE__);

 return notiz;
}


void Kunde::setFixeNotiz(const NotizZiel nz, const std::string n) throw(SQLerror)
{
 std::string column;

 switch(nz)
  {case RNG_NOTIZ : column="rng_notiz"; break;
   case AUF_NOTIZ : column="auf_notiz"; break;
   case LIEF_NOTIZ : column="lief_notiz"; break;
   default : return;
  }

 std::string query="update kunden set "+column+"=? where kundennr=?";
 Query(query) << n << entityid;
 SQLerror::test(__FILELINE__);
}

#ifdef MABELLA_EXTENSIONS
int Kunde::getAbrZyklus() const throw(SQLerror)
{int ret;
 try{
 Query("select coalesce(abrzyklus_mon,1) from ku_verkaeufer where vknr=?")
	<< Id() >> ret;
 }

 catch(SQLerror &e)
 { SQLerror::test(__FILELINE__,100);
   return 0; 
 }

 return ret;
 
}

void Kunde::setAbrZyklus(int mon) const throw(SQLerror)
{
 try{
 Query("update ku_verkaeufer set abrzyklus_mon=? where vknr=?")
	<< mon << Id();
 }

 catch(SQLerror &e)
 { SQLerror::test(__FILELINE__,100);
   return; 
 }
 
}

fixedpoint<2> Kunde::getProvAbschlag() const throw(SQLerror)
{
 fixedpoint<2> ret;
 try{
 Query("select coalesce(abschlag,0) from ku_verkaeufer where vknr=?")
	<< Id() >> ret;
 }

 catch(SQLerror &e)
 { SQLerror::test(__FILELINE__,100);
   return 0; 
 }

 return ret;
}

#endif


void Kunde::set_schema(ID s) throw(SQLerror)
{
 try{
 Query("update kunden set extartbezid=? where kundennr=?")
	<< s << Id();
 }

 catch(SQLerror &e)
 { SQLerror::test(__FILELINE__,100);
   return; 
 }

 schema = s; 
} 


