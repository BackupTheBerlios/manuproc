/*  pps: ManuProC's production planning system
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "RohwarenLager.h"
#include <Artikel/ArtikelBase.h>
#include <Artikel/ArtikelBezeichnung.h>
#include <Aux/Datum.h>
#include <Aux/string0.h>
exec sql include sqlca;
#include <Aux/SQLerror.h>
#include <Aux/Transaction.h>
#include <Aux/itos.h>
#include <unistd.h>
#include <Misc/relops.h>

bool RohwarenLager::RL_Entnahme(st_rohlager& rohlager,std::string &os,bool force,bool ist_leer)
{
  exec sql begin declare section;
   int KARTONS;
   int RESTE;
   int RESTE_KG;
   char POSITION[5];
   char DATUM[11];
   bool DUMMY;
  exec sql end declare section;
  strncpy0(POSITION,rohlager.position.SPosition().c_str(),sizeof(POSITION));
  rohlager.datum.write_postgres(DATUM,sizeof DATUM);

  exec sql select true into :DUMMY from rl_inhalt where position_= :POSITION;
  SQLerror::test(__FILELINE__,100);
  if (sqlca.sqlcode==100) // nichts drin
   {
     os+="           an Position " +rohlager.position.SPosition()+" steht nichts";
     return false;
   }
  st_rohlager was_ist_drin = RL_Inhalt(rohlager.position);
  if(!force)
   {
     if(was_ist_drin.artikel!=rohlager.artikel)
      {
        os+="  an Position "+rohlager.position.SPosition()+" befindet sich"
           +cH_ArtikelBezeichnung(was_ist_drin.artikel)->Bezeichnung() 
           +" vom "+was_ist_drin.datum.c_str()+" ("+itos(was_ist_drin.kartons)+"K.à "
            + itos(was_ist_drin.kg_pro_karton)+ "kg " +itos(was_ist_drin.reste) +"R.="
            + itos(was_ist_drin.reste_kg) + "kg)\n";
        return false;
      }
     if(ist_leer && (was_ist_drin.kartons!=rohlager.kartons ||
                     was_ist_drin.reste!=rohlager.reste ||
                      was_ist_drin.reste_kg!=rohlager.reste_kg))
       {
         os+="Warnung: Laut Daten müßten sich dort ("+rohlager.position.SPosition()
            +") noch "+itos(was_ist_drin.kartons)+"Kartons, " 
            +itos(was_ist_drin.reste)+" Reste("+itos(was_ist_drin.reste_kg) + "kg)\n";
       }
     else if(!ist_leer && (was_ist_drin.kartons<rohlager.kartons ||
                     was_ist_drin.reste<rohlager.reste ||
                      was_ist_drin.reste_kg<rohlager.reste_kg))
       {
         os+="Warnung: Laut Daten befinden sich dort ("+rohlager.position.SPosition()
            +") nur "+itos(was_ist_drin.kartons)+"Kartons, " 
            +itos(was_ist_drin.reste)+" Reste("+itos(was_ist_drin.reste_kg) + "kg)\n";
       }
    }
  std::string misc;
  if(ist_leer || force)
    {
      exec sql delete from rl_inhalt where position_= :POSITION;
      SQLerror::test(__FILELINE__);                  
      if(force) misc="lösc";
      else misc="leer";
    }  
  else 
    {
      KARTONS=was_ist_drin.kartons-rohlager.kartons;
      if (KARTONS<0) KARTONS=0;
      RESTE=was_ist_drin.reste-rohlager.reste;
      if (RESTE<0) RESTE=0;
      RESTE_KG=was_ist_drin.reste_kg-rohlager.reste_kg; ;   
      if (RESTE_KG<0) RESTE_KG=0;

       exec sql update rl_inhalt set kartons= :KARTONS, reste= :RESTE,
          rest_kg=:RESTE_KG, letzte_entnahme= :DATUM 
          where position_= :POSITION;
       SQLerror::test(__FILELINE__);                  
    }
   rohlager.kg_pro_karton=was_ist_drin.kg_pro_karton;
   if (force) RL_Log(was_ist_drin,RLEntnehmen,misc);
   else       RL_Log(rohlager,RLEntnehmen,misc);
   return true;
}


bool RohwarenLager::RL_Einlagern(const LagerPlatz position,st_rohlager& rohlager,std::string &os,bool force)
{
  rohlager.setPosition(position);

  exec sql begin declare section;
   int KARTONS=rohlager.kartons;
   int KG_PER_KARTON=rohlager.kg_pro_karton;
   int RESTE=rohlager.reste;
   int RESTE_KG=rohlager.reste_kg;
   int MATERIAL=rohlager.artikel.Id();
   char POSITION[5];
   char DATUM[11];
   bool DUMMY;
  exec sql end declare section;
  strncpy0(POSITION,rohlager.position.SPosition().c_str(),sizeof(POSITION));
  rohlager.datum.write_postgres(DATUM,sizeof DATUM);

  exec sql select true into :DUMMY from rl_inhalt where position_= :POSITION;
  SQLerror::test(__FILELINE__,100);
  if (sqlca.sqlcode==100) // nichts drin also rein damit
   {
      exec sql insert into rl_inhalt
        (position_, kartons, MATERIAL, KG_PER_KARTON,
              reste, rest_kg, eingelagert)
        values (:POSITION, :KARTONS, :MATERIAL, :KG_PER_KARTON,
              nullif(:RESTE,0), nullif(:RESTE_KG,0), :DATUM);
      SQLerror::test(__FILELINE__);
      RL_Log(rohlager,RLEinlagern);
      return true;
   }
  else  // ups, auf dieser Position liegt schon etwas
   {
     st_rohlager was_ist_drin = RL_Inhalt(rohlager.position);
     if(force) // überschreiben, ohne Rücksicht auf Material
      {
        exec sql update rl_inhalt set 
           kartons=:KARTONS, material=:MATERIAL, 
           kg_per_karton=:KG_PER_KARTON, reste=nullif(:RESTE,0), 
           rest_kg=nullif(:RESTE_KG,0), eingelagert=:DATUM where position_=:POSITION;
        SQLerror::test(__FILELINE__);
        RL_Log(was_ist_drin,RLEntnehmen,"lösc");
        RL_Log(rohlager,RLEinlagern);
        return true;
      }
     else // mal schauen ...
      {
        if(was_ist_drin.artikel==rohlager.artikel)
         {
           if (!was_ist_drin.kg_pro_karton) was_ist_drin.kg_pro_karton=rohlager.kg_pro_karton;
           if (!rohlager.kg_pro_karton) rohlager.kg_pro_karton=was_ist_drin.kg_pro_karton;
             // gleicher Artikel, gleiche Paketgröße also
             // neue Menge zu alter Menge hinzuaddieren und rein damit
           if (rohlager.kg_pro_karton==was_ist_drin.kg_pro_karton)
            {
              KARTONS = rohlager.kartons + was_ist_drin.kartons;
              KG_PER_KARTON=rohlager.kg_pro_karton;
              RESTE=rohlager.reste + was_ist_drin.reste;
              RESTE_KG=rohlager.reste_kg + was_ist_drin.reste_kg;    
              exec sql update rl_inhalt set 
                 kartons=:KARTONS, material=:MATERIAL,
                  kg_per_karton=:KG_PER_KARTON, 
                       reste=nullif(:RESTE,0), rest_kg=nullif(:RESTE_KG,0),
                        eingelagert=:DATUM where position_=:POSITION;
              SQLerror::test(__FILELINE__);
              RL_Log(rohlager,RLEinlagern);
              return true;
            }
           else 
            {
              os = "  an Position " + rohlager.position.SPosition() + " sollen "
                + itos(was_ist_drin.kg_pro_karton) + "kg "
                +  cH_ArtikelBezeichnung(was_ist_drin.artikel)->Bezeichnung()
                +  " im Karton sein.\n";
              return false;
            }
         }
        else // Die Materiaien stimmen nicht überein
         {
           os ="  an Position " +rohlager.position.SPosition()+" befindet sich "
            + cH_ArtikelBezeichnung(was_ist_drin.artikel)->Bezeichnung() + " vom "
            + was_ist_drin.datum.c_str() + " ("+itos(was_ist_drin.kartons)+"K.à "
            + itos(was_ist_drin.kg_pro_karton)+ "kg " +itos(was_ist_drin.reste)+ "R.="
            + itos(was_ist_drin.reste_kg) + "kg)\n";
           return false;
         }
      }  
   }
 assert(!" RohwarenLager::RL_Einlagern: Fehler");
}

void RohwarenLager::RL_Log(const st_rohlager& rohlager,RL_LogTyp typ,const std::string& misc)
{
  exec sql begin declare section;
   int KARTONS=rohlager.kartons;
   int KG_PER_KARTON=rohlager.kg_pro_karton;
   int RESTE=rohlager.reste;
   int RESTE_KG=rohlager.reste_kg;
   int MATERIAL=rohlager.artikel.Id();
   char MISC[5];
   char POSITION[5];
   char DATUM[11];
   char TYP=typ;
  exec sql end declare section;
  strncpy0(POSITION,rohlager.position.SPosition().c_str(),sizeof(POSITION));
  strncpy0(MISC,misc.c_str(),sizeof(MISC));

  rohlager.datum.write_postgres(DATUM,sizeof DATUM);
  if(typ==RLEinlagern)
   {
    exec sql insert into rl_log 
       (zeit,position_, kartons, MATERIAL, KG_PER_KARTON, typ, valuta, reste, rest_kg,misc)
       values (now(),:POSITION,:KARTONS,:MATERIAL,:KG_PER_KARTON,:TYP,:DATUM,
            :RESTE,:RESTE_KG,nullif(:MISC,''));
   }
  else if(typ==RLEntnehmen)
   {
    exec sql insert into rl_log 
       (zeit,position_, kartons, MATERIAL, KG_PER_KARTON, typ, valuta, reste, rest_kg,misc)
       values (now()-timespan('1 sec'),:POSITION,:KARTONS,:MATERIAL,
            :KG_PER_KARTON,:TYP,:DATUM,:RESTE,:RESTE_KG,nullif(:MISC,''));
   }
  else assert(!"RohwarenLager::RL_Log: Falscher Typ\n");
  SQLerror::test(__FILELINE__);
  ///////////////////////////////////////////////////////////////
  // Jetzt die Lagerbewegung mit den offenen Aufträgen verrechen.
  // Einlagern wird durch Lieferscheine geregelt.
  if(typ==RLEntnehmen)
   {
     AuftragBase::mengen_t menge = rohlager.kartons*rohlager.kg_pro_karton 
                                    + rohlager.reste_kg;
     raus_aus_lager(rohlager.artikel,menge,getuid());
   }
}


RohwarenLager::st_rohlager RohwarenLager::RL_Inhalt(const LagerPlatz position) const
{
  exec sql begin declare section;
   int KARTONS, KG_PER_KARTON, RESTE, RESTE_KG, MATERIAL;
   char POSITION[5];
   char DATUM[11];
  exec sql end declare section;
  strncpy(POSITION,position.SPosition().c_str(),5);
  exec sql select coalesce(kartons,0), coalesce(reste,0),
      int4(coalesce(kg_per_karton,0)), int4(coalesce(rest_kg,0)),
      material, eingelagert into :KARTONS, :RESTE, 
            :KG_PER_KARTON, :RESTE_KG, :MATERIAL, :DATUM
      from rl_inhalt where position_= :POSITION;
  SQLerror::test(__FILELINE__,100);
  ManuProC::Datum date; 
  if(sqlca.sqlcode==100)
   {
     return st_rohlager(position,0,0,0,0, ArtikelBase(0),date);
   }
  else 
   {
     date.from_postgres(DATUM);
     return st_rohlager(position,KARTONS,KG_PER_KARTON,RESTE,RESTE_KG,
                  ArtikelBase(MATERIAL),date);
   }
}  

std::vector<class LagerInhalt> RohwarenLager::LagerInhalt_(const ArtikelBase& artikel) const
{
  exec sql begin declare section;
   int KG, RESTE_KG, MATERIAL,KARTONS,RESTKARTONS;
   char QUERY[1024];
  exec sql end declare section;

  std::string squery ="select material,coalesce(kartons,0),coalesce(reste,0), "
      " coalesce(int4(sum(kartons*kg_per_karton)),0),"
      " coalesce(int4(sum(coalesce(rest_kg,0))),0) "
      " from rl_inhalt ";
  if(artikel.valid()) squery += " where material ="+itos(artikel.Id());
  squery +=" group by material,kartons,reste ";

  strncpy(QUERY,squery.c_str(),sizeof(QUERY));
  exec sql prepare r_summe_ from :QUERY;
  exec sql declare r_summe cursor for r_summe_;
  Transaction tr;
  exec sql open r_summe;
  SQLerror::test(__FILELINE__);
  std::vector<class LagerInhalt> V;
  while(true)
   {
     exec sql fetch r_summe into :MATERIAL,:KARTONS,:RESTKARTONS,:KG,:RESTE_KG;
     SQLerror::test(__FILELINE__,100);
     if(sqlca.sqlcode) break;
     V.push_back(class LagerInhalt(MATERIAL,KARTONS,RESTKARTONS,KG,RESTE_KG));
   }
 return V;
}
