// $Id: AufEintrag_sql.pgcc,v 1.59 2003/03/10 10:24:20 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Misc/TraceNV.h>
#include <Auftrag/AufEintrag.h>
#include <Auftrag/AuftragsBaum.h>
#include <stdio.h>
#include <Misc/string0.h>
#include <Misc/Transaction.h>
#include <Misc/FetchIStream.h>
#include "auftrag_status.h"
#include <Misc/Changejournal.h>
#include "selFullAufEntry.h"
#include <Auftrag/AufEintragZu.h>
#include <Lager/Lager.h>
#include <Lieferschein/Lieferschein.h>
#ifdef MABELLA_EXTENSIONS
#include <Lager/FertigWaren.h>
#include <Artikel/ArtikelBase.h>
#endif
#include <Artikel/ArtikelStamm.h>
#include <Auftrag/Auftrag.h>
#include <algorithm>
#include <unistd.h>
#include <Auftrag/VerfuegbareMenge.h>
#include <Misc/FetchIStream_ops.h>
#include <Auftrag/AufEintrag_macros.h>

// Menge wurde geliefert. 
// Um die Pfeile über uns muss sich jemand anderes kümmern

// menge kann negativ sein ...
// wo wird der 2er reduziert?
// wo werden die Instanzen darunter behandelt?
// ==> WurdeProduziert macht das ganze rekusiv
void AufEintrag::abschreiben(mengen_t menge,ManuProcEntity<>::ID lfrsid) throw(SQLerror)
{int uid=getuid();
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"Menge=",menge,"Lfrsid=",lfrsid);

  mengen_t GELIEFERT=getGeliefert()+menge;
  mengen_t BESTELLT=getStueck();
  AufStatVal STATUS=getEntryStatus();

 if(menge>=0 && getEntryStatus()!=(AufStatVal)OPEN) 
    throw(SQLerror(__FILELINE__,-1,"Auftragszeile ist nicht offen sondern "+itos(STATUS)));
 if(menge<0 && getEntryStatus()==(AufStatVal)UNCOMMITED) 
    throw(SQLerror(__FILELINE__,-1,"Auftragszeile ist nicht bestätigt"));
 if (menge<0 && -menge>getGeliefert()) 
 {  menge=-getGeliefert(); GELIEFERT=0; }

 if (!menge) return;

 AufStatVal oldstatus=getEntryStatus();

 if(mengen_t(GELIEFERT)>=getStueck()) STATUS=(AufStatVal)CLOSED;
 else if(menge<0 && mengen_t(GELIEFERT)<getStueck()) STATUS=(AufStatVal)OPEN;

 Transaction tr;
 Query("lock table auftragentry in exclusive mode");
 bool delete_entry=false;

  // Lieferung rückgängig machen, dann 1er löschen wenn es alle Menge war
  if(menge<0 &&
     Instanz()!=ppsInstanzID::Kundenauftraege && 
     !Instanz()->ProduziertSelbst() && 
     Id()==AuftragBase::plan_auftrag_id)
   {
     BESTELLT+=menge.as_int();
     if(BESTELLT<0) BESTELLT=0;
     if(BESTELLT==GELIEFERT) STATUS=CLOSED;
     if(BESTELLT==0 && GELIEFERT==0 &&  STATUS==CLOSED) delete_entry=true;
   }   

 if(delete_entry)
   Query("delete from auftragentry where (instanz,auftragid,zeilennr) = (?,?,?)").lvalue()
     << static_cast<const AufEintragBase&>(*this);
 else
   Query("update auftragentry set geliefert=?, status=?, "
     "bestellt=?, letzte_lieferung=now() "
     "where (instanz,auftragid,zeilennr) = (?,?,?)").lvalue()
     << GELIEFERT << STATUS << BESTELLT 
     << static_cast<const AufEintragBase&>(*this);
 SQLerror::test(__FILELINE__);

#ifdef MABELLA_EXTENSIONS // Lager updaten
#warning Jacek: Das muss raus, sobald es mehrstufig ist
 if(Instanz() == ppsInstanzID::Kundenauftraege)
   {
    FertigWaren fw(Artikel(),(FertigWaren::enum_Aktion)'L',menge.as_int(),lfrsid);
    if(menge < 0) fw.Einlagern(1);
    else if(menge > 0) fw.Auslagern(1);
   }
#endif

 geliefert=GELIEFERT;
 if(geliefert>=bestellt) entrystatus=(AufStatVal)CLOSED;

 // zumindest 2er werden nie geschlossen, nur auf 0 gesetzt
 if(STATUS!=oldstatus && Id()!=dispo_auftrag_id)
     setStatus(AufStatVal(STATUS),uid,true);
 
 // eigentlich könnte das if hier weg ... geht aber schneller so
 // dispomenge auf offene Menge beschränken
 if (Instanz() != ppsInstanzID::Kundenauftraege) DispoBeschraenken(uid);

 tr.commit();
}


void AufEintrag::setStatus(AufStatVal newstatus,int uid,bool force) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"Status=",newstatus,"Force=",force);
 if(entrystatus == newstatus)
 {  ManuProC::Trace(AuftragBase::trace_channel,__FILELINE__,*this,"status bereits",newstatus);
    return;
 }
 if(newstatus == STORNO) force=true;
 if(newstatus == STORNO && getGeliefert()!=mengen_t(0))  
 {  std::cerr << "Kann nicht storniert werden da bereits geliefert\n";
    return;
 }
 if(entrystatus == CLOSED && !force )
 {  std::cerr << "Auftragszeile bereits geschlossen\n";
    return;
 }
 if(newstatus == UNCOMMITED)
 {  std::cerr << "bestätigte Zeilen können nicht wieder unbestätigt werden\n";
    return;
 }
 if(newstatus == OPEN && entrystatus != UNCOMMITED && !force)
 {  std::cerr << "nur unbestätigte Zeilen können geöffnet werden\n";
    return;
 }

 Transaction tr; 
 Query("lock auftragentry in exclusive mode");
 SQLerror::test("setStatus: lock table auftragentry");

 // InternAbbestellen
 if(newstatus == CLOSED || newstatus == STORNO)
     ArtikelInternAbbestellen(uid,getRestStk(),ManuProC::Auftrag::r_Closed);

 std::string sqlcommand = "update auftragentry set status="+itos(newstatus);
 if(uid) sqlcommand+=", lasteditdate = now(), lastedit_uid="+itos(uid);
 sqlcommand +=" where (instanz,auftragid,zeilennr)=("+itos(Instanz()->Id())
              +","+itos(auftragid)+","+itos(zeilennr)+")";

 Query::Execute(sqlcommand);
 SQLerror::test("setStatus: update auftragentry");
 AufStatVal oldentrystatus=entrystatus;
 entrystatus=newstatus;


 if(newstatus==OPEN && auftragstatus==UNCOMMITED)
 {  setStatusAuftragBase(newstatus);
    auftragstatus=newstatus;
 }

 if(newstatus == OPEN  &&  oldentrystatus==UNCOMMITED)
    ArtikelInternNachbestellen(uid,getRestStk(),ManuProC::Auftrag::r_Anlegen);

 if(newstatus==OPEN)
   {
    pps_ChJournalEntry::newChange(
			instanz, *this, artikel,
			bestellt.as_float(),
			bestellt.as_float(),
			pps_ChJournalEntry::CH_MENGE);
  }
 else if(newstatus==CLOSED && oldentrystatus!=UNCOMMITED) 
 // UNCOMMITED->CLOSED => kein Eintrag
   {
    pps_ChJournalEntry::newChange(
			instanz, *this, artikel,
			geliefert.as_float(),
			(geliefert-bestellt).as_float(),
			pps_ChJournalEntry::CH_MENGE);
   }

 tr.commit(); 
}

// statische Variante (behandelt z.B. Vormerkungen, freie Menge etc.)
AufEintragBase AufEintrag::ArtikelInternNachbestellen(const cH_ppsInstanz &wo,
  mengen_t menge,const ManuProC::Datum &lieferdatum,const ArtikelBase& artikel,
  int uid,const AufEintragBase& ElternAEB)
{  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,
   	wo,menge,lieferdatum,artikel,"ElternAEB=",ElternAEB);
   if (!menge) return AufEintragBase(); // hmmm
   assert(menge>0);
   assert(ElternAEB.valid());

   // 2er Menge (freie Menge im Lager, freie Produktionsplanung)
   // vormerken
   VerfuegbareMenge AIL(wo,artikel,lieferdatum);
   mengen_t M_dispo=AuftragBase::min(AIL.getMengeDispo(),menge);
   if(M_dispo>0) menge-=AIL.reduce_in_dispo(uid,M_dispo,ElternAEB);

   // Im Lager von späteren Aufträgen vorgemerkte Menge wegschnappen
   if (menge>0 && wo->LagerInstanz())
   {  M_dispo=AuftragBase::min(AIL.getMengePlan(),menge);
      menge-=AIL.reduce_in_plan(uid,M_dispo,ElternAEB);
   }
   // Rest nachbestellen
   AuftragBase ab(wo,ungeplante_id);
   int znr=ManuProcEntity<>::none_id;
   if (menge>0)
      znr=ab.BestellmengeAendern(menge,lieferdatum,artikel,OPEN,uid,ElternAEB);
   return AufEintragBase(ab,znr);
}

// ehemals updateStkDiffInstanz__ mit menge>0
// + ehemals BaumAnlegen
void AufEintrag::ArtikelInternNachbestellen(int uid,mengen_t menge,
	ManuProC::Auftrag::Action reason) const
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,
   "menge=",menge,"Reason=",reason);
  assert(menge>0);
  assert(Id()!=dispo_auftrag_id);

  if (Instanz()==ppsInstanzID::Kundenauftraege)  
  {  cH_ppsInstanz i=ppsInstanz::getBestellInstanz(Artikel());
     if (i!=ppsInstanzID::None && i!=ppsInstanzID::Kundenauftraege)
     {  AufEintrag::ArtikelInternNachbestellen(i,menge,
		getLieferdatum(),Artikel(),uid,*this);
     }
  }
  else if (Instanz()->LagerInstanz())
  {  assert(Id()==ungeplante_id);
     ArtikelInternNachbestellen(ppsInstanz::getProduktionsInstanz(Artikel()),
     		menge,getLieferdatum(),Artikel(),uid,*this);
  }
  else
  {  ManuProC::Datum newdate=getLieferdatum()-Instanz()->ProduktionsDauer();

     ArtikelBaum AB(Artikel());
     for(ArtikelBaum::const_iterator i=AB.begin();i!=AB.end();++i)
     {  ArtikelInternNachbestellen(ppsInstanz::getBestellInstanz(i->rohartikel),
  		i->menge*menge,newdate,i->rohartikel,uid,*this);
     }
  }
}

// bei 2ern geht der Pfeil in die andere Richtung
AuftragBase::mengen_t AufEintrag::MengeAendern(int uid,mengen_t menge,bool instanzen,
     const AufEintragBase &ElternAEB,ManuProC::Auftrag::Action reason) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,
   "Eltern=",ElternAEB,
   "menge=",menge,"instanzen=",instanzen,"reason=",reason);
 assert(reason!=ManuProC::Auftrag::r_None);
 if (!menge)  return menge;

 Transaction tr; // Beschleunigung
 Query("lock auftragentry in exclusive mode");
 SQLerror::test("updateStkDiff: lock table auftragentry");

 mengen_t menge2=menge;
 if (menge2<0) // nicht mehr abbestellen als noch offen ist
 		// aber dennoch den Pfeil reduzieren
 {  menge2=-AuftragBase::min(-menge2,getRestStk());
 }
 if (!!menge2) 
 { menge2=updateStkDiffBase__(uid,menge2);
   bestellt+=menge2;
 }

 if (ElternAEB.valid()) 
 {  if (Id()!=dispo_auftrag_id) AufEintragZu(ElternAEB).Neu(*this,menge);
    // bei dispoaufträgen geht der Pfeil in die andere Richtung
    else AufEintragZu(*this).Neu(ElternAEB,menge);
 }

 if(auftragstatus==OPEN)
  {
   // Rekursion von 2ern verbieten
   assert(Id()!=dispo_auftrag_id || !instanzen); 
   // keine Rekursion bei 1er im Lager 
   // Rekursion bei 1er oder 3er in Produktion
   if ((!Instanz()->LagerInstanz() || Id()==AuftragBase::ungeplante_id) 
   	&& instanzen)
      updateStkDiffInstanz__(uid,menge2,*this,reason);
  }
  tr.commit();
 return menge2;
}

namespace {
class ArtikelInternAbbestellen_cb
{	unsigned uid;
	ManuProC::Auftrag::Action reason;
	const AufEintrag &mythis;

public:
	ArtikelInternAbbestellen_cb(const AufEintrag &_mythis, unsigned _uid, ManuProC::Auftrag::Action _reason)
		: uid(_uid), reason(_reason), mythis(_mythis)
	{}
	AuftragBase::mengen_t operator()(const ArtikelBase &,
 		const AufEintragBase &,AuftragBase::mengen_t) const;
};
}

AuftragBase::mengen_t ArtikelInternAbbestellen_cb::operator()
	(const ArtikelBase &i,
 		const AufEintragBase &j,AuftragBase::mengen_t M) const
{  AufEintrag AE(j);
   if(j.Id()==AuftragBase::ungeplante_id || j.Instanz()->LagerInstanz())
      M=-AE.MengeAendern(uid,-M,true,AufEintragBase(),reason);
   else // Abbestellung im Lager
     {
       assert(j.Id()!=AuftragBase::dispo_auftrag_id);
       AuftragBase::dispo_auftrag_aendern(uid,j.Instanz(),i,M,AE.getLieferdatum(),j);
     } 
   AufEintragZu(mythis).setMengeDiff__(j,-M);
   if(j.Instanz()->LagerInstanz() && 
      j.Id()==AuftragBase::plan_auftrag_id)
       AuftragBase::dispo_auftrag_aendern(uid,j.Instanz(),i,M,LagerBase::Lagerdatum(),AufEintragBase());
   return M;
}

void AufEintrag::ArtikelInternAbbestellen(int uid,mengen_t menge,ManuProC::Auftrag::Action reason) const
{ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,
   "menge=",menge,"Reason=",reason);

 assert(menge>0);
 try{
      distribute_children(*this,menge,ArtId(),
   			ArtikelInternAbbestellen_cb(*this,uid,reason));
  }catch(NoAEB_Error &e) 
  {std::cerr <<"Falsche Anzahl von AufEinträgen: "<<e.what()<<'\n'; 
   exit(1);}
}

void AufEintrag::updateStkDiffInstanz__(int uid,mengen_t menge,const AufEintragBase &ElternAEB,ManuProC::Auftrag::Action reason) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,
   "ElternAEB=",ElternAEB,"Menge=",menge,"Reason=",reason);
 if (menge<0) 
 {  assert(ElternAEB==AufEintragBase(*this)); // ?
    ArtikelInternAbbestellen(uid,-menge,reason);
 }
 else 
 {  assert(ElternAEB==AufEintragBase(*this));
    ArtikelInternNachbestellen(uid,menge,reason);
 }
}

void AufEintrag::updatePreis(const Preis &pr) throw(SQLerror)
{ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__);
 Query("update auftragentry "
 	"set preis=?, preismenge=? "
 	"where (instanz,auftragid,zeilennr)=(?,?,?)").lvalue()
 	<< pr.Wert() << pr.PreisMenge() 
 	<< static_cast<const AufEintragBase&>(*this);
 SQLerror::test("updatePreis: update preis in auftragentry");
 preis=pr;
}



void AufEintrag::updateRabatt(rabatt_t rb) throw(SQLerror)
{ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__);
 Query("update auftragentry "
 	"set rabatt=? "
 	"where (instanz,auftragid,zeilennr)=(?,?,?)").lvalue()
 	<< rb 
 	<< static_cast<const AufEintragBase&>(*this);
 SQLerror::test("updateRabatt: update rabatt in auftragentry");
 rabatt=rb;
}


void AufEintrag::updateLieferdatum(const Petig::Datum &ld,int uid) throw(SQLerror)
{ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"Datum=",ld);
 Transaction tr;
 Query("lock auftragentry in exclusive mode"); // unnötig? CP
 SQLerror::test("updateLieferdatum: lock table auftragentry");

 ArtikelInternAbbestellen(uid,getStueck(),ManuProC::Auftrag::r_Anlegen);

 Query("update auftragentry "
 	"set lieferdate=? "
 	"where (instanz,auftragid,zeilennr)=(?,?,?)").lvalue()
 	<< ld
 	<< static_cast<const AufEintragBase&>(*this);
 SQLerror::test("updateLiefDatum: update lieferdate in auftragentry");
 lieferdatum=ld;

 ArtikelInternNachbestellen(uid,getStueck(),ManuProC::Auftrag::r_Anlegen);

 if(entrystatus==OPEN)// status->entrystatus
  {
   try 
    {
     pps_ChJournalEntry::newChange(
  			instanz, *this,
  			artikel, ld,
  			(double)(ld-getLieferdatum()),
  			pps_ChJournalEntry::CH_LIEFDAT);
    }
   catch(SQLerror &e)
     {tr.rollback(); throw; }
  }
 
 tr.commit(); 
}

#include <Misc/relops.h>
  
int AufEintrag::split(int uid,mengen_t newmenge, const Petig::Datum &newld,bool dispoplanung) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"NewMenge=",newmenge,"NewDatum=",newld,"dispoplanung(bool)=",dispoplanung);
 if(entrystatus==CLOSED) return none_znr;

 mengen_t BESTELLT_OLD=bestellt-newmenge;
 int STATUS=entrystatus;

 double GELIEFERT;
 double GELIEFERT_OLD;

 if(lieferdatum>newld)
   {GELIEFERT=(geliefert>newmenge ? mengen_t(newmenge) : geliefert).as_float();
    GELIEFERT_OLD=(geliefert>newmenge ? geliefert-mengen_t(newmenge) : mengen_t(0)).as_float();}
 else
   {GELIEFERT_OLD=(geliefert>BESTELLT_OLD ? mengen_t(BESTELLT_OLD) : geliefert).as_float();
    GELIEFERT=(geliefert>BESTELLT_OLD ? geliefert-mengen_t(BESTELLT_OLD) : mengen_t(0)).as_float();}
    
 Transaction tr;
 Query("lock auftragentry in exclusive mode");
 SQLerror::test("split: lock table auftragentry");

 mengen_t mt=MengeAendern(uid,-newmenge,true,AufEintragBase(),ManuProC::Auftrag::r_Anlegen);
 assert(mt==-newmenge);

 int ZEILENNR;
 if(Instanz()==ppsInstanzID::Kundenauftraege)
   {Auftrag A(*this);
    AufEintragBase newaeb=A.push_back(newmenge,newld,artikel,entrystatus,uid,true,preis,rabatt);
    ZEILENNR=newaeb.ZNr();
   }
 else
   ZEILENNR=split_zuordnungen_to(newmenge,newld,artikel,entrystatus,uid,dispoplanung);

 if(STATUS==OPEN)
   {   pps_ChJournalEntry::newChange(
    			instanz, *this,
    			artikel, BESTELLT_OLD.as_float(), (BESTELLT_OLD-bestellt).as_float(),
    			pps_ChJournalEntry::CH_MENGE);
       pps_ChJournalEntry::newChange(
    			instanz, *this,
    			artikel, newmenge.as_float(), newmenge.as_float(),
    			pps_ChJournalEntry::CH_MENGE);
   }

 tr.commit();
 return ZEILENNR;
}

AufEintrag::AufEintrag(const AufEintragBase &aebb) throw (SQLerror,NoAEB_Error)
  : AufEintragBase(aebb), 
    artikel(0),
    prozess(Prozess::default_id)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,aebb);
 try{
  SelectedFullAufList aufids((SQLFullAuftragSelector)
    (SQLFullAuftragSelector::sel_AufidZnr(aebb)));

  if ( aufids.aufidliste.size()!=1 ) throw NoAEB_Error(aufids.aufidliste.size());

  *this=*(aufids.aufidliste.begin());
 } catch (SQLerror &e) {std::cerr << e <<'\n';}
}

// hässlich ! warum denn ein cH_Lieferschein statt eines LieferscheinEntryBase?
cH_Lieferschein AufEintrag::getLieferschein() const
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__);
  int LFRSID,LFRZNR;
 // bislang cH_Lieferschein(ppsInstanzID::None,0); wenn keine Zeile
 // jetzt SQLerror
 Query("select lfrsid,zeile from lieferscheinentry "
 	"where (instanz,refauftragid,refzeilennr)=(?,?,?) "
 	"limit 1").lvalue()
 	<< static_cast<const AufEintragBase&>(*this)
 	>> LFRSID >> LFRZNR;
#warning kann es mehr als eine Zeile geben? 
 return cH_Lieferschein(Instanz(),LFRSID);
}

// Aufruf: ProduziertNG(uid,RestStk(),ElternAEB,ElternAEB)

namespace {
class ProduziertNG_cb
{	AufEintrag &mythis;
	unsigned uid;
public:	
	void operator()(const AufEintragBase &elter,AuftragBase::mengen_t m) const
	{  mythis.ProduziertNG(uid,m,elter,elter);
	}
	ProduziertNG_cb(AufEintrag &_mythis) : mythis(_mythis), uid(getuid()) {}
};
}

void AufEintrag::ProduziertNG(AuftragBase::mengen_t M)
{  distribute_parents(*this,M,ProduziertNG_cb(*this));
}

namespace {
class ProduziertNG_cb2
{  unsigned uid;
   AufEintragBase alterAEB,neuerAEB;
public:
	ProduziertNG_cb2(unsigned _uid, const AufEintragBase &aAEB, const AufEintragBase &nAEB)
		: uid(_uid), alterAEB(aAEB), neuerAEB(nAEB) {}
	AuftragBase::mengen_t operator()(const ArtikelBase &art,
		const AufEintragBase &aeb,AuftragBase::mengen_t M) const
	{  if (!aeb.Instanz()->ProduziertSelbst())
              AufEintrag(aeb).ProduziertNG(uid,M,alterAEB,neuerAEB);
           else AufEintragZu(alterAEB).setMengeDiff__(aeb,-M);
           return M;
	}
};
}

// similar to move_to	
void AufEintrag::ProduziertNG(unsigned uid, AuftragBase::mengen_t M,
		const AufEintragBase &elter_alt,
		const AufEintragBase &elter_neu)
{  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,M,elter_alt,elter_neu);
   assert(M>=0); // notwendig?
   
   AufEintragBase neuerAEB=*this;
   if (Instanz()->LagerInstanz()) // && Id()==ungeplante_id)
   {  assert(Id()==ungeplante_id);
      MengeAendern(uid,-M,false,elter_alt,ManuProC::Auftrag::r_Produziert);
      // Menge wird woanders vorgemerkt ... wo? CP
      // he, deshalb habe ich keinen neuerAEB zum verzeigern ...
   }
   else if (Id()==AuftragBase::plan_auftrag_id 
	|| Id()>=AuftragBase::handplan_auftrag_id)
   {  // auch in Produziert()
      // könnte man vorziehen, wenn unten elter_alt wegfallen würde
      AufEintragZu(elter_alt).setMengeDiff__(*this,-M);
      // neuerAEB=*this;
      abschreiben(M);
   }
   else
   {  // keine Rekursion!  // und für Lager?
      MengeAendern(uid,-M,false,elter_alt,ManuProC::Auftrag::r_Produziert);
      AuftragBase zielauftrag(Instanz(),plan_auftrag_id);
      zielauftrag.create_if_not_exists(OPEN);
      neuerAEB=AufEintragBase(zielauftrag,
      		zielauftrag.PassendeZeile(getLieferdatum(),Artikel(),OPEN,uid));
      // elter_neu übergeben?
      AufEintrag ae(neuerAEB);
      ae.MengeAendern(uid,M,false,AufEintragBase(),ManuProC::Auftrag::r_Produziert);
      ae.abschreiben(M);
   }
   // Pfeil mindestens anlegen, wenn auch mit Menge 0
   if (elter_alt!=elter_neu) 
      AufEintragZu(elter_neu).setMengeDiff__(neuerAEB,0);
   // Kinder bearbeiten
   distribute_children(*this,M,Artikel(),ProduziertNG_cb2(uid,*this,neuerAEB));

   cH_ppsInstanz EI=Instanz()->EinlagernIn();
   if(EI->AutomatischEinlagern())
   {  assert(Instanz()->ProduziertSelbst()); // sonst Endlosrekursion
      LagerBase(EI).rein_ins_lager(Artikel(),M,uid);
   }
}

// wird bislang von menge_neu_verplanen für 0er aufgerufen
// vermutlich ehemals abschreiben_oder_reduzieren 
// & ehemals ppsInstanz::Produziert
void AufEintrag::WurdeProduziert(AuftragBase::mengen_t M,const AufEintragBase &ElternAEB)
{  int uid=getuid();
   ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,M,"Eltern=",ElternAEB);
   assert(M>=0);

   ProduziertNG(uid,M,ElternAEB,ElternAEB);
}

#if 0
void AufEintrag::ProduktionRueckgaengig(AuftragBase::mengen_t M)
{
}
#endif

// auf noch offene Menge beschränken
// uid mitgeben?
void AufEintrag::DispoBeschraenken(int uid)
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
  AufEintragZu::list_t L=AufEintragZu::get_Referenz_list(*this,AufEintragZu::list_eltern,AufEintragZu::list_ohneArtikel);

  AuftragBase::mengen_t S=0;
  for(AufEintragZu::list_t::const_iterator i=L.begin();i!=L.end();++i)
   {
     if(i->AEB.Id()==AuftragBase::dispo_auftrag_id) S+=i->Menge;
   }
  if (getRestStk()<S)
  {   ManuProC::Trace(AuftragBase::trace_channel, __FILELINE__,
  		"Dispo muss um ",S-getRestStk()," erniedrigt werden");
      for(AufEintragZu::list_t::const_iterator i=L.begin();i!=L.end();++i)
      {
        if(i->AEB.Id()==AuftragBase::dispo_auftrag_id)
         {
           AuftragBase::mengen_t M=AuftragBase::min(i->Menge,S-getRestStk());
           // warum nicht MengeAendern?
           M=AufEintrag(i->AEB).MengeAendern(uid,-M,false,*this,ManuProC::Auftrag::r_Produziert);
           S-=M;
         } 
      }  
  }
}
