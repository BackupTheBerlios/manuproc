// $Id: AuftragsEntryZuordnung_sql.pgcc,v 1.3 2002/01/07 16:23:09 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/AuftragsEntryZuordnung.h>
#include "AufEintragBase.h"
#include <Aux/Transaction.h>
#include <Auftrag/auftrag_status.h>
#include <Auftrag/AuftragsBaum.h> 
#include <Aux/Changejournal.h>
#include <Artikel/ArtikelStamm.h>

exec sql include sqlca;

list<AufEintragZu::st_reflist> AufEintragZu::get_Referenz_list(const AufEintragBase2& aeb,bool kinder) const throw(SQLerror) 
{
 exec sql begin declare section;
  int INSTANZ[30],AUFTRAGID[30],ZEILENNR[30];
  double MENGE[30];
  int ARTIKEL[30];
  char query[1024];
 exec sql end declare section;
 Transaction tr;
 std::string squery;
 if(kinder)
    squery = "select neuauftragid,neuinstanz,neuzeilennr,menge,artikelid
      from auftragsentryzuordnung 
      join auftragentry on (neuauftragid,neuinstanz,neuzeilennr)
         = (auftragid,instanz,zeilennr)
      where (altauftragid,altinstanz,altzeilennr) = 
       ("+itos(aeb.Id())+","+itos(aeb.Instanz())+","+itos(aeb.ZNr())+")";
 else
    squery = "select altauftragid,altinstanz,altzeilennr,menge,artikelid
      from auftragsentryzuordnung 
      join auftragentry on (altauftragid,altinstanz,altzeilennr)
         = (auftragid,instanz,zeilennr)
      where (neuauftragid,neuinstanz,neuzeilennr) = 
       ("+itos(aeb.Id())+","+itos(aeb.Instanz())+","+itos(aeb.ZNr())+")";
 strncpy(query,squery.c_str(),sizeof(query));
 exec sql prepare ONAUF_ from :query;
//cout << query<<"\n\n\n";
 exec sql declare ONAUF cursor for ONAUF_;
 exec sql open ONAUF;
 list<st_reflist> vaeb;
 while(true)
  {
    exec sql fetch 30 in ONAUF into :AUFTRAGID,:INSTANZ,:ZEILENNR,:MENGE,:ARTIKEL;
    SQLerror::test(__FILELINE__,100);
    if (sqlca.sqlcode) break;
    int j=sqlca.sqlerrd[2];
    for (int i=0;i<j;++i)
     {
      vaeb.push_back(st_reflist(
         AufEintragBase2(cH_ppsInstanz((ppsInstanz::ppsInstId)INSTANZ[i]),
             AUFTRAGID[i],ZEILENNR[i]),ARTIKEL[i],MENGE[i]));
     }
    if(j<30) break;
  }
 exec sql close ONAUF;
 tr.close();
 return vaeb;
}

list<AufEintragZu::st_reflist> AufEintragZu::get_Referenz_listFull(bool kinder) const throw(SQLerror)
{
// AufEintragBase2 aeb=*this;
 list<st_reflist> tv=get_Referenz_list(AEB,kinder);
 list<st_reflist> vaeb;
 list<st_reflist> tvxx;
reloop:
 tv.splice(tv.end(),tvxx);
 for (list<st_reflist>::iterator i=tv.begin();i!=tv.end();++i)
   {
     tvxx=get_Referenz_list(i->AEB2,kinder);
     if (tvxx.size()==0) vaeb.splice(vaeb.end(),tv,i) ;
     else tv.erase(i) ; 
     goto reloop;
   }
 return vaeb;
}


list<cH_Kunde> AufEintragZu::get_Referenz_Kunden_long() const throw(SQLerror)
{
 list<cH_Kunde> LK;
// list<st_reflist> vaeb = get_Referenz_AufEintragBase2();
 list<st_reflist> vaeb = get_Referenz_listFull(false);
 exec sql begin declare section;
  int KUNDE;
  int INSTANZ;
  int AUFTRAGID;
 exec sql end declare section;
 for (list<st_reflist>::const_iterator i=vaeb.begin();i!=vaeb.end();++i)
  {
    INSTANZ=i->AEB2.Instanz();
    AUFTRAGID=i->AEB2.Id();
    exec sql select kundennr into :KUNDE from auftrag where
      auftragid=:AUFTRAGID and instanz=:INSTANZ; 
    SQLerror::test(__FILELINE__);
    LK.push_back(cH_Kunde(KUNDE));
  }
 return LK;
}

list<cH_Kunde> AufEintragZu::get_Referenz_Kunden() const throw(SQLerror)
{
 list<cH_Kunde> LK = get_Referenz_Kunden_long();
 LK.sort();
 LK.unique();
 return LK;
}

std::list<AufEintragBase2> AufEintragZu::get_AufEintragList_from_Artikel
               (const ArtikelBase& artikel,AufStatVal status)
{
  std::list<AufEintragBase2> L;
  exec sql begin declare section;
   char query[1024];
   int db_auftragid,db_zeilennr;
  exec sql end declare section;
  std::string squery = "select auftragid,zeilennr from auftragentry
      where artikelid="+itos(artikel.Id()) +
      " and instanz!="+itos(ppsInstanz::INST_KNDAUF) //Nur interne Aufträge sind interessant
      +" and auftragid=0"; // Nur die UNGEPLANTEN Aufträge bekommen neue Kinder
  if(status!=NOSTAT) squery += "and status="+itos(status);
  strncpy(query,squery.c_str(),sizeof(query));
  Transaction tr;
  exec sql prepare AELfAein_ from :query ;
  exec sql declare AELfAein cursor for AELfAein_ ;

  exec sql open AELfAein;
  SQLerror::test(__FILELINE__);
  cH_ppsInstanz I(ArtikelStamm(artikel).BestellenBei());
  while(true)
   {
     exec sql fetch AELfAein into :db_auftragid,:db_zeilennr;
     SQLerror::test(__FILELINE__,100);
     if (sqlca.sqlcode) break;
     L.push_back(AufEintragBase2(I,db_auftragid,db_zeilennr));
//cout << "Liste: "<<I->Name()<<' '<<db_auftragid<<' '<<db_zeilennr<<'\n';
   }  
  return L;
}

AufEintragBase2 AufEintragZu::get_AufEintrag_from_Artikel_by_Lfdate   
               (const ArtikelBase& artikel)
{
  std::list<AufEintragBase2> LI=get_AufEintragList_from_Artikel(artikel,OPEN);
  std::list<st_reflist> LR;
  for(std::list<AufEintragBase2>::const_iterator i=LI.begin();i!=LI.end();++i)
   {
     std::list<st_reflist> LRtmp = AufEintragZu(*i).get_Referenz_listFull(false);
     LR.splice(LR.end(),LRtmp);
   }
  Petig::Datum lieferdatum;
  AufEintragBase2 AEB;
  // lieferdatum initialisieren
  if(LR.begin()!=LR.end()) 
  { lieferdatum=AufEintragBase(LR.begin()->AEB2).getLieferdatum();
    AEB=LR.begin()->AEB2;
   for(std::list<st_reflist>::const_iterator i=LR.begin();i!=LR.end();++i)
   {
    Petig::Datum ld=AufEintragBase(i->AEB2).getLieferdatum();
    if(ld<lieferdatum) 
      {
        AEB=i->AEB2;
        lieferdatum=ld;
      }
   }
  }
}

void AufEintragZu::AuftragsEntryZuordnung(const mengen_t menge,
                              const AuftragBase& neuAuftrag,const int neuZnr,
                              const int oldZnr=0)
{
 exec sql begin declare section;
  int db_aaid=AEB.Id();
  int db_ains=AEB.Instanz();
  int db_aznr=AEB.ZNr();
  double db_menge=menge;
  int db_naid=neuAuftrag.Id();
  int db_nins=neuAuftrag.Instanz();
  int db_nznr=neuZnr;
 exec sql end declare section;
 if(oldZnr!=0) db_aznr=oldZnr;
 exec sql insert into auftragsentryzuordnung
   (altauftragid,altinstanz,altzeilennr,menge,neuauftragid,neuinstanz,neuzeilennr) values
   (:db_aaid,:db_ains,:db_aznr,:db_menge,:db_naid,:db_nins,:db_nznr);
 SQLerror::test(__FILELINE__);
}

#include <Aux/itos.h>

void AufEintragZu::setMenge(const mengen_t menge,const AuftragBase& neuAuftrag,const int neuZnr)
{
 exec sql begin declare section;
  int db_aaid=AEB.Id();
  int db_ains=AEB.Instanz();
  int db_aznr=AEB.ZNr();
  double db_menge=menge;
  int db_naid=neuAuftrag.Id();
  int db_nins=neuAuftrag.Instanz();
  int db_nznr=neuZnr;
 exec sql end declare section;
 exec sql update auftragsentryzuordnung
   set menge=:db_menge where
   (altauftragid,altinstanz,altzeilennr,neuauftragid,neuinstanz,neuzeilennr)
    = (:db_aaid,:db_ains,:db_aznr,:db_naid,:db_nins,:db_nznr);
//cout << "update auftragsentryzuordnung set menge="+itos(menge)+
//" where (altauftragid,altinstanz,altzeilennr,neuauftragid,neuinstanz,neuzeilennr) = ("
//+itos(db_aaid)+","+itos(db_ains)+","+itos(db_aznr)+","+itos(db_naid)+","
//+itos(db_nins)+","+itos(db_nznr)+")\n";
 SQLerror::test(__FILELINE__);
/*
 SQLerror::test(__FILELINE__,100);
 if (sqlca.sqlcode) return false;
 else return true;
*/
 
}

bool AufEintragZu::setMengeDiff(const mengen_t menge,const AuftragBase& neuAuftrag,const int neuZnr)
{
 exec sql begin declare section;
  int db_aaid=AEB.Id();
  int db_ains=AEB.Instanz();
  int db_aznr=AEB.ZNr();
  double db_menge=menge;
  int db_naid=neuAuftrag.Id();
  int db_nins=neuAuftrag.Instanz();
  int db_nznr=neuZnr;
 exec sql end declare section;
 exec sql update auftragsentryzuordnung
   set menge=menge+:db_menge where
   (altauftragid,altinstanz,altzeilennr,neuauftragid,neuinstanz,neuzeilennr)
    = (:db_aaid,:db_ains,:db_aznr,:db_naid,:db_nins,:db_nznr);
//cout << "update auftragsentryzuordnung set menge="+itos(menge)+
//" where (altauftragid,altinstanz,altzeilennr,neuauftragid,neuinstanz,neuzeilennr) = ("
//+itos(db_aaid)+","+itos(db_ains)+","+itos(db_aznr)+","+itos(db_naid)+","
//+itos(db_nins)+","+itos(db_nznr)+")\n";
 SQLerror::test(__FILELINE__,100);
 if (sqlca.sqlcode) return false;
 else return true;
}


bool AufEintragZu::setKindZnr(const AuftragBase& neuAuftrag,const int neuZnr)
{
 exec sql begin declare section;
  int db_aaid=AEB.Id();
  int db_ains=AEB.Instanz();
  int db_aznr=AEB.ZNr();
  int db_naid=neuAuftrag.Id();
  int db_nins=neuAuftrag.Instanz();
  int db_nznr=neuZnr;
 exec sql end declare section;
 exec sql update auftragsentryzuordnung
   set neuzeilennr=:db_nznr where
   (altauftragid,altinstanz,altzeilennr,neuauftragid,neuinstanz)
    = (:db_aaid,:db_ains,:db_aznr,:db_naid,:db_nins);
 SQLerror::test(__FILELINE__);
 if (sqlca.sqlcode) return false;
 else return true;
}

/*
int AufEintragZu::getKindZnr(const AuftragBase& neuAuftrag) const
{
 exec sql begin declare section;
  int db_aaid=AEB.Id();
  int db_ains=AEB.Instanz();
  int db_aznr=AEB.ZNr();
  int db_naid=neuAuftrag.Id();
  int db_nins=neuAuftrag.Instanz();
  int db_nznr=-1;
 exec sql end declare section;
 exec sql select neuzeilennr into :db_nznr from auftragsentryzuordnung
   where  (altauftragid,altinstanz,altzeilennr,neuauftragid,neuinstanz)
    = (:db_aaid,:db_ains,:db_aznr,:db_naid,:db_nins);
 SQLerror::test(__FILELINE__,100);
 return db_nznr;
}
*/