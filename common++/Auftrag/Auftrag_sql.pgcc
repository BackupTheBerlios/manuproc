/*  pps: ManuProC's production planning system
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/AuftragFull.h>
#include <string.h>
#include <strstream>
#include <Aux/SQLerror.h>
#include <Aux/Transaction.h>
exec sql include sqlca;
#include <Auftrag/selFullAufEntry.h>
#include <Aux/string0.h>
#include <Kunde/Zahlungsart.h>
#include<Aux/Changejournal.h>
#include <Artikel/ArtikelStamm.h>
#include <Aux/Trace.h>

void Auftrag::deleteAuftrag() throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 exec sql begin declare section;
 int AUFTRAGID=Id();
 int INSTANZ=int(Instanz());
 exec sql end declare section;

 Transaction tr;

 exec sql lock table auftragentry in row exclusive mode;
 exec sql lock table auftrag in row exclusive mode;
 exec sql delete from auftragentry where auftragid= :AUFTRAGID and instanz=:INSTANZ;
 exec sql delete from auftrag where auftragid= :AUFTRAGID and instanz=:INSTANZ;
 SQLerror::test(__FILELINE__"Löschen des Auftrags");

 tr.commit();
}



void Auftrag::setWaehrung(cP_Waehrung w) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 exec sql begin declare section;
 int WAEHRUNG = w->Id();
 int AUFTRAGID = Id();
 int INSTANZ = int(Instanz());
 exec sql end declare section;

 exec sql update auftrag set waehrung = :WAEHRUNG 
   where auftragid= :AUFTRAGID and instanz = :INSTANZ;
 SQLerror::test(__FILELINE__"Waehrung setzen");
}

void Auftrag::Zahlziel(const ManuProC::Datum &zziel) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,zziel);
 exec sql begin declare section;
 int AUFTRAGID = Id();
 int INSTANZ = int(Instanz());
 char *ZAHLZIEL;
 int IZAHLZIEL;
 exec sql end declare section;

 if(zziel.valid())
   ZAHLZIEL = (char*)zziel.to_iso().c_str();
 else
  IZAHLZIEL = -1;
  
 exec sql update auftrag set zahlungsziel = :ZAHLZIEL:IZAHLZIEL 
   where auftragid= :AUFTRAGID and instanz = :INSTANZ;
 SQLerror::test(__FILELINE__"Zahlungsziel setzen");
}

void Auftrag::Zahlart(cH_Zahlungsart zart) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 exec sql begin declare section;
 int AUFTRAGID = Id();
 int INSTANZ = int(Instanz());
 int ZAHLART;
 exec sql end declare section;

 if(zart->Id()!=Zahlungsart::none_id)
   ZAHLART = zart->Id();
 else
   {cH_Kunde k(kundennr);
   ZAHLART = k->zahlungsart()->Id();
   }
  
 exec sql update auftrag set zahlart = :ZAHLART 
   where auftragid= :AUFTRAGID and instanz = :INSTANZ;
 SQLerror::test(__FILELINE__"Zahlungsart setzen");
}



void Auftrag::deleteEintrag(int zeilennr) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,"ZNr=",zeilennr);
 exec sql begin declare section;
 int AUFTRAGID=Id();
 int INSTANZ=int(Instanz());
 int ZEILENNR=zeilennr;
 exec sql end declare section;

 Transaction tr;
 
 exec sql lock table auftragentry in share row exclusive mode;
 exec sql delete from auftragentry where zeilennr= :ZEILENNR
 		and auftragid= :AUFTRAGID and instanz = :INSTANZ;
 SQLerror::test(__FILELINE__"Auftragszeile löschen");

 exec sql update auftragentry set zeilennr=zeilennr-1
 	where zeilennr> :ZEILENNR and auftragid= :AUFTRAGID
   and instanz = :INSTANZ;
 SQLerror::test(__FILELINE__"Auftragszeilennr aktualisieren");
 
 tr.commit();
}

Auftrag::Auftrag(const AuftragBase& _auftrag) throw(SQLerror)
: AuftragBase(_auftrag), zahlart(Zahlungsart::none_id)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 exec sql begin declare section;
 int AUFTRAGID = Id();
 int INSTANZ =int(Instanz());
 int KUNDENNR;
 char DATUM[11];
 char ZAHLZIEL[11];
 int STATUS;
 char YOURAUFNR[21];
 char *BEMERKUNG=0;
 int WAEHRUNG;
 float RABATT;
 int IZAHLZIEL;
 int ZAHLART;
 int NONE_ID;
 char *NOTIZ=0;
 int INVALID_ENTITY;
 int DEFAULT_WID;
 exec sql end declare section;
 INVALID_ENTITY=ManuProcEntity<>::none_id;

 NONE_ID=Zahlungsart::none_id;
 DEFAULT_WID=Waehrung::default_id;

//if(Instanz()==ppsInstanzID::Kundenauftraege)
//ECPGdebug(true,stdout);
 exec sql select coalesce(kundennr,:INVALID_ENTITY), date(coalesce(datum,now())), 
 		stat, coalesce(youraufnr,''), coalesce(bemerkung,''),
		 coalesce(waehrung,:DEFAULT_WID),coalesce(rabatt,0),
		zahlungsziel, coalesce(zahlart,:NONE_ID),
		coalesce(notiz,'')
	into 	:KUNDENNR, :DATUM, :STATUS, :YOURAUFNR, :BEMERKUNG,
		 :WAEHRUNG,:RABATT,:ZAHLZIEL:IZAHLZIEL, :ZAHLART,
		:NOTIZ
	from auftrag where (auftragid,instanz) = (:AUFTRAGID,:INSTANZ) ;
 SQLerror::test(__FILELINE__"Auftrag laden");

 kundennr = KUNDENNR;
 datum.from_postgres(DATUM);
// wrkstatus = LOADED;
 status = (AufStatVal)STATUS;
 youraufnr = YOURAUFNR;
 bemerkung = BEMERKUNG;
 waehrung = cP_Waehrung(Waehrung::ID(WAEHRUNG));
 auftragsrabatt = RABATT;
 zahlziel = (IZAHLZIEL==0) ? ManuProC::Datum(ZAHLZIEL):ManuProC::Datum();
 zahlart = cH_Zahlungsart(ZAHLART);
 notiz=NOTIZ;
 notiz_valid=true;
 ECPGfree_auto_mem();
}


Auftrag::Auftrag(Anlegen _instanz, long kdnr) throw(SQLerror)
	: AuftragBase(cH_ppsInstanz(_instanz),invalid_id),
	  zahlart(Zahlungsart::none_id)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"Anlegen:",*this);
 exec sql begin declare section;
 int AUFTRAGID;
 char DATUM[11];
 int YEAR;
 int KUNDENNR=kdnr;
 int STATUS=UNCOMMITED;
 int INSTANZ=Instanz();
 int WAEHRUNG;
 int VERKNR;
 int IVERKNR=0;
 exec sql end declare section;

 exec sql select waehrungid,coalesce(verknr,-1) 
	into :WAEHRUNG,:VERKNR from kunden where kundennr= :KUNDENNR;
 SQLerror::test(__FILELINE__"select waehrung from kunden");

 Transaction tr;

 exec sql lock table auftrag in exclusive mode;
 SQLerror::test(__FILELINE__"lock table auftrag");

 exec sql select cast(date_part('year',date(now())) as integer)%100 into :YEAR;
 SQLerror::test(__FILELINE__"select year");
 
 exec sql select coalesce(max(auftragid)+1,:YEAR*10000) 
 		into :AUFTRAGID from auftrag 
 		where auftragid between (:YEAR*10000) and (:YEAR+1)*10000-1
 		and instanz=:INSTANZ;
 SQLerror::test("Auftrag: select neue auftragid");

 exec sql insert into auftrag (auftragid, kundennr, 
				stat, waehrung, instanz)
 	values (:AUFTRAGID, :KUNDENNR, :STATUS, :WAEHRUNG,:INSTANZ);
 SQLerror::test(__FILELINE__" insert into auftrag");
  
#ifdef MABELLA_EXTENSIONS
 if(VERKNR==-1) IVERKNR=-1;
 exec sql update auftrag set verknr=:VERKNR:IVERKNR where
	(auftragid,instanz)=(:AUFTRAGID,:INSTANZ);
 SQLerror::test(__FILELINE__":Auftrag: update auftrag");	
#endif


 exec sql select date(datum) into :DATUM from auftrag 
   where auftragid= :AUFTRAGID and instanz = :INSTANZ;
 SQLerror::test("Aufrtag: select datum");

 kundennr = kdnr;
 datum.from_postgres(DATUM);
// wrkstatus= INSERTED;
 status=(AufStatVal)STATUS;
 auftragid= AUFTRAGID;
 assert(valid()); 
 tr.commit();
}

Auftrag::Auftrag(Anlegen2 AB, long kdnr) throw(SQLerror)
	: AuftragBase(AB), zahlart(Zahlungsart::none_id)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"Anlegen:",*this,"KnNr=",kdnr);
 exec sql begin declare section;
 int AUFTRAGID=Id();
 char DATUM[11];
 int KUNDENNR=kdnr;
 int STATUS = OPEN;
 int INSTANZ =Instanz();
 int WAEHRUNG;
 int VERKNR;
 int IVERKNR=0;
 exec sql end declare section;

 exec sql select waehrungid,coalesce(verknr,-1) 
	into :WAEHRUNG,:VERKNR from kunden where kundennr= :KUNDENNR;
 SQLerror::test(__FILELINE__"select waehrung from kunden");

 Transaction tr;
 exec sql insert into auftrag (auftragid, kundennr,  
				stat, waehrung, instanz)
 	values (:AUFTRAGID, :KUNDENNR, :STATUS, :WAEHRUNG,:INSTANZ);
 SQLerror::test(__FILELINE__" insert auftrag with auftragid 0");
  
#ifdef MABELLA_EXTENSIONS
 if(VERKNR==-1) IVERKNR=-1;
 exec sql update auftrag set verknr=:VERKNR:IVERKNR where
	(auftragid,instanz)=(:AUFTRAGID,:INSTANZ);
 SQLerror::test(__FILELINE__":Auftrag: update auftrag");	
#endif

 exec sql select date(datum) into :DATUM from auftrag 
   where auftragid= :AUFTRAGID and instanz = :INSTANZ;
 SQLerror::test("Aufrtag: select datum");

 kundennr = kdnr;
 datum.from_postgres(DATUM);
// wrkstatus= INSERTED;
 status=(AufStatVal)STATUS;

 tr.commit();
}


void Auftrag::setBemerkung(const std::string &bem) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 exec sql begin declare section;
 int AUFTRAGID=Id();
 int INSTANZ=int(Instanz());
 const char *BEMERKUNG=bem.c_str();
 exec sql end declare section;

 exec sql update auftrag set bemerkung= nullif(:BEMERKUNG,'')
	where auftragid= :AUFTRAGID and instanz=:INSTANZ;
 SQLerror::test("setBemerkung: update bemerkung");
}

void Auftrag::setYourAufNr(const std::string &yanr) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 exec sql begin declare section;
 int AUFTRAGID=Id();
 int INSTANZ=int(Instanz());
 char YOURAUFNR[21];
 exec sql end declare section;

 youraufnr=yanr;

 strncpy0(YOURAUFNR,youraufnr.c_str(),20);

 exec sql update auftrag set youraufnr= nullif(:YOURAUFNR,'')
	where auftragid= :AUFTRAGID and instanz = :INSTANZ;
 SQLerror::test("setYourAufNr: update youraufnr");
}

int Auftrag::getIdFromYourAufId(const char *youraufid) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 exec sql begin declare section;
 int AUFTRAGID;
 int INSTANZ;
 char YOURAUFNR[21];
 exec sql end declare section;
 INSTANZ=int(Instanz());

 strncpy0(YOURAUFNR,youraufid,20);

 exec sql select auftragid into :AUFTRAGID from auftrag
	where youraufnr= :YOURAUFNR and instanz =:INSTANZ;
 SQLerror::test("getIdFromYourAufId: select auftragid");
 return AUFTRAGID;
}

const std::string Auftrag::Notiz() const throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 if(notiz_valid) return notiz;

 exec sql begin declare section;
 int AUFID = Id();
 char *NOTIZ=0;
 exec sql end declare section;

 exec sql select coalesce(notiz,'') into :NOTIZ from auftrag where auftragid= :AUFID;
 SQLerror::test(__FILELINE__);

 notiz=NOTIZ;
 ECPGfree_auto_mem();
 notiz_valid=true;
 return notiz;
}

void Auftrag::Notiz(const std::string n) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 exec sql begin declare section;
 int AUFID = Id();
 char *NOTIZ;
 exec sql end declare section;

 NOTIZ = (char*)n.c_str();

 Transaction tr;

 exec sql update auftrag set notiz=:NOTIZ where auftragid= :AUFID;
 SQLerror::test(__FILELINE__);

 tr.commit();
 notiz=n;
}



AufEintragBase Auftrag::push_back(const mengen_t bestellt, 
  const ManuProC::Datum lieferdatum,const ArtikelBase& artikel,
  const AufStatVal status,int uid,const bool setInstanzAuftraege,
  const Preis& preis,const fixedpoint<2> rabatt,
  const cH_PreisListe &preisliste) const throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,
   "Menge=",bestellt,"Datum=",lieferdatum,
   "Artikel=",artikel,
   "Status=",status,"InstanzAufträgeSetzen=",setInstanzAuftraege);
 exec sql begin declare section;
 int AUFTRAGID =Id();
 long ARTIKELID=artikel.Id();
 int INSTANZ =InstanzID();
 int ZEILENNR;
 int BESTELLT=bestellt.as_int();
 char LIEFERDATUM[21];
 double PREIS=preis.Wert().as_float();
 int RABATT=rabatt.as_int();
 float PREISMENGE=preis.PreisMenge().as_float();
 int STATUS=status;
 int PREISLISTE=preisliste->Id();
 int PREISLISTENULL;
 int UID=uid;
 exec sql end declare section;
 PREISLISTENULL=PreisListe::none_id;
 
// bei Mabella auf keinen Fall UNCOMMITED
#ifdef MABELLA_EXTENSIONS
 if(status==UNCOMMITED)
   STATUS=OPEN;   
#endif

 if(STATUS!=getStatus()) setStatusAuftragBase(AufStatVal(STATUS));


 lieferdatum.write_postgres(LIEFERDATUM,sizeof LIEFERDATUM);

 Transaction tr;
 exec sql lock table auftragentry in exclusive mode;
 SQLerror::test("AufEintrag: lock auftragentry");	

//ECPGdebug(true,stdout);
 exec sql select coalesce(max(zeilennr)+1,1) into :ZEILENNR from auftragentry
	where (instanz,auftragid)= (:INSTANZ,:AUFTRAGID);
 SQLerror::test("generate next zeilennr");

 exec sql insert into auftragentry (instanz,auftragid, zeilennr,
	bestellt,geliefert,lieferdate,artikelid,status,
	preis,rabatt,preismenge,preisliste,lastedit_uid)
	values (:INSTANZ, :AUFTRAGID, :ZEILENNR, :BESTELLT, 0, :LIEFERDATUM,
		:ARTIKELID, :STATUS, :PREIS, :RABATT,
		:PREISMENGE, nullif(:PREISLISTE,:PREISLISTENULL),:UID) ;
 SQLerror::test(__FILELINE__" insert into auftragentry");	
//ECPGdebug(false,0);
	
 if(Instanz()==ppsInstanzID::Kundenauftraege)
  { try{
     pps_ChJournalEntry::newChange(
                        instanz,
			AufEintragBase(instanz,AUFTRAGID,ZEILENNR),
                        artikel,
                        (double)BESTELLT,
                        (double)BESTELLT,
                        pps_ChJournalEntry::CH_MENGE);
        }
    catch(SQLerror &e)
      {tr.rollback(); throw; }
  }
 // Kundenaufträge legen automatisch einen Auftrag bei der entsprechenden Instanz 
 // für denselben Artikel an.
 AufEintragBase AEB(*this,ZEILENNR);
 if(status!=UNCOMMITED) // Nur offene Aufträge kümmern sich um andere Instanzen
   {
      AufEintrag AE(AEB);
      BaumAnlegen(AE,uid,setInstanzAuftraege);
    }
 tr.commit();
 return AEB;
}

