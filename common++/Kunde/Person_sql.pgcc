// $Id: Person_sql.pgcc,v 1.6 2002/02/28 15:19:29 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Christof Petig
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Kunde/Person.h>
#include <Kunde/Telefon.h>
#include <Aux/Transaction.h>

exec sql include sqlca;

Person::Person(ID _id) throw(SQLerror) : personennr(_id)
{  exec sql begin declare section;
   int ID=_id;
   int KUNDENNR;
   int ANREDE;
   char NAME[50], VORNAME[50], POSITION[50];
   char GEBDATE[21],NOTIZ[1500];
   int IGEBDATE,IKUNDENNR;
   exec sql end declare section;

   if(_id == none_id) return;   
  
   Transaction tr;

   exec sql select kundennr, name, coalesce(vname,''), coalesce(_position,''),
	gebdat, coalesce(branr,0), coalesce(p.notiz||' '||a.notiz,'')
	into :KUNDENNR:IKUNDENNR, :NAME, :VORNAME, :POSITION,
		:GEBDATE:IGEBDATE, :ANREDE, :NOTIZ
	from ku_person p full join ku_ansprech a using(persnr)
	   where  p.persnr= :ID;

   SQLerror::test(__FILELINE__);

   personennr=ID;
   kundennr=IKUNDENNR ? Kunde::none_id : KUNDENNR;
   name=NAME;
   vorname=VORNAME;
   position=POSITION;
   gebdatum=IGEBDATE ? Petig::Datum() : Petig::Datum(GEBDATE);
   anrede=cH_Anrede(ANREDE);
   notiz=NOTIZ;	
}

vector<Person::st_person> Person::get_Person(ID nr) throw(SQLerror)
{
   exec sql begin declare section;
    int PERSNR;
    char NAME[50], VORNAME[50], POSITION[50];
    char GEBDATE[21];
    int ANREDE;
    char NOTIZ[1500];
    int IGEBDATE;
   char *QU;
   exec sql end declare section;

   Transaction tr;
   std::string qu =  "select persnr,name, coalesce(vname,''), "
	"coalesce(_position,''),gebdat, coalesce(branr,0), "
	"coalesce(p.notiz||' '||a.notiz,'') from "
	"ku_person p, ku_ansprech a "
	" where p.persnr=a.persnr and a.kundennr="+itos(nr);
   QU = (char*)qu.c_str();
   exec sql prepare perqu from :QU;
    exec sql declare PER cursor for perqu;
    exec sql open PER;
    SQLerror::test(__FILELINE__);
 while (true)
  { 
    exec sql fetch PER into
	    :PERSNR,:NAME, :VORNAME, :POSITION,
		 :GEBDATE:IGEBDATE, :ANREDE, :NOTIZ;
    SQLerror::test(__FILELINE__,100);
    if (sqlca.sqlcode) break;
    gebdatum=IGEBDATE ? Petig::Datum() : Petig::Datum(GEBDATE);
    vec_person.push_back(st_person(PERSNR,NAME,VORNAME,POSITION,gebdatum,
         cH_Anrede(ANREDE),NOTIZ));
   }
  exec sql close PER;
  tr.close();
  return vec_person;
}



cH_Person Person::newPerson(const Kunde::ID _knr, const std::string &_name, const std::string &_vorname,
 	const std::string &_pos, const Petig::Datum &gd, 
	const int _branr_id, const std::string &_not) throw(SQLerror)
{
 exec sql begin declare section;
    int KUNDENNR = _knr, PERSNR;
    int BRANR_ID;
    char *NAME, *VORNAME, *POSITION, *GEBURT, *NOTIZ;   
 exec sql end declare section;

 NAME=(char*)_name.c_str();
 VORNAME=(char*)_vorname.c_str();
 POSITION=(char*)_pos.c_str();
 GEBURT=(char*)gd.c_str();
 BRANR_ID=_branr_id;
 NOTIZ=(char*)_not.c_str();   

 Transaction tr;

 exec sql select nextval('kunden_personen_persnr_seq') into :PERSNR;
 SQLerror::test(__FILELINE__);

 exec sql insert into ku_person
	(persnr,name,vname,gebdat,branr,notiz)
	values
	(:PERSNR,:NAME,:VORNAME,:GEBURT,:BRANR_ID,:NOTIZ);

 if(KUNDENNR != Kunde::none_id)
    exec sql insert into ku_ansprech
       (kundennr, persnr, _position) values (:KUNDENNR,:PERSNR,:POSITION);

  SQLerror::test(__FILELINE__);

 tr.commit();

 return cH_Person(PERSNR);

}


void Person::update() throw(SQLerror)
{
 exec sql begin declare section;
 int PERSNR=personennr;
 int BRANR_ID;
 char *NAME, *VORNAME, *POSITION, *GEBURT, *NOTIZ;   
 exec sql end declare section;

 NAME=(char*)name.c_str();
 VORNAME=(char*)vorname.c_str();
 POSITION=(char*)position.c_str();
 GEBURT=(char*)gebdatum.c_str();
 BRANR_ID=branr_id;
 NOTIZ=(char*)notiz.c_str();   

 Transaction tr;

 exec sql update ku_personen set
       name= :NAME, vname= :VORNAME, _position= :POSITION,
	gebdat= :GEBURT, branr= :BRANR_ID, notiz= :NOTIZ
	where persnr= :PERSNR;
  SQLerror::test(__FILELINE__);

 tr.commit();

}

void Person::delPerson(const ID pid) throw(SQLerror)
{
 exec sql begin declare section;
 int PERSNR=pid;
 exec sql end declare section;

 Transaction tr;

 exec sql delete from ku_ansprech where persnr= :PERSNR;
 SQLerror::test(__FILELINE__);
 exec sql delete from ku_person where persnr= :PERSNR;
 SQLerror::test(__FILELINE__);

 tr.commit();

}

const vector<cH_Telefon> Person::getTelefon() const
{
 exec sql begin declare section;
   int TELID;  
   int PID=Id();
 exec sql end declare section;

 Transaction tr;
 
 exec sql declare telein cursor for
   SELECT telid FROM ku_telefon WHERE persnr= :PID;
 exec sql open telein;
 SQLerror::test(__FILELINE__);

 vector<cH_Telefon> T;
 while(true)
      {
         exec sql fetch telein into :TELID;
         SQLerror::test(__FILELINE__,"teleein",100);
         if (sqlca.sqlcode) break;
         T.push_back(cH_Telefon(TELID));
      }

 exec sql close telein;
 tr.close(); 
 return T;  
}


