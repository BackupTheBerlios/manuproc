/*  libKomponenten: GUI components for ManuProC's libcommon++
 *  Copyright (C) 1998-2001 Adolf Petig GmbH & Co. KG
 *			 written by Christof Petig and Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include "ArtikelBox.hh"
#include <Aux/itos.h>
#include <algorithm>
#include <unistd.h>
#include "stock_button_apply.xpm"
#include "stock_button_cancel.xpm"
#include <Aux/FetchIStream.h>

exec sql include sqlca;

void ArtikelBox::searchFunc(int *cont, GtkSCContext newsearch, unsigned int sp,unsigned int l) throw(SQLerror)
{
 std::vector<cH_EntryValue> vl,va;
 if (kombiniertbool) { vl = expand_kombi(l,LABEL);
                       va = expand_kombi(l,ARTIKEL);
                     }
 try
 {switch(newsearch)
  { case GTK_SEARCH_OPEN:
    { 
      pixmap->set(stock_button_cancel_xpm);
      artikel=ArtikelBase();
 exec sql begin declare section;
   char *QUERY;
 exec sql end declare section;
 std::string table="artbez_"+itos(schema->Typ())+"_"+itos(schema->Id());
 std::string what;
 std::string combocontent=combos[l][sp]->get_text();
 std::string constraint;
 std::string squery; 

 unsigned int spalte=0;
 if(!kombiniertbool)
 for (ExtBezSchema::const_iterator i=schema->begin();i!=schema->end();++i)
  { if (i->signifikanz!=signifikanz[l]) continue;
    if (spalte==sp) 
    {  what = i->spaltenname;
       constraint += "text("+i->spaltenname +") like '"+combos[l][spalte]->get_text()+"\%'";
       break;
    }
    else 
    {  
       constraint += "text("+i->spaltenname +")='"+combos[l][spalte]->get_text()+"' AND ";
       ++spalte;
    }
  }
 else // wenn die Anzeige kombiniert ist
  {
    for (unsigned int i=0;i<vl.size();++i)
      {
        what += vl[i]->getStrVal();
        if (i+1!=vl.size()) what +=", ";
      }    
    for (unsigned int i=0;i<va.size();++i)
      {
        constraint += vl[i]->getStrVal() +" like '"+ va[i]->getStrVal() +"%'";
        if (i+1!=va.size()) constraint += " and "; 
      }    
  }
 squery = "SELECT DISTINCT "+what+" FROM "+table ;
 if (constraint!="") squery += " WHERE "+constraint;
//cout << squery<<"\n";
    (const char*)QUERY=squery.c_str();
    tr.open();
    exec sql prepare QUERY from :QUERY;
    exec sql declare extbezfeld cursor for QUERY;
    exec sql open extbezfeld;
    SQLerror::test("ArtikelBox::searchFunc: select text",100);
    if(sqlca.sqlcode==100) return;
    }
    // fall through
    
case GTK_SEARCH_FETCH:   
 {
   exec sql allocate descriptor spalten;
   exec sql fetch extbezfeld into sql descriptor spalten;
   SQLerror::test(__FILELINE__);
//   exec sql close extbezfeld;
//   SQLerror::test(__FILELINE__);
   FetchIStream is("spalten");
   vector<std::string> sv;
   std::string t;
   if (kombiniertbool)
     for (vector<std::cH_EntryValue>::const_iterator i=vl.begin();i!=vl.end();++i)
      {
         is >> FetchIStream::MapNull<string>(t,"");
//cout <<"-"<< t<<"-\n";
         sv.push_back(t);
      }
   else { is >> FetchIStream::MapNull<string>(t,"");
        sv.push_back(t);
      }
 exec sql deallocate descriptor spalten;
 SQLerror::test("ArtikelBox::searchFunc: fetch resulttable",100);
 if(sqlca.sqlcode==100){  combos[l][sp]->add_item(""); return;}

 std::string text;

 unsigned int c=0;
 if(kombiniertbool)
   for (ExtBezSchema::const_sigiterator i=schema->sigbegin(signifikanz[l]);i!=schema->sigend(signifikanz[l]);++i)
    {
     std::string sep = i->separator;
     if (kombiniertbool) text +=sv[c++];
     if (sep==" ") text += "_";
     else text +=sep;
//cout << "\t"<<c<<"\t-"<<sv[c-1]<<"-\t-"<<sep<<"-\t"<<text<<"\n";
    }
 else  text = sv[0];
 combos[l][sp]->add_item(text);

 *cont=true;
 }
 break;
 
case GTK_SEARCH_CLOSE:
 exec sql close extbezfeld;
 tr.commit();
 break;
  }
 } catch (SQLerror &e)
  {  //std::cerr << e << '\n';
  }

}

void ArtikelBox::fuelleMenu()
{  
   exec sql begin declare section;
     int eab_id,db_artikeltyp;
     int id[20];
   char bez[20][41];
   exec sql end declare section;
   eab_id=schema->Id();
   bool typ_ok=false;
//   bool typ2_ok=false;
   int neuerTyp=0;
//   int neuerTyp2=0;
   // Hauptmenü
   Gtk::Menu *typ_menu = manage(new class Gtk::Menu());
   Gtk::MenuItem *typ = manage(new class Gtk::MenuItem("Typ (Warengruppe)"));
   Gtk::Menu *typ2_menu = manage(new class Gtk::Menu());
   Gtk::MenuItem *typ2 = manage(new class Gtk::MenuItem("Schema (Kundengruppe)"));
   Gtk::Menu *anzeige_menu = manage(new class Gtk::Menu());
   Gtk::MenuItem *anzeige = manage(new class Gtk::MenuItem("Anzeige"));
   Gtk::Menu *optionen_menu = manage(new class Gtk::Menu());
   Gtk::MenuItem *optionen = manage(new class Gtk::MenuItem("Optionen"));
   Gtk::Menu *neu_menu = manage(new class Gtk::Menu());
   Gtk::MenuItem *neu = manage(new class Gtk::MenuItem("Neuen Eintrag anlegen"));
   menu->append(*typ);   
   typ->set_submenu(*typ_menu);
   menu->append(*typ2);   
   typ2->set_submenu(*typ2_menu);
   menu->append(*anzeige);   
   anzeige->set_submenu(*anzeige_menu);
   menu->append(*optionen);   
   optionen->set_submenu(*optionen_menu);
   menu->append(*neu);
   neu->activate.connect(SigC::slot(this,&ArtikelBox::Neuer_Eintrag));

   // Einträge für den Menüeintrag 'Typ'
   exec sql select DISTINCT e.artikeltyp, w.text into :id, :bez
        from extbezschema e, artbez_warengruppe w where w.id 
         = e.artikeltyp AND extartbezid= :eab_id limit 20;
   if (!sqlca.sqlcode)
   {  for (int i=0;i<sqlca.sqlerrd[2];++i)
      {  std::string entr;
         if (id[i]==schema->Typ()) entr += "*";
         else entr += " ";
         entr += bez[i];
         Gtk::MenuItem *mi=manage(new Gtk::MenuItem(entr)); 
         typ_menu->append(*mi);
         mi->show();
         mi->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::setzeTyp),id[i]));

   	 if (!typ_ok)
	     { if (schema->Typ()==ArtikelTyp::typ(id[i])) typ_ok=true;
	       else if (!i) neuerTyp=id[i];
     	  }
       }
   }
   if (!typ_ok)
   // Dieser Typ ist für diesen Kunden nicht vorhanden,
   // nehmen wir den ersten anderen.
   {  static bool block=false;
      if (block) return;
      block=true; // never recurse here
      setExtBezSchema(cH_ExtBezSchema(schema->Id(),neuerTyp));
      block=false;
      return;
   }

   // Einträge für den Menüeintrag 'Typ (Kundengruppe)'
   db_artikeltyp=schema->Typ();
   exec sql select DISTINCT e.extartbezid, k.firma into :id, :bez
        from extbezschema e join kunden k on (e.extartbezid=k.kundennr) 
        where e.artikeltyp = :db_artikeltyp
         limit 20;
   if (!sqlca.sqlcode)
   {  for (int i=0;i<sqlca.sqlerrd[2];++i)
      {  std::string entr;
         if (id[i]==schema->Id()) entr += "*";
         else entr += " ";
         entr += bez[i];
         Gtk::MenuItem *mi=manage(new Gtk::MenuItem(entr)); 
         typ2_menu->append(*mi);
         mi->show();
         mi->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::setzeTyp2),id[i]));
/*
   	 if (!typ2_ok)
	     { if (schema->Id()==ArtikelTyp::typ(id[i])) typ2_ok=true;
	       else if (!i) neuerTyp2=id[i];
     	  }
*/
       }
   }
   // Für neue Kundengruppe immer erste Warengruppe setzen:
//   setExtBezSchema(cH_ExtBezSchema(schema->Id(),neuerTyp));
/*
   if (!typ2_ok)
   // Diese Typ ist für diesen Kunden nicht vorhanden,
   // nehmen wir den ersten anderen.
   {  static bool block=false;
      if (block) return;
      block=true; // never recurse here
      setExtBezSchema(cH_ExtBezSchema(schema->Id(),neuerTyp));
      block=false;
      return;
   }
*/

   // Einträge für den Menüeintrag 'Anzeige'
   exec sql begin declare section;
      int db_atyp, db_sigV[20];
   exec sql end declare section;
   db_atyp=schema->Typ();
   exec sql select distinct signifikanz into :db_sigV 
      from extbezschema where artikeltyp = :db_atyp 
      and extartbezid = :eab_id limit 20;
   SQLerror::test(__FILELINE__);
   if (!sqlca.sqlcode)
   {  
     int sanz = sqlca.sqlerrd[2];
     for (int i=0;i<sanz;++i)
      {
       std::string text = kombinierteAnzeige(db_sigV[i],db_atyp,eab_id);
       Gtk::CheckMenuItem *mi=manage(new Gtk::CheckMenuItem(text));
       anzeige_menu->append(*mi);
       if (find(signifikanz.begin(),signifikanz.end(),db_sigV[i])!= signifikanz.end()) mi->set_active(true);
       mi->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::setzeSignifikanz),db_sigV[i]));
       mi->show();
      }
   }

   // Einträge für den Menüeintrag 'Optionen'
   Gtk::CheckMenuItem *autocomplete = manage(new class Gtk::CheckMenuItem("Automatisches Ergänzen"));      
   Gtk::CheckMenuItem *kombiniert = manage(new class Gtk::CheckMenuItem("Kombiniert"));      
   Gtk::CheckMenuItem *vertikal = manage(new class Gtk::CheckMenuItem("Vertikal anordnen"));      
   optionen_menu->append(*autocomplete);
   optionen_menu->append(*kombiniert);
   optionen_menu->append(*vertikal);
   autocomplete->show();
   kombiniert->show();
   vertikal->show();
   if(autocompletebool) autocomplete->set_active(true);
   autocomplete->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::Autocomplete),autocomplete));
   if (kombiniertbool) kombiniert->set_active(true);
   kombiniert->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::kombiniert),kombiniert));
   if (vertikalbool) vertikal->set_active(true);
   vertikal->activate.connect(SigC::bind(SigC::slot(this,&ArtikelBox::set_Vertikal),vertikal));


   // Menu anzeigen
   typ_menu->show();
   typ->show();
   typ2_menu->show();
   typ2->show();
   anzeige_menu->show();
   anzeige->show();
   optionen_menu->show();
   optionen->show();
   if (neuanlegen()) neu->show();
}

bool ArtikelBox::neuanlegen()
{
 exec sql begin declare section;
   bool B;
   char TABELLE[20];
 exec sql end declare section;
 std::string table="artbez_"+itos(schema->Typ())+"_"+itos(schema->Id());
 strncpy(TABELLE,table.c_str(),sizeof(TABELLE));
 exec sql select true into :B from artbez_insert where tabelle =:TABELLE; 
 SQLerror::test(__FILELINE__,100);
 if (sqlca.sqlcode) B=false;
 return B;
}

std::string ArtikelBox::kombinierteAnzeige(int sig, int atyp, int id)
{
  exec sql begin declare section;
   char db_text[20][20],db_sep[20][5];
   int eab_id,db_atyp,db_sig;
   int db_bezkomptype[20];
  exec sql end declare section;
  eab_id=id;
  db_atyp=atyp;
  db_sig=sig;
  exec sql select distinct bezkomptype, bezkomptext, coalesce(separator,'') 
    into :db_bezkomptype, :db_text, :db_sep
    from extbezschema where artikeltyp = :db_atyp and signifikanz = :db_sig
    and extartbezid = :eab_id order by bezkomptype limit 20;
  SQLerror::test(__FILELINE__);
  std::string text;
  if (!sqlca.sqlcode)
  for (int i=0;i<sqlca.sqlerrd[2];++i)
     { std::string t= db_text[i];
       std::string s= db_sep[i];
       text += t+s;
     }
  return text;
}


void ArtikelBox::Benutzerprofil_laden()
{
  exec sql begin declare section;
   int db_uid, db_artikeltyp, db_schema, 
       db_anzeige_pos, db_anzeige_neg, db_auswahl;
   bool db_autocomplete, db_kombiniert;
  exec sql end declare section;
  db_uid=getuid();
  db_artikeltyp=schema->Typ();
  db_schema=schema->Id();
  exec sql select anzeige_pos, anzeige_neg, auswahl, autocomplete, kombiniert
   into :db_anzeige_pos, :db_anzeige_neg, :db_auswahl, :db_autocomplete, :db_kombiniert
   from artbez_anzeige where uid=:db_uid and artikeltyp=:db_artikeltyp
   and schema=:db_schema;
  SQLerror::test(__FILELINE__,100);
  if (sqlca.sqlcode) 
  {  signifikanz.clear();
     autocompletebool=false;
     kombiniertbool=false;
     return;
  }
  
  signifikanz.clear();
  for (unsigned int i=0;i<sizeof(db_anzeige_pos)*8;++i)
   {
     unsigned int sig = (db_anzeige_pos &(1<<i));
     if (sig!=0) signifikanz.push_back(i+1);
   }
  for (unsigned int i=0;i<sizeof(db_anzeige_neg)*8;++i)
   {
     unsigned int sig = (db_anzeige_neg &(1<<i));
     if (sig!=0) signifikanz.push_back(-(i+1));
   }
  autocompletebool=db_autocomplete;
  kombiniertbool=db_kombiniert;
}

void ArtikelBox::Benutzerprofil_speichern()
{
  exec sql begin declare section;
   int db_uid, db_artikeltyp, db_schema, 
       db_anzeige_pos, db_anzeige_neg, db_auswahl;
   bool db_autocomplete, db_kombiniert;
  exec sql end declare section;
  db_autocomplete=autocompletebool; 
  db_kombiniert=kombiniertbool; 
  db_uid=getuid();
  db_artikeltyp=schema->Typ();
  db_schema=schema->Id();
  db_anzeige_pos=0;
  db_anzeige_neg=0;
  for(std::vector<int>::const_iterator i=signifikanz.begin();i!=signifikanz.end();++i)
   {
     if ((*i)>0) db_anzeige_pos |= 1<<( (*i)-1);
     else if ((*i)<0) db_anzeige_neg |= 1<<(-(*i)-1);
   }
  db_auswahl=0;
  exec sql delete from artbez_anzeige where 
      uid=:db_uid and artikeltyp=:db_artikeltyp and schema=:db_schema;
  exec sql insert into artbez_anzeige 
      (uid,artikeltyp,schema,anzeige_pos,anzeige_neg,auswahl,autocomplete,kombiniert)
   values
      (:db_uid,:db_artikeltyp,:db_schema,:db_anzeige_pos,:db_anzeige_neg,:db_auswahl,:db_autocomplete,:db_kombiniert);
  SQLerror::test(__FILELINE__);
}

void ArtikelBox::Neuer_Eintrag()
{
 try {
 /* testen ob ID eingetragen => FEHLER */
 for (unsigned int j=0;j<combos.size();++j)
  for (unsigned int i=0; i<combos[j].size(); ++i)
   { 
     if (labels[j][i]->get_text()=="ID" && combos[j][i]->get_text() !="")
      { std::cerr<<"FEHLER: ID darf nicht vorgegeben werden: Feld freilassen\n";
        return;
      }
   }
  exec sql begin declare section;
   int db_id,db_id_jumbo;
  exec sql end declare section;

  exec sql select nextval ('artikelbezeichnun_artikelid_seq') into :db_id;
  std::string where, what;
  where = "(id,stand," ;
  what  = "("+itos(db_id)+",now(),";
  where_what(where,what,false);

#warning Was in die ArtikelBox eingegeben wird wird als Kundenauftrag = 9 bestellt
#warning Das sollten wir unbedingt überdenken.
  Neuer_Eintrag_sql(db_id,where,what,9);

 
 std::string aufmachung;
  for (unsigned int j=0;j<combos.size();++j)
   for (unsigned int i=0; i<combos[j].size(); ++i)
    if (labels[j][i]->get_text()==schema->JumboTitel())
       aufmachung=combos[j][i]->get_text();

 if (schema->JumboBez()!=aufmachung) // Wenn ich selber keine Jumborolle bin
  {
    int jumbo_id=jumbo_exist();
    if(jumbo_id==0)  // Wenn es keine entsprechende Jumborolle vorhanden sofort eine anlegen 
      {
        exec sql select nextval ('artikelbezeichnun_artikelid_seq') into :db_id_jumbo;
        jumbo_id=db_id_jumbo;      
        where = "(id,stand," ;
        what  = "("+itos(db_id_jumbo)+",now(),";
        where_what(where,what,true);
   
#warning 'aufgemachte' Ware wird im Bandlager = 8 bestellt
        Neuer_Eintrag_sql(db_id_jumbo,where,what,8);
      }
    insert_into_artikelzusammensetzung(db_id,jumbo_id,31,get_menge_from_artikelbox());
  }


  artikel=db_id;
  pixmap->set(stock_button_apply_xpm);
  new_article_inserted(db_id);
  activate();
  }catch (SQLerror &e)   {  /*std::cerr << e << '\n';*/}
}


void ArtikelBox::Neuer_Eintrag_sql(int id, std::string where, std::string what,int bestellen_bei)
{
  exec sql begin declare section;
   int db_id=id, db_warengruppe,db_schema,db_bestellen_bei=bestellen_bei;   
   char db_query[1024];
  exec sql end declare section;

  std::string strtyp = itos(schema->Typ());
  std::string table = "artbez_"+strtyp+"_"+itos(schema->Id());
  std::string sq = "insert into "+table +" "+ where+" values "+what;
  strncpy(db_query,sq.c_str(),sizeof(db_query));
  exec sql execute immediate :db_query;
  SQLerror::test(__FILELINE__);

  // Eintrag in Artikelbezeichnung
  db_warengruppe= atoi(strtyp.c_str());
  db_schema = schema->Id();
  exec sql insert into artikelstamm (id,stand,warengruppe,defaultschema,bestellen_bei)
     values (:db_id,now(),:db_warengruppe,:db_schema,:db_bestellen_bei);
  SQLerror::test(__FILELINE__);
     

}

#if 0
unsigned int ArtikelBox::intern_id(int typ)
{
  exec sql begin declare section;
   char db_query[1024];
   int db_id;
  exec sql end declare section;
  std::string where, what;
  where = "(" ;
  what  = "(";
  where_what(where,what);

  std::string sq = "select id from artbez_"+itos(typ)+"_1 where "+where+"="+what;
  strncpy(db_query,sq.c_str(),sizeof(db_query));
  Transaction tr;
  exec sql prepare e_ from :db_query;
  exec sql declare e cursor for e_;
  exec sql open e;
  exec sql fetch e into :db_id;
  SQLerror::test(__FILELINE__,100);
  if (sqlca.sqlcode) return 0;
  else return db_id;

}
#endif

void ArtikelBox::where_what(std::string& where, std::string& what, bool jumbo)
{
  unsigned int l=0; 
  bool Jumbo=false;

  for (std::vector<int>::const_iterator i=signifikanz.begin();i!=signifikanz.end();++i)
   {
     unsigned int spalte=0;   
     if (labels[l][0]->get_text() =="ID") continue;
     for(ExtBezSchema::const_sigiterator j=schema->sigbegin(signifikanz[l]);j!=schema->sigend(signifikanz[l]);)
      {
        if(jumbo && j->spaltenname==schema->JumboSpalte()) Jumbo=true;

        std::vector<cH_EntryValue> v;
        if (kombiniertbool) v = expand_kombi(l,ARTIKEL);
        if (j->spaltenname!="id") where += j->spaltenname  ;
        if (j->spaltenname!="id" && !Jumbo) 
         { if (!kombiniertbool) what += "'"+combos[l][spalte]->get_text()+"'" ; 
           else                 what += "'"+v[spalte]->getStrVal()+"'";
         }
        if (j->spaltenname!="id" && Jumbo) 
            what += "'"+schema->JumboBez()+"'" ; 
         
         ++spalte; ++j;
        if (j!=schema->sigend(signifikanz[l]) 
            || i+1!=signifikanz.end() && labels[l+1][0]->get_text() !="ID")  
               { where += ","; what+=",";}
      }
     ++l;
   }
  where += ")"; what+=")";
}

int ArtikelBox::jumbo_exist() 
{
  unsigned int l=0; 
  std::string table = "artbez_"+itos(schema->Typ())+"_"+itos(schema->Id());
  std::string squery = "select id from "+table+" where ";

  for (std::vector<int>::const_iterator i=signifikanz.begin();i!=signifikanz.end();++i)
   {
     unsigned int spalte=0;   
     if (labels[l][0]->get_text() =="ID") continue;
     for(ExtBezSchema::const_sigiterator j=schema->sigbegin(signifikanz[l]);j!=schema->sigend(signifikanz[l]);)
      {
        std::vector<cH_EntryValue> v;
        if (kombiniertbool) v = expand_kombi(l,ARTIKEL);
        if (j->spaltenname!="id") squery += j->spaltenname+"="  ;
        if (j->spaltenname!="id" && j->spaltenname!=schema->JumboSpalte()) 
         { if (!kombiniertbool) squery += "'"+combos[l][spalte]->get_text()+"'" ; 
           else                 squery += "'"+v[spalte]->getStrVal()+"'";
         }
        if(j->spaltenname==schema->JumboSpalte() && j->spaltenname!="id") 
            squery += "'"+schema->JumboBez()+"'" ; 
         
         ++spalte; ++j;
        if (j!=schema->sigend(signifikanz[l]) 
            || i+1!=signifikanz.end() && labels[l+1][0]->get_text() !="ID")  
               { squery += " and ";}
      }
     ++l;
   }
 exec sql begin declare section;
   char query[1024];
   int db_jumbo_id;
 exec sql end declare section;
 strncpy(query,squery.c_str(),sizeof(query));
 Transaction tr;
 exec sql prepare jein_ from :query ;
 exec sql declare jein cursor for jein_ ;
 exec sql open jein;
 SQLerror::test(__FILELINE__);
 exec sql fetch jein into  :db_jumbo_id;
 SQLerror::test(__FILELINE__,100);
 if (sqlca.sqlcode) db_jumbo_id=0;
 exec sql close jein;
 tr.close();
 return db_jumbo_id;
}

void ArtikelBox::insert_into_artikelzusammensetzung(int id, int id_jumbo, int prozess,double menge)
{
 exec sql begin declare section;
   int db_id=id,db_id_jumbo=id_jumbo,db_prozess=prozess;
   double db_menge=menge;
 exec sql end declare section;
 exec sql insert into artikelzusammensetzung (id,prozessid,altartikelid,menge,stand)
    values (:db_id,:db_prozess,:db_id_jumbo,:db_menge,now());
 SQLerror::test(__FILELINE__);
}
