// $Id: AufEintrag_sql.pgcc,v 1.47 2003/01/31 16:23:15 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/AufEintrag.h>
#include <Auftrag/AuftragsBaum.h>
#include <stdio.h>
#include <Misc/string0.h>
#include <Misc/Transaction.h>
#include <Misc/FetchIStream.h>
#include "auftrag_status.h"
#include <Misc/Changejournal.h>
#include "selFullAufEntry.h"
#include <Auftrag/AufEintragZu.h>
#include <Lager/Lager.h>
#include <Lieferschein/Lieferschein.h>
#ifdef MABELLA_EXTENSIONS
#include <Lager/FertigWaren.h>
#include <Artikel/ArtikelBase.h>
#endif
#include <Artikel/ArtikelStamm.h>
#include <Auftrag/Auftrag.h>
#include <algorithm>
#include <unistd.h>
//#include <Auftrag/ppsInstanzProduziert.h>
#include <Misc/Trace.h>
#include <Auftrag/VerfuegbareMenge.h>
#include <Misc/FetchIStream_ops.h>

// Menge wurde geliefert. 
// Um die Pfeile über uns muss sich jemand anderes kümmern

// menge kann negativ sein ...
// wo wird der 2er reduziert?
// wo werden die Instanzen darunter behandelt?
void AufEintrag::abschreiben(mengen_t menge,ManuProcEntity<>::ID lfrsid) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"Menge=",menge,"Lfrsid=",lfrsid);

  mengen_t GELIEFERT=getGeliefert()+menge;
  mengen_t BESTELLT=getStueck();
  AufStatVal STATUS=getEntryStatus();

 if(menge>=0 && getEntryStatus()!=(AufStatVal)OPEN) 
    throw(SQLerror(__FILELINE__,-1,"Auftragszeile ist nicht offen sondern "+itos(STATUS)));
 if(menge<0 && getEntryStatus()==(AufStatVal)UNCOMMITED) 
    throw(SQLerror(__FILELINE__,-1,"Auftragszeile ist nicht bestätigt"));
 if (menge<0 && -menge>getGeliefert()) 
 {  menge=-getGeliefert(); GELIEFERT=0; }

 if (!menge) return;

 AufStatVal oldstatus=getEntryStatus();

 if(mengen_t(GELIEFERT)>=getStueck()) STATUS=(AufStatVal)CLOSED;
 else if(menge<0 && mengen_t(GELIEFERT)<getStueck()) STATUS=(AufStatVal)OPEN;

 Transaction tr;
 Query("lock table auftragentry in exclusive mode");
 bool delete_entry=false;

  // Lieferung rückgängig machen, dann 1er löschen wenn es alle Menge war
  if(menge<0 &&
     Instanz()!=ppsInstanzID::Kundenauftraege && 
     !Instanz()->ProduziertSelbst() && 
     Id()==AuftragBase::plan_auftrag_id)
   {
     BESTELLT+=menge.as_int();
     if(BESTELLT<0) BESTELLT=0;
     if(BESTELLT==GELIEFERT) STATUS=CLOSED;
     if(BESTELLT==0 && GELIEFERT==0 &&  STATUS==CLOSED) delete_entry=true;
   }   

 if(delete_entry)
   Query("delete from auftragentry where (instanz,auftragid,zeilennr) = (?,?,?)")
     << InstanzID() << Id() << ZNr();
 else
   Query("update auftragentry set geliefert=?, status=?, "
     "bestellt=?, letzte_lieferung=now() "
     "where (instanz,auftragid,zeilennr) = (?,?,?)")
     << GELIEFERT << STATUS << BESTELLT 
     << InstanzID() << Id() << ZNr();
 SQLerror::test(__FILELINE__);

#ifdef MABELLA_EXTENSIONS // Lager updaten
#warning Jacek: Das muss raus, sobald es mehrstufig ist
 if(Instanz() == ppsInstanzID::Kundenauftraege)
   {
    FertigWaren fw(Artikel(),(FertigWaren::enum_Aktion)'L',menge.as_int(),lfrsid);
    if(menge < 0) fw.Einlagern(1);
    else if(menge > 0) fw.Auslagern(1);
   }
#endif

 geliefert=GELIEFERT;
 if(geliefert>=bestellt) entrystatus=(AufStatVal)CLOSED;

 // zumindest 2er werden nie geschlossen, nur auf 0 gesetzt
 if(STATUS!=oldstatus && Id()!=dispo_auftrag_id)
     setStatus(AufStatVal(STATUS),getuid(),true);

 tr.commit();
}


void AufEintrag::setStatus(AufStatVal newstatus,int uid,bool force) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"Status=",newstatus,"Force=",force);
 if(entrystatus == newstatus)
 {  ManuProC::Trace(AuftragBase::trace_channel,__FILELINE__,*this,"status bereits",newstatus);
    return;
 }
 if(newstatus == STORNO) force=true;
 if(newstatus == STORNO && getGeliefert()!=mengen_t(0))  
 {  std::cerr << "Kann nicht storniert werden da bereits geliefert\n";
    return;
 }
 if(entrystatus == CLOSED && !force )
 {  std::cerr << "Auftragszeile bereits geschlossen\n";
    return;
 }
 if(newstatus == UNCOMMITED)
 {  std::cerr << "bestätigte Zeilen können nicht wieder unbestätigt werden\n";
    return;
 }
 if(newstatus == OPEN && entrystatus != UNCOMMITED && !force)
 {  std::cerr << "nur unbestätigte Zeilen können geöffnet werden\n";
    return;
 }

 Transaction tr; 
 Query("lock auftragentry in exclusive mode");
 SQLerror::test("setStatus: lock table auftragentry");

 // InternAbbestellen
 if(newstatus == CLOSED || newstatus == STORNO)
     ArtikelInternAbbestellen(uid,getRestStk(),ManuProC::Auftrag::r_Closed);

 std::string sqlcommand = "update auftragentry set status="+itos(newstatus);
 if(uid) sqlcommand+=", lasteditdate = now(), lastedit_uid="+itos(uid);
 sqlcommand +=" where (instanz,auftragid,zeilennr)=("+itos(Instanz()->Id())
              +","+itos(auftragid)+","+itos(zeilennr)+")";

 Query::Execute(sqlcommand);
 SQLerror::test("setStatus: update auftragentry");
 AufStatVal oldentrystatus=entrystatus;
 entrystatus=newstatus;


 if(newstatus==OPEN && auftragstatus==UNCOMMITED)
 {  setStatusAuftragBase(newstatus);
    auftragstatus=newstatus;
 }

 if(newstatus == OPEN  &&  oldentrystatus==UNCOMMITED)
    ArtikelInternNachbestellen(uid,getRestStk(),ManuProC::Auftrag::r_Anlegen);

 if(newstatus==OPEN)
   {
    pps_ChJournalEntry::newChange(
			instanz, *this, artikel,
			bestellt.as_float(),
			bestellt.as_float(),
			pps_ChJournalEntry::CH_MENGE);
  }
 else if(newstatus==CLOSED && oldentrystatus!=UNCOMMITED) 
 // UNCOMMITED->CLOSED => kein Eintrag
   {
    pps_ChJournalEntry::newChange(
			instanz, *this, artikel,
			geliefert.as_float(),
			(geliefert-bestellt).as_float(),
			pps_ChJournalEntry::CH_MENGE);
   }

 tr.commit(); 
}

// statische Variante (behandelt z.B. Vormerkungen, freie Menge etc.)
AufEintragBase AufEintrag::ArtikelInternNachbestellen(const cH_ppsInstanz &wo,
  mengen_t menge,const ManuProC::Datum &lieferdatum,const ArtikelBase& artikel,
  int uid,const AufEintragBase& ElternAEB)
{  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,
   	wo,menge,lieferdatum,artikel,"ElternAEB=",ElternAEB);
   if (!menge) return AufEintragBase(); // hmmm
   assert(menge>0);
   assert(ElternAEB.valid());

   // 2er Menge (freie Menge im Lager, freie Produktionsplanung)
   // vormerken
   VerfuegbareMenge AIL(wo,artikel,lieferdatum);
   mengen_t M_dispo=AuftragBase::min(AIL.getMengeDispo(),menge);
   if(M_dispo>0) menge-=AIL.reduce_in_dispo(uid,M_dispo,ElternAEB);

   // Im Lager von späteren Aufträgen vorgemerkte Menge wegschnappen
   if (menge>0 && wo->LagerInstanz())
   {  M_dispo=AuftragBase::min(AIL.getMengePlan(),menge);
      menge-=AIL.reduce_in_plan(uid,M_dispo,ElternAEB);
   }
   // Rest nachbestellen
   AuftragBase ab(wo,ungeplante_id);
   int znr=ManuProcEntity<>::none_id;
   if (menge>0)
      znr=ab.BestellmengeAendern(menge,lieferdatum,artikel,OPEN,uid,ElternAEB,
   		st_BestellmengeAendern());
   return AufEintragBase(ab,znr);
}

// ehemals updateStkDiffInstanz__ mit menge>0
// + ehemals BaumAnlegen
void AufEintrag::ArtikelInternNachbestellen(int uid,mengen_t menge,
	ManuProC::Auftrag::Action reason) const
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,
   "menge=",menge,"Reason=",reason);
  assert(menge>0);
  assert(Id()!=dispo_auftrag_id);

  if (Instanz()==ppsInstanzID::Kundenauftraege)  
  {  cH_ppsInstanz i=ppsInstanz::getBestellInstanz(Artikel());
     if (i!=ppsInstanzID::None && i!=ppsInstanzID::Kundenauftraege)
     {  AufEintrag::ArtikelInternNachbestellen(i,menge,
		getLieferdatum(),Artikel(),uid,*this);
     }
  }
  else if (Instanz()->LagerInstanz())
  {  assert(Id()==ungeplante_id);
     ArtikelInternNachbestellen(ppsInstanz::getProduktionsInstanz(Artikel()),
     		menge,getLieferdatum(),Artikel(),uid,*this);
  }
  else
  {  ManuProC::Datum newdate=getLieferdatum()-Instanz()->ProduktionsDauer();

     ArtikelBaum AB(Artikel());
     for(ArtikelBaum::const_iterator i=AB.begin();i!=AB.end();++i)
     {  ArtikelInternNachbestellen(ppsInstanz::getBestellInstanz(i->rohartikel),
  		i->menge*menge,newdate,i->rohartikel,uid,*this);
     }
  }
}

AuftragBase::mengen_t AufEintrag::MengeAendern(int uid,mengen_t menge,bool instanzen,
     const AufEintragBase &ElternAEB,ManuProC::Auftrag::Action reason) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"AE=",*this,
   "ElternAEB=",ElternAEB,
   "Menge=",menge,"Instanzen(bool)=",instanzen,"Reason=",reason);
 assert(reason!=ManuProC::Auftrag::r_None);
// if (reason==ManuProC::Auftrag::r_None) assert(!instanzen);
 if (!menge)  return menge;
 Transaction tr;
 Query("lock auftragentry in exclusive mode");
 SQLerror::test("updateStkDiff: lock table auftragentry");

 menge=updateStkDiffBase__(uid,menge);

 if(auftragstatus==OPEN)
  {
   // Rekursion von 2ern verbieten
   assert(Id()!=dispo_auftrag_id || !instanzen); 
   // keine Rekursion bei 1er im Lager 
   // Rekursion bei 1er oder 3er in Produktion
   if ((!Instanz()->LagerInstanz() || Id()==AuftragBase::ungeplante_id) 
   	&& instanzen)
      updateStkDiffInstanz__(uid,menge,*this,reason);
  }
  tr.commit();

 bestellt+=menge;
 return menge;
}

void AufEintrag::ArtikelInternAbbestellen(int uid,mengen_t menge,ManuProC::Auftrag::Action reason) const
{ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,
   "menge=",menge,"Reason=",reason);

 assert(menge>0);
 std::list<AufEintragZu::st_reflist> KindListeU = AufEintragZu(*this).get_Referenz_list(*this,true);
 try{
   typedef  std::map<ArtikelBase,std::list<AufEintragZu::st_reflist> > MapArt_t;
   MapArt_t MapArt;

   for(std::list<AufEintragZu::st_reflist>::iterator i=KindListeU.begin();i!=KindListeU.end();++i)
    {
      // Nach dem Planen kann es zu einem Auftrag mehrere Kindaufträge 
      // mit demselben Artikel geben, nur bei EINEM darf die Menge geändert
      // werden
      MapArt[i->Art].push_back(*i);
     }
  for(MapArt_t::iterator i=MapArt.begin();i!=MapArt.end();++i)
   {
     ArtikelBaum::faktor_t faktor = ArtikelBaum(ArtId()).Faktor(i->first);
     AuftragBase::mengen_t menge2=faktor*menge;
     
     for(std::list<AufEintragZu::st_reflist>::iterator j=i->second.begin();j!=i->second.end();++j)
      {
        AufEintrag AE(j->AEB);
        mengen_t M=AuftragBase::min(j->Menge,menge2);
        
        if(j->AEB.Id()==AuftragBase::ungeplante_id || j->AEB.Instanz()->LagerInstanz())
           M=-AE.MengeAendern(uid,-M,true,AufEintragBase(),reason);
        else // Abbestellung im Lager
          {
            assert(j->AEB.Id()!=AuftragBase::dispo_auftrag_id);
            dispo_auftrag_aendern(uid,j->AEB.Instanz(),i->first,M,AE.getLieferdatum(),j->AEB);
          } 
        AufEintragZu(*this).setMengeDiff__(j->AEB,-M);
        if(j->AEB.Instanz()->LagerInstanz() && 
           j->AEB.Id()==AuftragBase::plan_auftrag_id)
            dispo_auftrag_aendern(uid,j->AEB.Instanz(),i->first,M,LagerBase::Lagerdatum(),AufEintragBase());
        menge2-=M;
        if(!menge2) break;
      }
    }

  }catch(NoAEB_Error &e) 
  {std::cerr <<"Falsche Anzahl von AufEinträgen: "<<e.what()<<'\n'; 
   exit(1);}
}

void AufEintrag::updateStkDiffInstanz__(int uid,mengen_t menge,const AufEintragBase &ElternAEB,ManuProC::Auftrag::Action reason) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,
   "ElternAEB=",ElternAEB,"Menge=",menge,"Reason=",reason);
 if (menge<0) 
 {  assert(ElternAEB==AufEintragBase(*this)); // ?
    ArtikelInternAbbestellen(uid,-menge,reason);
 }
 else 
 {  assert(ElternAEB==AufEintragBase(*this));
    ArtikelInternNachbestellen(uid,menge,reason);
 }
}

void AufEintrag::updatePreis(const Preis &pr) throw(SQLerror)
{ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__);
 Query("update auftragentry "
 	"set preis=?, preismenge=? "
 	"where (instanz,auftragid,zeilennr)=(?,?,?)").lvalue()
 	<< pr.Wert() << pr.PreisMenge() 
 	<< instanz->Id() << auftragid << zeilennr;
 SQLerror::test("updatePreis: update preis in auftragentry");
 preis=pr;
}



void AufEintrag::updateRabatt(rabatt_t rb) throw(SQLerror)
{ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__);
 Query("update auftragentry "
 	"set rabatt=? "
 	"where (instanz,auftragid,zeilennr)=(?,?,?)").lvalue()
 	<< rb 
 	<< instanz->Id() << auftragid << zeilennr;
 SQLerror::test("updateRabatt: update rabatt in auftragentry");
 rabatt=rb;
}


void AufEintrag::updateLieferdatum(const Petig::Datum &ld,int uid) throw(SQLerror)
{ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"Datum=",ld);
 Transaction tr;
 Query("lock auftragentry in exclusive mode"); // unnötig? CP
 SQLerror::test("updateLieferdatum: lock table auftragentry");

 ArtikelInternAbbestellen(uid,getStueck(),ManuProC::Auftrag::r_Anlegen);

 Query("update auftragentry "
 	"set lieferdate=? "
 	"where (instanz,auftragid,zeilennr)=(?,?,?)").lvalue()
 	<< ld
 	<< instanz->Id() << auftragid << zeilennr;
 SQLerror::test("updateLiefDatum: update lieferdate in auftragentry");
 lieferdatum=ld;

 ArtikelInternNachbestellen(uid,getStueck(),ManuProC::Auftrag::r_Anlegen);

 if(entrystatus==OPEN)// status->entrystatus
  {
   try 
    {
     pps_ChJournalEntry::newChange(
  			instanz, *this,
  			artikel, ld,
  			(double)(ld-getLieferdatum()),
  			pps_ChJournalEntry::CH_LIEFDAT);
    }
   catch(SQLerror &e)
     {tr.rollback(); throw; }
  }
 
 tr.commit(); 
}

#include <Misc/relops.h>
  
int AufEintrag::split(int uid,mengen_t newmenge, const Petig::Datum &newld,bool dispoplanung) throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"NewMenge=",newmenge,"NewDatum=",newld,"dispoplanung(bool)=",dispoplanung);
 if(entrystatus==CLOSED) return none_znr;

 mengen_t BESTELLT_OLD=bestellt-newmenge;
 int STATUS=entrystatus;

 double GELIEFERT;
 double GELIEFERT_OLD;

 if(lieferdatum>newld)
   {GELIEFERT=(geliefert>newmenge ? mengen_t(newmenge) : geliefert).as_float();
    GELIEFERT_OLD=(geliefert>newmenge ? geliefert-mengen_t(newmenge) : mengen_t(0)).as_float();}
 else
   {GELIEFERT_OLD=(geliefert>BESTELLT_OLD ? mengen_t(BESTELLT_OLD) : geliefert).as_float();
    GELIEFERT=(geliefert>BESTELLT_OLD ? geliefert-mengen_t(BESTELLT_OLD) : mengen_t(0)).as_float();}
    
 Transaction tr;
 Query("lock auftragentry in exclusive mode");
 SQLerror::test("split: lock table auftragentry");

 mengen_t mt=MengeAendern(uid,-newmenge,true,AufEintragBase(),ManuProC::Auftrag::r_Anlegen);
 assert(mt==-newmenge);

 int ZEILENNR;
 if(Instanz()==ppsInstanzID::Kundenauftraege)
   {Auftrag A(*this);
    AufEintragBase newaeb=A.push_back(newmenge,newld,artikel,entrystatus,uid,true,preis,rabatt);
    ZEILENNR=newaeb.ZNr();
   }
 else
   ZEILENNR=split_zuordnungen_to(newmenge,newld,artikel,entrystatus,uid,dispoplanung);

 if(STATUS==OPEN)
   {   pps_ChJournalEntry::newChange(
    			instanz, *this,
    			artikel, BESTELLT_OLD.as_float(), (BESTELLT_OLD-bestellt).as_float(),
    			pps_ChJournalEntry::CH_MENGE);
       pps_ChJournalEntry::newChange(
    			instanz, *this,
    			artikel, newmenge.as_float(), newmenge.as_float(),
    			pps_ChJournalEntry::CH_MENGE);
   }

 tr.commit();
 return ZEILENNR;
}

AufEintrag::AufEintrag(const AufEintragBase &aebb) throw (SQLerror,NoAEB_Error)
  : AufEintragBase(aebb), 
    artikel(0),
    prozess(Prozess::default_id)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,aebb);
 try{
  SelectedFullAufList aufids((SQLFullAuftragSelector)
    (SQLFullAuftragSelector::sel_AufidZnr(aebb)));

  if ( aufids.aufidliste.size()!=1 ) throw NoAEB_Error(aufids.aufidliste.size());

  *this=*(aufids.aufidliste.begin());
 } catch (SQLerror &e) {std::cerr << e <<'\n';}
}

// hässlich ! warum denn ein cH_Lieferschein statt eines LieferscheinEntryBase?
cH_Lieferschein AufEintrag::getLieferschein() const
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__);
  int LFRSID,LFRZNR;
 // bislang cH_Lieferschein(ppsInstanzID::None,0); wenn keine Zeile
 // jetzt SQLerror
 Query("select lfrsid,zeile from lieferscheinentry "
 	"where (instanz,refauftragid,refzeilennr)=(?,?,?) "
 	"limit 1").lvalue()
 	<< instanz->Id() << Id() << ZNr()
 	>> LFRSID >> LFRZNR;
#warning kann es mehr als eine Zeile geben? 
 return cH_Lieferschein(Instanz(),LFRSID);
}
