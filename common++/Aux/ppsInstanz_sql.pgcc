#include "ppsInstanz.h"
#include <Aux/SQLerror.h>
#include <Aux/Transaction.h>
exec sql include sqlca;

cH_ppsInstanz::cache_t cH_ppsInstanz::cache;

cH_ppsInstanz::cH_ppsInstanz(ppsInstanz::ID iid) 
{ 
 cH_ppsInstanz *cached(cache.lookup(iid));
 if (cached) *this=*cached;
 else 
  { *this=cH_ppsInstanz(new ppsInstanz(iid));
    cache.Register(iid,*this);
  }
}


void ppsInstanz::get_name()
{
 if(instid == ppsInstanzID::None) return;
 try{

 exec sql begin declare section;
   char db_name[50];
   int db_nr=instid,db_lager_fuer, db_best_fuer,db_sortierung;
   int IN;
   bool db_liefer;
   char db_lagername[50];
 exec sql end declare section;
 IN=ppsInstanzID::None;
 exec sql select name,coalesce(lager_fuer,:IN),sortierung ,
      coalesce(lieferschein,'f'),coalesce(lagername,'')
      into :db_name,:db_lager_fuer,:db_sortierung ,:db_liefer,:db_lagername
      from prod_instanz where insid= :db_nr;
 SQLerror::test(__FILELINE__);
// if(sqlca.sqlcode) *db_name=0;

//cout << instid<< ' ' <<db_name<<' '<<db_lager_fuer<<' '
//<<db_sortierung<<' '<<db_liefer<<' '<<db_lagername<<'\n';
 name=db_name;
 lager_fuer=ID(db_lager_fuer);
 sortierung=db_sortierung;
 lieferschein=db_liefer;
 lagername=db_lagername;

  exec sql select insid into :db_best_fuer from prod_instanz 
         where lager_fuer=:db_nr;
  SQLerror::test(__FILELINE__,100);
  if(sqlca.sqlcode) bestellung_fuer=ppsInstanzID::None;
  else              bestellung_fuer=ID(db_best_fuer);
 }catch(SQLerror &e) {cerr<<e<<'\n'; exit(1);}
}

cH_Prozess ppsInstanz::get_Prozess() const
{
  switch(instid) {
#if defined PETIG_EXTENSIONS && defined MANUPROC_DYNAMICENUMS_CREATED
	case ppsInstanzID::Faerberei: return cH_Prozess(ProzessID::Faerben);break;
	case ppsInstanzID::Druckerei: return cH_Prozess(ProzessID::Drucken);break;
	case ppsInstanzID::Weberei: return cH_Prozess(ProzessID::Weben);break;
	case ppsInstanzID::Schaererei: return cH_Prozess(ProzessID::Schaeren);break;
	case ppsInstanzID::Spritzgiesserei: return cH_Prozess(ProzessID::Giessen);break;
#endif	
        default : return cH_Prozess(ProzessID::Verarbeitung); break;
	}
}

bool ppsInstanz::LagerInstanz() const
{
  if (LagerFuer()!=ppsInstanzID::None) return true;
  return false;
}

std::string ppsInstanz::shortName() const
{
  std::string s=Name();
  s=s.substr(0,2);
  return s;
}


std::vector<cH_ppsInstanz> cH_ppsInstanz::get_all_instanz()
{
 vector<cH_ppsInstanz> v;
 try{
  exec sql begin declare section;
    int db_i;
  exec sql end declare section;
  exec sql declare ins_ein cursor for select insid from 
      prod_instanz order by sortierung;
  Transaction tr;
  exec sql open ins_ein;
  SQLerror::test(__FILELINE__);
  while (true)
   {
     exec sql fetch ins_ein into :db_i;
     SQLerror::test(__FILELINE__,100);
     if (sqlca.sqlcode) break;
     v.push_back(cH_ppsInstanz(ppsInstanz::ID(db_i)));
   }
 }catch(SQLerror &e){cerr << e<<'\n';}
 return v;
}

