#include "auftrag_main.hh"
#include <Aux/SQLerror.h>
#include <Aux/Transaction.h>
exec sql include sqlca;
#include <Aux/FetchIStream.h>

int auftrag_main::get_next_entry_znr(AuftragBase& auftrag)
{
 exec sql begin declare section;
   int db_instanz;
   int db_aufid;
   int db_maxznr;
 exec sql end declare section;
 db_aufid=auftrag.Id();
 db_instanz=auftrag.Instanz();
 exec sql SELECT coalesce(max(zeilennr),0) into :db_maxznr from auftragentry 
   where auftragid=:db_aufid and instanz=:db_instanz;
 SQLerror::test(__FILELINE__,100);
 if (sqlca.sqlcode) db_maxznr=0; 
 return db_maxznr+1;
}


/*
void auftrag_main::instanz_menu()
{
  try{
  menu_an_instanz=manage(new Gtk::Menu());

  exec sql allocate descriptor mydesc;
  exec sql begin declare section;
   char query[1024];
   char db_name[50];
   int db_insnr;
  exec sql end declare section;
  std::string squery="select insid,name from prod_instanz order by insid";  
  snprintf(query,sizeof(query),squery.c_str());

  Transaction tr;
  exec sql prepare instanz_ein_ from :query ;
  exec sql declare instanz_ein cursor for instanz_ein_ ;
  exec sql open instanz_ein;
  SQLerror::test(__FILELINE__);

  while (true)
   {  
      exec sql fetch instanz_ein into :db_insnr, :db_name;
      SQLerror::test(__FILELINE__,100);
      if (sqlca.sqlcode) break; 

      Gtk::MenuItem *mi = manage(new class Gtk::MenuItem(db_name));
      menu_an_instanz->append(*mi);
      mi->activate.connect(SigC::bind(SigC::slot(this,&auftrag_main::an_instanz_selected)
            ,(ppsInstanz::ID)db_insnr));
      mi->show();
   }

  exec sql close instanz_ein;  
  tr.close();

  menu_an_instanz->show();
  }  catch (SQLerror &e)
   {  std::cerr << e << '\n';}

}
*/

void auftrag_main::on_searchcombo_auftragid_search(int *cont, GtkSCContext newsearch)
throw(SQLerror)
{
 exec sql begin declare section;
 int AUFID;
 char AUFIDCHR[10];
 char *PAT;
 int KUNDE=1;
 int INSTANZ;
 exec sql end declare section;
 INSTANZ=instanz->Id();
 static bool transaction = false;
  
 switch(newsearch)
   {
    case GTK_SEARCH_OPEN :
      {
       std::string pat = searchcombo_auftragid->get_text() + "%";
       PAT = (char*)pat.c_str();
       
       exec sql begin;
       SQLerror::test(__FILELINE__"begin",ECPG_NOTICE_IN_TRANSACTION);
       transaction = sqlca.sqlcode!=ECPG_NOTICE_IN_TRANSACTION;
                   
       exec sql declare AUFNR_CURSOR cursor for
       		select auftragid, ltrim(to_char(auftragid,'000000'))
       		from auftrag where
       		ltrim(to_char(auftragid,'000000')) like :PAT
                and (:KUNDE<1 or kundennr=:KUNDE)
                and instanz = :INSTANZ
       		order by auftragid;
       	
       exec sql open AUFNR_CURSOR;
       SQLerror::test(__FILELINE__":on_aufnrscombo_search: open cursor",
       						transaction);
      } 							
           
  case GTK_SEARCH_FETCH :
       {
        exec sql fetch AUFNR_CURSOR into :AUFID, :AUFIDCHR;
	SQLerror::test(__FILELINE__":on_aufnrscombo_search: "
			" fetch","AUFNR_CURSOR",100,transaction);
			
	if(sqlca.sqlcode==100){*cont=false; break; }
	
	searchcombo_auftragid->add_item(AUFIDCHR,AUFID);
	*cont=true;
        break;
       }
 
  case GTK_SEARCH_CLOSE :
       {
	exec sql close AUFNR_CURSOR;
	if(transaction) exec sql commit;
	break;
       }
  }
}

