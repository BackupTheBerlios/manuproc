/*  pps: ManuProC's production planning system
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/Auftrag.h>
#include<stdio.h>
#include <Aux/Transaction.h>
#include<Aux/Changejournal.h>
#include <Auftrag/auftrag_status.h>
#include "AufEintrag.h"
#include <Artikel/ArtikelStamm.h>
#include <Auftrag/AufEintragZu.h>
#include <Lager/Lager_Vormerkungen.h>

exec sql include sqlca;


AuftragBase::AuftragBase(cH_ppsInstanz _instanz, int aufid,int kid) throw(SQLerror)
: instanz(_instanz),auftragid(aufid)
{
 exec sql begin declare section;
   int KID=kid;
   int AID=auftragid;
   int INST=instanz->Id();
   int ID;
 exec sql end declare section;
 exec sql select auftragid into :ID from auftrag where instanz=:INST and
      kundennr=:KID and youraufnr=:AID;
 SQLerror::test(__FILELINE__);	
 *this=AuftragBase(instanz,ID);
}

bool AuftragBase::Exists() const throw(SQLerror)
{
 exec sql begin declare section;
  int AUFTRAGID=Id();
  int INSTANZ=InstanzID();
  bool DUMMY;
 exec sql end declare section;
 exec sql select true into :DUMMY from auftrag where 
	(instanz,auftragid)= (:INSTANZ,:AUFTRAGID);
 SQLerror::test(__FILELINE__,100);
 if(sqlca.sqlcode) return false;
 return true;
}

void AuftragBase::create_if_not_exists(AufStatVal status,Kunde::ID kunde) const
{
//cout << "create_if_not_exists: "<<Exists()<<'\n';
  if(Exists()) return;
//cout << "Anlegen "<<Instanz()->Name()<<' '<<Id()<<'\n';
  exec sql begin declare section;
   int AUFTRAGID=Id();
   int INSTANZ=InstanzID();
   int KUNDE=kunde;
   int STATUS=status;
  exec sql end declare section;
  exec sql insert into auftrag (instanz,auftragid,kundennr,stat) 
      values (:INSTANZ,:AUFTRAGID,:KUNDE,:STATUS);
 SQLerror::test(__FILELINE__);
}


void AuftragBase::setStatusAuftragBase(AufStatVal st) const throw(SQLerror)
{
 exec sql begin declare section;
  int AUFTRAGID=Id();
  int INSTANZ=InstanzID();
  int STATUS=st;
 exec sql end declare section;

 exec sql update auftrag set stat= :STATUS
       where (instanz,auftragid)= (:INSTANZ,:AUFTRAGID);
 SQLerror::test(__FILELINE__"Status setzen");
}




int AuftragBase::insertNewEntry(const mengen_t bestellt, 
  const Petig::Datum lieferdatum,const ArtikelBase& artikel,
  const AufStatVal status,const bool setInstanzAuftraege,
  const Preis& preis,const fixedpoint<2> rabatt) const throw(SQLerror)
{
//std::cout << "insertfunktion: "<<bestellt<<' '
//   <<cH_ArtikelBezeichnung(artikel)->Bezeichnung()<<' '<<Id()<<'\n';
 exec sql begin declare section;
 int AUFTRAGID =Id();
 long ARTIKELID=artikel.Id();
 int INSTANZ =InstanzID();
 int ZEILENNR;
 int BESTELLT=bestellt;
 char LIEFERDATUM[21];
 double PREIS=preis.Wert();
 int RABATT=rabatt;
 float PREISMENGE=preis.PreisMenge();
 int STATUS=status;
 exec sql end declare section;
 
 lieferdatum.write_postgres(LIEFERDATUM,sizeof LIEFERDATUM);

 Transaction tr;
 exec sql lock table auftragentry in exclusive mode;
 SQLerror::test("AufEintrag: lock auftragentry");	

 exec sql select coalesce(max(zeilennr)+1,1) into :ZEILENNR from auftragentry
	where (instanz,auftragid)= (:INSTANZ,:AUFTRAGID);
 SQLerror::test("generate next zeilennr");

 exec sql insert into auftragentry (instanz,auftragid, zeilennr,
	bestellt,geliefert,lieferdate,artikelid,status,
	preis,rabatt,preismenge)
	values (:INSTANZ, :AUFTRAGID, :ZEILENNR, :BESTELLT, 0, :LIEFERDATUM,
		:ARTIKELID, :STATUS, :PREIS, :RABATT/100.0,
		:PREISMENGE);
 SQLerror::test(__FILELINE__" insert into auftragentry");	
	
 if(Instanz()==ppsInstanzID::Kundenauftraege)
  { try{
     pps_ChJournalEntry::newChange(
                        instanz,
			AufEintragBase(instanz,AUFTRAGID,ZEILENNR),
                        artikel,
                        (double)BESTELLT,
                        (double)BESTELLT,
                        pps_ChJournalEntry::CH_MENGE);
        }
    catch(SQLerror &e)
      {tr.rollback(); throw; }
  }
//std::cout <<"INSTANZ\n";
 // Kundenaufträge legen automatisch einen Auftrag bei der entsprechenden Instanz 
 // für denselben Artikel an.
 if(Instanz()==ppsInstanzID::Kundenauftraege)
  {
    AuftragBase AB(ArtikelStamm(artikel).BestellenBei(),AuftragBase::ungeplante_id);   
    AB.tryUpdateEntry(bestellt,lieferdatum,artikel,status,AufEintragBase(*this,ZEILENNR));
  }
 else if(setInstanzAuftraege)
    InstanzAuftraegeAnlegen(artikel,ZEILENNR,lieferdatum,status,bestellt);
 tr.commit();
 return ZEILENNR;
}

void AuftragBase::InstanzAuftraegeAnlegen(const ArtikelBase& artikel,
      const int altZnr,const Petig::Datum& lieferdatum,
      const AufStatVal status, const mengen_t menge) const
{
   ArtikelBaum AB(artikel);
//cout << cH_ArtikelBezeichnung(artikel)->Bezeichnung()<<'\n';
   for(ArtikelBaum::const_iterator i=AB.begin();i!=AB.end();++i)
    {
//cout << '\t'<<cH_ArtikelBezeichnung(i->rohartikel)->Bezeichnung()<<'\n';
      AuftragBase neuAuftrag(ArtikelStamm(i->rohartikel).BestellenBei(),0);
      neuAuftrag.tryUpdateEntry(double(i->menge)*menge,lieferdatum,
                 i->rohartikel,status,AufEintragBase(*this,altZnr));
    }
}

bool AuftragBase::existEntry(const ArtikelBase& artikel,
                             const Petig::Datum& lieferdatum,
                             int& znr,int &newznr,mengen_t& menge,
                             AufStatVal status) const throw(SQLerror)
{
 exec sql begin declare section;
   int AUFTRAGID =Id();
   long ARTIKELID=artikel.Id();
   int INSTANZ =InstanzID();
   int ZEILENNR,NEUZNR=-99;
   double MENGE;
   char LIEFERDATUM[21];
   int STATUS=status;
 exec sql end declare section;
 lieferdatum.write_postgres(LIEFERDATUM,sizeof LIEFERDATUM);

 exec sql select zeilennr,neuzeilennr,bestellt into :ZEILENNR, :NEUZNR,:MENGE
   from auftragentry join auftragsentryzuordnung on
   (altauftragid,altinstanz,altzeilennr)=(auftragid,instanz,zeilennr)
	where (instanz,auftragid)= (:INSTANZ,:AUFTRAGID) and
      lieferdate=:LIEFERDATUM and artikelid=:ARTIKELID 
      and status=:STATUS limit 1;
 SQLerror::test(__FILELINE__,100);
 //2.Versuch ohne 'join'
 if (sqlca.sqlcode==100) ;
  { 
    exec sql select zeilennr,bestellt into :ZEILENNR, :MENGE
      from auftragentry 
   	where (instanz,auftragid)= (:INSTANZ,:AUFTRAGID) and 
      lieferdate=:LIEFERDATUM and artikelid=:ARTIKELID 
      and status=:STATUS limit 1;
    SQLerror::test(__FILELINE__,100);
   }

 if (sqlca.sqlcode==100) return false;
 else  {
//std::cout << "EXIST=TRUE\n";
    znr=ZEILENNR;
    newznr=NEUZNR;
    menge=MENGE;
    return true;  }
}


#include <Artikel/ArtikelBezeichnung.h> //debug
int AuftragBase::tryUpdateEntry(mengen_t bestellt, 
  const Petig::Datum lieferdatum,const ArtikelBase& artikel,
  AufStatVal status,const AufEintragBase& altAEB,bool force_new) 
      const throw(SQLerror)
{
 create_if_not_exists(status);
//std::cout << "Try: "<<altAuftrag.Instanz()->Name()<<' '<<altAuftrag.Id()<<' '<<altZnr<<'\n';
// AufEintragBase AEB(altAuftrag,altZnr);
//std::cout << "\tErfolg\n";
 int znr=-99,neuznr=-99;
 mengen_t menge=0;
 Transaction tr;
 exec sql lock table auftragentry in exclusive mode;
 SQLerror::test(__FILELINE__);  
 if(force_new || !existEntry(artikel,lieferdatum,znr,neuznr,menge,status))
  {
//cout << "Neu\t";
//cout << Instanz()->Name()<<"\n";
    if(Instanz()->LagerInstanz())
     {
       znr=insertNewEntry(bestellt,lieferdatum,artikel,status,false)  ;
//cout << Instanz()->Id()<<' '<<Id()<<" znr"<<' '<<znr<<'\t'<<bestellt<<'\t'<<status<<'\n';
       Lager_Vormerkungen(class AufEintrag(Instanz()->Id(),Id(),znr,bestellt,artikel,lieferdatum,status)).vormerken_oder_bestellen();
//cout << "F\n";
     }
    else 
       znr=insertNewEntry(bestellt,lieferdatum,artikel,status,true)  ;
//std::cout << "Zeile: "<<znr<<'\n';
//   AufEintragZu(XAEB).AuftragsEntryZuordnung(bestellt,*this,znr);
   AufEintragZu(altAEB).Neu(AufEintragBase(*this,znr),bestellt);
  }
 else
  {
//cout << "Alt\t"<<znr<<' '<<altZnr<<' '<<neuznr<<' '
//<<AufEintragBase(instanz,auftragid,znr).ZNr()<<"  MENGE:"<<bestellt<<'\n';
    try{ mengen_t mt=AufEintragZu(altAEB).setMengeDiff__(AufEintragBase(*this,znr),bestellt);
         assert(mt==bestellt); } catch(SQLerror &e)
      { AufEintragZu(altAEB).Neu(AufEintragBase(*this,znr),bestellt);}
//std::cout << "\t"<<instanz->Name()<<' '<<auftragid<<' '<<znr<<' '
//<<cH_ArtikelBezeichnung(artikel)->Bezeichnung()<<' '<<menge<<'+'<<bestellt<<' '<<status<<'\n';
//std::cout << "Alt\t"<<znr<<' '<<altZnr<<' '<<AufEintragBase(instanz,auftragid,znr).ZNr()<<'\n';
//cout << Instanz()->Name()<<"  Lager ? : "<<ppsInstanz::LagerInstanz(InstanzID())<<'\n';
    if(Instanz()->LagerInstanz())
       Lager_Vormerkungen(class AufEintrag(Instanz()->Id(),Id(),znr,bestellt,artikel,lieferdatum,status)).vormerken_oder_bestellen();
    else 
       InstanzAuftraegeAnlegen(artikel,znr,lieferdatum,status, bestellt) ;
    mengen_t mt=AufEintragBase(instanz,auftragid,znr).updateStkDiff__(bestellt);
    assert(mt==bestellt);
  }
  tr.commit();
  return znr;
}

const std::string AuftragBase::getStatusStr(AufStatVal a)
{
 switch(a)
   {case (AufStatVal)UNCOMMITED : return "unbestätigt"; 
    case (AufStatVal)OPEN : return "offen"; 
    case (AufStatVal)CLOSED : return "fertig";
    case (AufStatVal)STORNO : return "storno";
   }
 return "-";
}

