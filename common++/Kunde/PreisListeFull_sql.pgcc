/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 2002 Adolf Petig GmbH & Co. KG
 *  written by Jacek Jakubowski, Christof Petig, Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */


#include <Kunde/PreisListeFull.h>
#include <Misc/itos.h>
#include <Misc/Transaction.h>
#include <ExtBezSchema/ExtBezSchemaHandle.h>
#include <ExtBezSchema/ExtBezSchema.h>
#include <DynamicEnums/DynamicConfig.h>

void PreisListeFull::load_preisliste(bool with_artbez,
	ID id, bool art_in_list, ArtikelTyp at)
{
 std::string bezkomps,bezorder;
 std::string beztable;
 int signifikanz=1;
 int ean_sign=ArtikelTyp::none_id;
 int bez_sign=ArtikelTyp::none_id; 
 
 cH_ExtBezSchema ebz(ExtBezSchema::default_id,at);
 bool mit_ean = ArtikelTyp::hasAttribute(at.Id(),
           ManuProC::DynamicEnums::ArtikelTyp_Attributes::mit_ean);
 bool mit_bez = ArtikelTyp::hasAttribute(at.Id(),
           ManuProC::DynamicEnums::ArtikelTyp_Attributes::mit_bezeichnung);
 
 if(with_artbez)
   {
    bez_columns.erase(bez_columns.begin(),bez_columns.end());
    
    ExtBezSchema::const_sigiterator bezit=ebz->sigbegin(signifikanz);
    ExtBezSchema::const_sigiterator bezend=ebz->sigend(signifikanz);    
    for(;bezit!=bezend;++bezit)
      {bezkomps+=" atoi(b."+(*bezit).spaltenname+") as "+(*bezit).spaltenname+",";
       bezorder+=" "+(*bezit).spaltenname+",";
       bez_columns.push_back((*bezit).bezkomptext);
      }
    beztable = " artbez_"+itos(at)+"_"+itos(ebz->Id());

#ifdef GLOB_SET_EAN_SIGN_BASENAME    
    if(mit_ean)
      {ean_sign=at.SpecialSignifikanz(
            std::string(GLOB_SET_EAN_SIGN_BASENAME)+itos(at.Id()));
       ExtBezSchema::const_sigiterator eanit=ebz->sigbegin(ean_sign);
       ExtBezSchema::const_sigiterator eanend=ebz->sigend(ean_sign);    
       mit_ean=false;
       for(;eanit!=eanend;++eanit)
         {bezkomps+=" b."+(*eanit).spaltenname+",";
          mit_ean=true;
          bez_columns.push_back((*eanit).bezkomptext);}
      }
#endif
#ifdef GLOB_SET_BEZ_SIGN_BASENAME          
    if(mit_bez)
      {bez_sign=at.SpecialSignifikanz(
            std::string(GLOB_SET_BEZ_SIGN_BASENAME)+itos(at.Id()));
       ExtBezSchema::const_sigiterator bezit=ebz->sigbegin(bez_sign);
       ExtBezSchema::const_sigiterator bezend=ebz->sigend(bez_sign);    
       mit_bez=false;
       for(;bezit!=bezend;++bezit)
         {bezkomps+=" b."+(*bezit).spaltenname+",";      
          mit_bez=true;
          bez_columns.push_back((*bezit).bezkomptext);}
      }
#endif
      
   }

   

 std::string qu;
 payoff.erase(payoff.begin(),payoff.end());

  
 std::string plid=itos(RealId());
 std::string preis_sel=getPreisSelClausel();
 
 if(art_in_list)
   {qu=std::string("select ");
	if(with_artbez)
          qu+=bezkomps;
	qu+=" artikelid,"+preis_sel+",preismenge,coalesce(mindestmenge,1),"
	" coalesce(k.pl_parent,-1) as parent"
        " from artikelpreise p join ku_preisliste k on "
        " (k.prlsnr=p.kundennr and p.kundennr="+plid+")"
 	" join artikelstamm s on (p.artikelid=s.id and "
	" s.warengruppe="+itos(at.Id())+") ";
    if(with_artbez)
      qu+=" join "+beztable+" b using (id) ";

    if(isDepending())
      {  
       qu+=" UNION ";
       qu+=" (select ";
       if(with_artbez)
          qu+=bezkomps;
       qu+="  artikelid,preis,preismenge,coalesce(mindestmenge,1),"
        "  coalesce(k.pl_parent,-1) as parent"
        "  from artikelpreise p join ku_preisliste k on "
        "  (k.prlsnr=p.kundennr and p.kundennr="+itos(id)+")"
        "  join artikelstamm s on (p.artikelid=s.id and "
	" s.warengruppe="+itos(at.Id())+") ";
        if(with_artbez)
          qu+=" join "+beztable+" b using (id) ";
      qu+=") "; // UNION end 
      qu+="order by "+bezorder+" parent";
      }
    else
     if(with_artbez) 
       qu+=" order by "+bezorder+" artikelid";
      
   }
 else
   {
    qu=std::string("select ");
    if(with_artbez)
      qu+=bezkomps;
    qu+=" id,coalesce(preis_alt,0),0,"
	" coalesce(c.mindestmenge,1),-1 from artikelstamm s "
	" left join preis_change_journal c on "
	" (c.artikelid=s.id and c.prlsnr="+itos(id);
    qu+=" and preis_alt is not null and cast(preis_neu as float) = 0.0) ";
    if(with_artbez)
      qu+=" join "+beztable+" b using (id) ";
    qu+=" where not exists"
 	" (select p.artikelid from artikelpreise p"
	"  where p.artikelid=s.id and kundennr = ";
    qu+=itos(id)+") and s.warengruppe="+itos(at.Id())+" order by zeitpunkt";
   }
 
 Query q(qu); 

 FetchIStream is=q.Fetch();

 while(is.good())
   {
    int ARTIKELID;
    float PREIS;
    int PREISMENGE;
    int MINDMENGE;
    int PARENT;
    std::string beztext;
    struct PayOff po;
    
    if(with_artbez)
      {
       for(unsigned int i=0; i<ebz->size(signifikanz); i++)
         {is >> FetchIStream::MapNull(beztext);
          po.b.push_back(cH_EntryValueIntString(beztext));
         }
       if(mit_ean) {is >> FetchIStream::MapNull(beztext);
                    po.b.push_back(cH_EntryValueIntString(beztext));}
       if(mit_bez) {is >> FetchIStream::MapNull(beztext);
                    po.b.push_back(cH_EntryValueIntString(beztext));}
      }
    is  >> ARTIKELID >> PREIS >> PREISMENGE >> MINDMENGE >> PARENT;  

    po.p=Preis(PREIS,getWaehrung(),PREISMENGE);
    po.pl_parent=PARENT;
    payoff[UniqPreis(ARTIKELID,MINDMENGE)]=po;
    sorted_payoff.push_back(po);

    is=q.Fetch();
   }

}


PreisListeFull::PreisListeFull(ID id, bool art_in_list,
			ArtikelTyp at) throw(SQLerror) : PreisListe(id)
{
 load_preisliste(false,id,art_in_list,at);
}

PreisListeFull::PreisListeFull(bool with_artbez,ID id, bool art_in_list,
		ArtikelTyp at) throw(SQLerror) : PreisListe(id)
{
 load_preisliste(with_artbez,id,art_in_list,at);
}


