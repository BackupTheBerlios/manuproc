// $Id: AufEintragZu_sql.pgcc,v 1.18 2003/02/10 14:33:59 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Malte Thoma
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/AufEintragZu.h>
#include <Auftrag/auftrag_status.h>
#include <Artikel/ArtikelBezeichnung.h>
#include <Misc/FetchIStream.h>
#include <Misc/Trace.h>
#include <Misc/FetchIStream_fixedpoint.h>

FetchIStream &operator>>(FetchIStream &i, AufEintragZu::st_reflist &rl)
{  return i >> rl.AEB >> rl.Menge >> rl.Art;
}

AufEintragZu::list_t AufEintragZu::get_Referenz_list(const AufEintragBase& aeb,bool kinder) throw(SQLerror) 
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,aeb,kinder?"Kinder":"Eltern");

 std::string squery;
 if(kinder)
    squery = "select neuinstanz,neuauftragid,neuzeilennr,menge,artikelid "
      "from auftragsentryzuordnung "
      "join auftragentry on (neuinstanz,neuauftragid,neuzeilennr)"
         "= (instanz,auftragid,zeilennr)"
      "where (altinstanz,altauftragid,altzeilennr) = (?,?,?)"
      " order by neuinstanz,neuauftragid,neuzeilennr ";
 else
    squery = "select altinstanz,altauftragid,altzeilennr,menge,artikelid "
      "from auftragsentryzuordnung "
      "join auftragentry on (altinstanz,altauftragid,altzeilennr)"
         "= (instanz,auftragid,zeilennr)"
      "where (neuinstanz,neuauftragid,neuzeilennr) = (?,?,?)"
       " order by altinstanz,altauftragid,altzeilennr" ;
 std::list<st_reflist> vaeb;
 (Query(squery).lvalue() << aeb).FetchArray(vaeb);
 return vaeb;
}

AufEintragZu::list_t AufEintragZu::get_Referenz_list_without_child() const throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);

 std::list<st_reflist> vaeb;
 (Query("select neuinstanz,neuauftragid,neuzeilennr,menge,NULL "
      "from auftragsentryzuordnung "
      "where (altinstanz,altauftragid,altzeilennr) = "
      "(?,?,?)"
      " order by neuinstanz,neuauftragid,neuzeilennr").lvalue() 
      <<  static_cast<const AufEintragBase&>(*this))
  .FetchArray(vaeb);
 return vaeb;
}


std::list<cH_Kunde> AufEintragZu::get_Referenz_Kunden() const throw(SQLerror)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this);
 std::list<cH_Kunde> LK;
 std::list<st_reflist> vaeb = get_Referenz_listFull(false);

 for (std::list<st_reflist>::const_iterator i=vaeb.begin();i!=vaeb.end();++i)
  {
    int kdnr=(Query("select kundennr from auftrag "
    		"where (instanz,auftragid)=(?,?) order by kundennr")
    		<< i->AEB.InstanzID() << i->AEB.Id())
    	.FetchOne<int>(); 
    LK.push_back(cH_Kunde(kdnr));
  }
 LK.sort();
 LK.unique();
 return LK;
}

std::list<AufEintragBase> AufEintragZu::get_AufEintragList_from_Artikel
               (const ArtikelBase& artikel,ppsInstanz::ID instanz,AufStatVal status)
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,"Artikel=",artikel,"Status=",status,"Instanz=",instanz);
  std::list<AufEintragBase> L;
  
  (Query("select instanz,auftragid,zeilennr from auftragentry "
  	"where artikelid=? "
  	"and instanz<>? " //Nur interne Aufträge sind interessant
  	"and auftragid=0 " // Nur die UNGEPLANTEN Aufträge bekommen neue Kinder
  	+(status!=NOSTAT ? " and status="+itos(status) : std::string())+
  	"order by auftragid,zeilennr").lvalue()
    << artikel.Id() << int(ppsInstanzID::Kundenauftraege))
  .FetchArray(L);
  return L;
}

void AufEintragZu::Neu(const AufEintragBase& neuAEB,
                       const mengen_t menge,const int oldZnr)
{ AufEintragBase vonAEB(*this);
  if (oldZnr) vonAEB=AufEintragBase(AuftragBase(*this),oldZnr);
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,vonAEB,
      "--",menge,"-->",neuAEB,oldZnr?" OldZNr ":"");

 // erst erhöhen versuchen 
 try{ mengen_t mt=setMengeDiff__(neuAEB,menge); 
      assert(menge==mt);
    }
 catch (SQLerror &e) // anlegen
 {  Query("insert into auftragsentryzuordnung "
         "(altinstanz,altauftragid,altzeilennr, menge, "
           "neuinstanz,neuauftragid,neuzeilennr) "
         "values (?,?,?, ?, ?,?,?)").lvalue() 
      << vonAEB << menge << neuAEB;
    SQLerror::test(__FILELINE__);
 }
}

#include <Misc/itos.h>

bool AufEintragZu::setMenge(const AufEintragBase& neuAEB,const mengen_t menge)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,neuAEB,"Menge=",menge);

 Query("update auftragsentryzuordnung set menge=? "
 	"where (altinstanz,altauftragid,altzeilennr, "
 		"neuinstanz,neuauftragid,neuzeilennr)= (?,?,?, ?,?,?)").lvalue()
	<< menge 		
 	<< static_cast<const AufEintragBase&>(*this) << neuAEB;
 SQLerror::test(__FILELINE__,100);
 return !SQLerror::SQLCode();
}


AuftragBase::mengen_t AufEintragZu::setMengeDiff__(const AufEintragBase &neuAEB,mengen_t menge)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,neuAEB,"Menge=",menge);
 if(menge<0)
  {  AuftragBase::mengen_t M;
     Query("select menge from auftragsentryzuordnung "
     	"where (altinstanz,altauftragid,altzeilennr, "
     	       "neuinstanz,neuauftragid,neuzeilennr)= (?,?,?, ?,?,?)").lvalue()
	<< static_cast<const AufEintragBase&>(*this) << neuAEB
	>> M;
     if(mengen_t(M)<-menge) menge=-M;
  }
  if (menge!=0)
  {  Query("update auftragsentryzuordnung set menge=menge+? "
 	"where (altinstanz,altauftragid,altzeilennr, "
 		"neuinstanz,neuauftragid,neuzeilennr)= (?,?,?, ?,?,?)").lvalue()
	<< menge 		
 	<< static_cast<const AufEintragBase&>(*this) << neuAEB;
     SQLerror::test(__FILELINE__);
  }
 return menge;
}


// wer braucht denn so etwas krankes? CP
bool AufEintragZu::setKindZnr(const AufEintragBase& neuAEB)
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,neuAEB);

 Query("update auftragsentryzuordnung set neuzeilennr=? "
 	"where (altinstanz,altauftragid,altzeilennr, "
 		"neuinstanz,neuauftragid)= (?,?,?, ?,?)").lvalue()
	<< neuAEB.ZNr()
 	<< static_cast<const AufEintragBase&>(*this) 
 	<< neuAEB.InstanzID() << neuAEB.Id();
 SQLerror::test(__FILELINE__,100);
 return !SQLerror::SQLCode();
}

void AufEintragZu::moveInstanz(const VonNachDel vdl,const AufEintragBase &oldAEB, const AufEintragBase &newAEB) throw(SQLerror)
{

 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,oldAEB,"VonNachDel=",vdl);

 switch(vdl)
  {
   case Von:
    Query("update auftragsentryzuordnung set "
      "altinstanz=?,altauftragid=?,altzeilennr=? where "
      "(altinstanz,altauftragid,altzeilennr)=(?,?,?)").lvalue()
      	<< newAEB << oldAEB;
    break;
   case Nach:
    Query("update auftragsentryzuordnung set "
      "neuinstanz=?,neuauftragid=?,neuzeilennr=? where "
      "(neuinstanz,neuauftragid,neuzeilennr)=(?,?,?)").lvalue()
      	<< newAEB << oldAEB;
    break;
   case Delete:
    std::cerr << "please use remove instead of " << __PRETTY_FUNCTION__ << '\n';
    remove(oldAEB,newAEB);
    return;
  }
 SQLerror::test(__FILELINE__,100);
}


AuftragBase::mengen_t AufEintragZu::getMenge(const AufEintragBase& aeb) const
{
 ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,*this,aeb);
 return (Query("select menge from auftragsentryzuordnung "
    "where (altinstanz,altauftragid,altzeilennr, "
    	"neuinstanz,neuauftragid,neuzeilennr) = ()").lvalue()
    << static_cast<const AufEintragBase&>(*this) << aeb).FetchOne<int>();
}

bool AufEintragZu::remove(const AufEintragBase& alt,const AufEintragBase& neu)
{
  ManuProC::Trace _t(AuftragBase::trace_channel, __FUNCTION__,alt,neu);

  Query("delete from auftragsentryzuordnung where "
                 "(altinstanz,altauftragid,altzeilennr,"
                 "neuinstanz,neuauftragid,neuzeilennr)"
                 "=(?,?,?, ?,?,?)").lvalue()
      << alt << neu;
 SQLerror::test(__FILELINE__,100);
 return !SQLerror::SQLCode();
}

