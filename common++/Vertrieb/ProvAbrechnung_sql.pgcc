/* $Id: ProvAbrechnung_sql.pgcc,v 1.5 2003/06/20 14:34:19 jacek Exp $ */
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Vertrieb/ProvAbrechnung.h>


ProvAbrechnung::ProvAbrechnung(const Kunde::ID verkid, 	const ID abrnr) 
throw(SQLerror)
: ManuProcEntity<>(abrnr), verkaeufer(Kunde::none_id), entries_valid(false)
{
 exec sql begin declare section;
 int PROVNR=abrnr;
 int VERKNR=verkid;
 char *DATUM=0;
 char *BIS=0;
 char *VOM=0;
 char *NOTIZ=0;
 exec sql end declare section;


 exec sql select datum,bis,vom,notiz into
 	:DATUM,:BIS,:VOM,:NOTIZ from prov_abrechnung
 	where (verknr,provnr) = (:VERKNR,:PROVNR);
 SQLerror::test(__FILELINE__);
 
 verkaeufer=VERKNR;
 datum=ManuProC::Datum(DATUM);
 bis=ManuProC::Datum(BIS);
 vom=ManuProC::Datum(VOM);
 notiz=NOTIZ;

 ECPGfree_auto_mem();

}


ProvAbrechnung* ProvAbrechnung::newProvAbrechnung(const Kunde::ID verkid,
 		ProvAbrechnung::ID abrnr, ManuProC::Datum _bis,
		ManuProC::Datum _vom,
 		const std::string _notiz) throw(SQLerror)
{
 exec sql begin declare section;
 int PROVNR=abrnr;
 int VERKNR=verkid;
 char *BIS;
 char *VOM;
 char *NOTIZ;
 exec sql end declare section;

 if(!_bis.valid()) _bis=ManuProC::Datum::today();

 BIS=(char*)_bis.to_iso().c_str();
 VOM=(char*)_vom.to_iso().c_str();
 NOTIZ=(char*)_notiz.c_str();

 exec sql insert into prov_abrechnung
	(provnr,verknr,datum,bis,vom,notiz) values 
	(:PROVNR,:VERKNR,date(now()),:BIS,:VOM,:NOTIZ);
 SQLerror::test(__FILELINE__);
 
 return new ProvAbrechnung(verkid,abrnr);
}


FetchIStream &operator>>(FetchIStream &is, ProvAbrechnung::FetchStruct &st)
{
 return is >> st.rngid >> st.zeilennr >> st.provsatz;
}


void ProvAbrechnung::loadEntries(std::string sql_order) throw(SQLerror)
{
 if(entries_valid) return;
 
 std::vector<FetchStruct> st;

 Query Q("select p.rngid,p.zeilennr,coalesce(e.provsatz,0) from prov_entry p"
	" join rechnungentry e on (p.rngid=e.rngid and p.zeilennr=e.zeilennr"
	" and (p.provnr,p.verknr)=(?,?)) "+sql_order);

 Q << itos(Id()) << itos(verkaeufer);

 SQLerror::test(__FILELINE__,100);

 if(!Q.good()) return;  // sqlcode=100
 Q.FetchArray(st); 

 for(std::vector<FetchStruct>::const_iterator i=st.begin(); i!=st.end(); ++i)
   {
    entries.push_back(new ProvAbrechnungEntry(Id(),verkaeufer,(*i).rngid,
    			(*i).zeilennr,(*i).provsatz));
   }
 entries_valid=true;
 
}


