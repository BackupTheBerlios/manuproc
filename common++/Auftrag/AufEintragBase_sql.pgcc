// $Id: AufEintragBase_sql.pgcc,v 1.10 2001/11/05 08:58:29 christof Exp $
/*  libcommonc++: ManuProC's main OO library
 *  Copyright (C) 1998-2000 Adolf Petig GmbH & Co. KG, written by Jacek Jakubowski
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <Auftrag/AufEintragBase.h>
#include <stdio.h>
#include <Aux/string0.h>
#include <Aux/Transaction.h>
#include "auftrag_status.h"
#include <Aux/Changejournal.h>
#include "selFullAufEntry.h"


exec sql include sqlca;

void AufEintragBase::setStatus(AufStatVal st) throw(SQLerror)
{exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int INSTANZ=instanz->Id();
 int ZEILENNR = zeilennr;
 int STATUS=st;
 exec sql end declare section;

#warning was ist mit status (Auftragsstatus), kann das ignoriert werden?
 if(entrystatus == CLOSED) return; // nichts geht mehr
 if(st == UNCOMMITED) return; // zurück geht nicht, nur vor
 if(entrystatus == st) return;     // nichts geändert

 if(st == OPEN && entrystatus != UNCOMMITED) return; // nur UNCOMMITED->OPEN

 Transaction tr; 
 
 exec sql update auftragentry set status= :STATUS
	where auftragid= :AUFTRAGID and zeilennr= :ZEILENNR 
   and instanz =:INSTANZ;
 SQLerror::test("setStatus: update auftragentry");


 if(st==OPEN)
  {try 
   {
    pps_ChJournalEntry::newChange(
			instanz,
			AufEintragBase2(instanz,AUFTRAGID,ZEILENNR),
			artikel,
			(double)bestellt,
			(double)bestellt,
			pps_ChJournalEntry::CH_MENGE);
   }
   catch(SQLerror &e)
     {tr.rollback(); throw; }
  }
 else if(st==CLOSED && entrystatus!=UNCOMMITED) 
 // UNCOMMITED->CLOSED => kein Eintrag
  {try 
   {
    pps_ChJournalEntry::newChange(
			instanz,
			AufEintragBase2(instanz,AUFTRAGID,ZEILENNR),
			artikel,
			(double)geliefert,
			(double)geliefert-bestellt,
			pps_ChJournalEntry::CH_MENGE);
   }
   catch(SQLerror &e)
     {tr.rollback(); throw; }
  } 

 entrystatus=(AufStatVal)STATUS;
 tr.commit(); 
}


void AufEintragBase::updateStk(long stk) throw(SQLerror)
{exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int INSTANZ=instanz->Id();
 int ZEILENNR = zeilennr;
 long BESTELLT = stk;
 exec sql end declare section;

 Transaction tr;

 exec sql update auftragentry set bestellt= :BESTELLT
 	where auftragid= :AUFTRAGID and zeilennr= :ZEILENNR
   and instanz =:INSTANZ;
 SQLerror::test("updateStk: update stk in auftragentry");
 
 if(status==OPEN)
  {
   try 
    {
     pps_ChJournalEntry::newChange(
  			instanz,
  			AufEintragBase2(instanz,AUFTRAGID,ZEILENNR),
  			artikel,
  			(double)BESTELLT,
  			(double)(BESTELLT-bestellt),
  			pps_ChJournalEntry::CH_MENGE);
    }
   catch(SQLerror &e)
     {tr.rollback(); throw; }
  }
 
 bestellt=BESTELLT;
 tr.commit(); 
}

void AufEintragBase::updatePreis(const Preis &pr) throw(SQLerror)
{exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int ZEILENNR = zeilennr;
 int INSTANZ=instanz->Id();
 float PREIS=pr.Wert();
 float PREISMENGE=pr.PreisMenge();
 exec sql end declare section;
 
 exec sql update auftragentry 
 	set preis= :PREIS, preismenge= :PREISMENGE
 	where auftragid= :AUFTRAGID and zeilennr= :ZEILENNR
   and instanz=:INSTANZ;
 SQLerror::test("updatePreis: update preis in auftragentry");
 preis=pr;
}


void AufEintragBase::updateRabatt(int rb) throw(SQLerror)
{exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int INSTANZ=instanz->Id();
 int ZEILENNR = zeilennr;
 int RABATT = rb;
 exec sql end declare section;

 exec sql update auftragentry set rabatt= :RABATT/100.0
 	where auftragid= :AUFTRAGID and zeilennr= :ZEILENNR
   and instanz=:INSTANZ;
 SQLerror::test("updateRabatt: update rabatt in auftragentry");
 
 rabatt=RABATT;
}


void AufEintragBase::updateLieferdatum(const Petig::Datum &ld) throw(SQLerror)
{exec sql begin declare section;
 int AUFTRAGID = auftragid;
 int INSTANZ=instanz->Id();
 int ZEILENNR = zeilennr;
 char LIEFERDATUM[21];
 exec sql end declare section;

 Transaction tr;

 ld.write_postgres(LIEFERDATUM,sizeof LIEFERDATUM);
 
 exec sql update auftragentry set lieferdate= :LIEFERDATUM
 	where auftragid= :AUFTRAGID and zeilennr= :ZEILENNR
   and instanz=:INSTANZ;
 SQLerror::test("updateLiefDatum: update lieferdate in auftragentry");

 if(status==OPEN)
  {
   try 
    {
     pps_ChJournalEntry::newChange(
  			instanz,
  			AufEintragBase2(instanz,AUFTRAGID,ZEILENNR),
  			artikel,
  			ld,
  			(double)(ld-getLieferdatum()),
  			pps_ChJournalEntry::CH_LIEFDAT);
    }
   catch(SQLerror &e)
     {tr.rollback(); throw; }
  }
 
 lieferdatum=ld;
 tr.commit(); 
}

void AufEintragBase::split(int newmenge, const Petig::Datum &newld) throw(SQLerror)
{
 exec sql begin declare section;
 int AUFTRAGID=auftragid;
 int INSTANZ=instanz->Id();
 int ZEILENNR_OLD=zeilennr;
 long ARTIKELID=artikel.Id();
 long BESTELLT=newmenge;
 long BESTELLT_OLD=bestellt-newmenge;
 int STATUS=status;
 float PREIS = preis.Wert();
 int RABATT = rabatt;
 float PREISMENGE = preis.PreisMenge();
 int WAEHRUNG=preis.getWaehrung()->Id();

 int ZEILENNR;
 long GELIEFERT;
 long GELIEFERT_OLD;
 char LIEFERDATUM[21];
 exec sql end declare section;
 
 if(status==CLOSED) return;

 newld.write_postgres(LIEFERDATUM,sizeof LIEFERDATUM);
 
 if(lieferdatum>newld)
   {GELIEFERT=geliefert>BESTELLT ? (BESTELLT) : geliefert;
    GELIEFERT_OLD=geliefert>BESTELLT ? geliefert-BESTELLT : 0;}
 else
   {GELIEFERT_OLD=geliefert>BESTELLT_OLD ? (BESTELLT_OLD) : geliefert;
    GELIEFERT=geliefert>BESTELLT_OLD ? geliefert-BESTELLT_OLD : 0;}
    
 Transaction tr;
// exec sql lock auftragentry in share mode;
 // don't we need access exclusive mode???
 // what if two people split concurrently seperate lines - second will fail
 exec sql lock auftragentry in exclusive mode;
 SQLerror::test("split: lock table auftragentry");
   
 exec sql select (max(zeilennr))+1 into :ZEILENNR from auftragentry
	where auftragid= :AUFTRAGID and instanz =:INSTANZ;
 SQLerror::test("split: select max(zeielnnr) auftragentry");

 exec sql insert into auftragentry (auftragid, zeilennr, artikelid,
		bestellt, geliefert, lieferdate,
		status,preis,rabatt,preismenge, waehrung)
	values ( :AUFTRAGID, :ZEILENNR, :ARTIKELID,
		:BESTELLT, :GELIEFERT, :LIEFERDATUM,
		:STATUS, :PREIS, :RABATT/100.0,
		:PREISMENGE, :WAEHRUNG);
 SQLerror::test("split: insert into auftragentry");

 exec sql update auftragentry set bestellt= :BESTELLT_OLD,
	geliefert= :GELIEFERT_OLD
	where auftragid= :AUFTRAGID and zeilennr= :ZEILENNR_OLD
   and instanz=:INSTANZ;
 SQLerror::test("split: update auftragentry");

 if(STATUS==OPEN)
   {
    try 
      {
       pps_ChJournalEntry::newChange(
    			instanz,
    			AufEintragBase2(instanz,AUFTRAGID,ZEILENNR_OLD),
    			ArtikelBase(ARTIKELID),
    			(double)BESTELLT_OLD,
    			(double)(BESTELLT_OLD-bestellt),
    			pps_ChJournalEntry::CH_MENGE);

       pps_ChJournalEntry::newChange(
    			instanz,
    			AufEintragBase2(instanz,AUFTRAGID,ZEILENNR),
    			ArtikelBase(ARTIKELID),
    			(double)BESTELLT,
    			(double)BESTELLT,
    			pps_ChJournalEntry::CH_MENGE);
      }
     catch(SQLerror &e)
       {tr.rollback(); throw; }
   }

 tr.commit();
}

AufEintragBase::AufEintragBase(const AufEintragBase2 &aebb) throw (SQLerror)
  : AufEintragBase2(aebb), 
    artikel(0),
    prozess(Prozess::default_id)
{
 try{
  SelectedFullAufList aufids((SQLFullAuftragSelector)
    (SQLFullAuftragSelector::sel_AufidZnr(aebb)));
  assert(aufids.aufidliste.size()==1);
  (*this)=aufids.aufidliste[0];
 } catch (SQLerror &e) {std::cerr << e <<'\n';}
}


void AufEintragBase::abschreiben(int menge) throw(SQLerror)
{
 geliefert=AufEintragBase2::abschreiben(menge);
// rest = bestellt-geliefert;
 if(geliefert>=bestellt) status=(AufStatVal)CLOSED;
}


list<pair<AufEintragBase2,long> > AufEintragBase::get_Referenz_list(const AufEintragBase2& aeb) const throw(SQLerror) 
{
 exec sql begin declare section;
  int INSTANZ=aeb.Instanz();
  int AUFTRAGID=aeb.Id();
  int ZEILENNR=aeb.ZNr();
  int OLDINSTANZ[30],OLDAUFTRAGID[30],OLDZEILENNR[30];
  long MENGE[30];
 exec sql end declare section;
 Transaction tr;
 exec sql declare ONAUF cursor for select altauftragid,altinstanz,altzeilennr,menge
   from auftragsentryzuordnung where neuauftragid=:AUFTRAGID and 
      neuinstanz=:INSTANZ and neuzeilennr=:ZEILENNR;
 exec sql open ONAUF;
          
 list<pair<AufEintragBase2, long> > vaeb;
 while(true)
  {
    exec sql fetch 20 in ONAUF into :OLDAUFTRAGID,:OLDINSTANZ,:OLDZEILENNR,:MENGE;
    SQLerror::test(__FILELINE__,100);
    if (sqlca.sqlcode) break;
    int j=sqlca.sqlerrd[2];
    for (int i=0;i<j;++i)
     {
      vaeb.push_back(pair<AufEintragBase2,long> 
            ( AufEintragBase2(cH_ppsInstanz((ppsInstanz::ppsInstId)OLDINSTANZ[i]),
                               OLDAUFTRAGID[i],OLDZEILENNR[i]),MENGE[i]));
     }
    if(j<30) break;
  }
 return vaeb;
}

list<pair<AufEintragBase2,long> > AufEintragBase::get_Referenz_AufEintragBase2(bool ursprung) const throw(SQLerror)
{
 AufEintragBase2 aeb=*this;
 list<pair<AufEintragBase2,long> > tv=get_Referenz_list(aeb);
 if(!ursprung) return tv;
 list<pair<AufEintragBase2,long> > vaeb;
 list<pair<AufEintragBase2,long> > tvxx;
reloop:
 tv.merge(tvxx);
 for (list<pair<AufEintragBase2,long> >::iterator i=tv.begin();i!=tv.end();++i)
   {
     tvxx=get_Referenz_list(i->first);
     if (tvxx.size()==0) vaeb.splice(vaeb.end(),tv,i) ;
     else tv.erase(i) ;
     goto reloop;
   }
 return vaeb;
}

list<cH_Kunde> AufEintragBase::get_Referenz_Kunden_long() const throw(SQLerror)
{
 list<cH_Kunde> LK;
 list<pair<AufEintragBase2,long> > vaeb = get_Referenz_AufEintragBase2();
 exec sql begin declare section;
  int KUNDE;
  int INSTANZ;
  int AUFTRAGID;
 exec sql end declare section;
 for (list<pair<AufEintragBase2,long> >::const_iterator i=vaeb.begin();i!=vaeb.end();++i)
  {
    INSTANZ=i->first.Instanz();
    AUFTRAGID=i->first.Id();
    exec sql select kundennr into :KUNDE from auftrag where
      auftragid=:AUFTRAGID and instanz=:INSTANZ; 
    SQLerror::test(__FILELINE__);
    LK.push_back(cH_Kunde(KUNDE));
  }
 return LK;
}

list<cH_Kunde> AufEintragBase::get_Referenz_Kunden() const throw(SQLerror)
{
 list<cH_Kunde> LK = get_Referenz_Kunden_long();
 LK.sort();
 LK.unique(); // Entfernt Duplikate
 return LK;
}
